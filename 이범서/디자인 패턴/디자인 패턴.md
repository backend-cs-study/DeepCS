## 🎯 디자인 패턴 정리


### 1. **싱글톤 패턴 (Singleton Pattern)**
**설명**  
하나의 클래스에 대해 인스턴스를 하나만 생성하고, 그 인스턴스를 어디서든 공유해서 사용하는 패턴입니다.

**특징**
- 인스턴스가 하나만 존재
- 전역 접근 지점 제공 (`getInstance()`)

**장점**
- 리소스 낭비 방지 (ex. DB 커넥션, 설정 정보)
- 상태 공유가 쉬움
- 인스턴스 생성 비용이 클 때 유리

---

### 2. **팩토리 패턴 (Factory Pattern)**
**설명**  
객체 생성 코드를 별도의 클래스나 메서드로 분리해, 객체 생성 로직을 캡슐화하는 패턴입니다.

**특징**
- 부모 클래스 타입으로 반환
- 객체 생성 책임 분리

**장점**
- 클라이언트는 구현체에 대해 몰라도 됨
- 객체 생성 방식 변경이 쉬움
- OCP(Open-Closed Principle)에 적합

---

### 3. **전략 패턴 (Strategy Pattern)**
**설명**  
알고리즘 군을 정의하고 각각을 캡슐화하여 필요에 따라 알고리즘을 교체할 수 있도록 하는 패턴입니다.

**특징**
- 공통 인터페이스를 통한 유연한 알고리즘 교체
- 객체 조합 기반

**장점**
- 조건문 제거 가능
- 런타임에 알고리즘 변경 가능
- 테스트 및 유지보수 용이

---

### 4. **옵저버 패턴 (Observer Pattern)**
**설명**  
한 객체의 상태 변화가 있을 때, 의존된 다른 객체들에게 자동으로 알림을 보내는 패턴입니다.

**특징**
- Subject(관찰 대상)와 Observer(관찰자) 간 느슨한 결합
- 이벤트 기반 구조

**장점**
- 실시간 데이터 반영 가능
- 다양한 모듈 간 동기화가 쉬움
- 확장성 우수 (구독자 추가 용이)

---

### 5. **프록시 패턴 (Proxy Pattern)**
**설명**  
실제 객체에 대한 접근을 제어하기 위해 대리 객체를 사용하는 패턴입니다.

**특징**
- `RealSubject`와 `Proxy`가 같은 인터페이스를 구현
- 클라이언트는 실제 객체인지 대리 객체인지 모름

**장점**
- 보안, 로깅, 접근 제한 등 부가 기능 제공
- 지연 로딩(Lazy Initialization) 가능
- 리소스 관리 용이

---

### 6. **이터레이터 패턴 (Iterator Pattern)**
**설명**  
컬렉션(리스트, 트리 등)의 내부 구조를 노출하지 않고, 순차적으로 접근할 수 있게 하는 패턴입니다.

**특징**
- 컬렉션 객체의 반복 로직을 분리
- 공통된 반복 인터페이스 제공

**장점**
- 반복 로직을 통일화
- 다양한 컬렉션에 대해 동일한 방식의 순회 가능
- 내부 구조 변경이 자유로움

---

### 7. **노출 모듈 패턴 (Revealing Module Pattern)**
**설명**  
모듈 내에서 외부에 노출하고 싶은 부분만 공개하고, 나머지는 은닉하는 방식입니다. 주로 JavaScript에서 사용됩니다.

**특징**
- IIFE(즉시 실행 함수)와 클로저 활용
- 캡슐화, 정보 은닉

**장점**
- 인터페이스 명확화
- 코드 충돌 방지
- 유지보수와 테스트 용이

---

### 8. **MVC 패턴 (Model-View-Controller)**
**설명**  
애플리케이션을 Model, View, Controller로 분리하여 각각의 역할을 나누는 구조입니다.

**특징**
- Model: 데이터와 비즈니스 로직
- View: 사용자 인터페이스
- Controller: 사용자 입력 처리

**장점**
- 역할 분리가 명확
- 유지보수와 테스트 용이
- 프론트엔드/백엔드 분리 가능

---

### 9. **MVP 패턴 (Model-View-Presenter)**
**설명**  
MVC에서 Controller 대신 Presenter가 등장하며, View 로직까지 Presenter가 관리합니다.

**특징**
- View는 Presenter에게 의존
- View는 Dumb(수동적)

**장점**
- 테스트 용이성 (View를 Mock으로 대체 가능)
- 로직 재사용 쉬움

---

### 10. **MVVM 패턴 (Model-View-ViewModel)**
**설명**  
ViewModel을 통해 View와 Model을 연결하고, 바인딩을 통해 양방향 데이터 동기화가 이루어지는 패턴입니다.

**특징**
- View ↔ ViewModel 간 양방향 바인딩
- ViewModel은 상태 및 로직 담당

**장점**
- View 로직 분리 → 테스트 가능
- 자동 동기화로 UI 코드 감소
- 유지보수 용이

---

## 💬 면접 예상 질문 & 모범 답변

### ❓ Q1. 싱글톤 패턴이란 무엇이며, 언제 사용하나요?
📌 **모범 답변**  
싱글톤 패턴은 클래스의 인스턴스를 하나만 생성하도록 제한하는 패턴입니다. 예를 들어, DB 커넥션 풀, 로깅 시스템처럼 하나의 인스턴스로 관리되어야 하는 경우 사용합니다. Spring에서는 기본적으로 Bean이 싱글톤 스코프로 관리되어, 자연스럽게 싱글톤 패턴이 적용됩니다.

---

### ❓ Q2. 팩토리 패턴의 장점은 무엇인가요?
📌 **모범 답변**  
팩토리 패턴은 객체 생성 로직을 별도의 클래스로 분리함으로써, 객체 생성 과정을 캡슐화합니다. 이를 통해 클라이언트는 생성 방식을 몰라도 객체를 사용할 수 있어, 코드의 유연성과 확장성이 높아집니다.

---

### ❓ Q3. 전략 패턴과 상태 패턴의 차이점은 무엇인가요?
📌 **모범 답변**  
전략 패턴은 알고리즘을 런타임에 교체할 수 있게 해주는 반면, 상태 패턴은 객체의 상태에 따라 행동을 변경합니다. 둘 다 유사하지만 전략은 동작을 캡슐화하고, 상태는 상태 기반의 전환 로직에 초점을 둡니다.

---

### ❓ Q4. 옵저버 패턴은 어떤 상황에서 유용하게 사용되나요?
📌 **모범 답변**  
옵저버 패턴은 이벤트 시스템에 적합합니다. 예를 들어 게시판에 댓글이 달렸을 때, 알림을 여러 사용자에게 전파해야 할 때 사용됩니다. 상태 변화가 여러 객체에 영향을 줄 때 유용합니다.

---

### ❓ Q5. 프록시 패턴과 프록시 서버의 차이점은 무엇인가요?
📌 **모범 답변**  
프록시 패턴은 객체에 대한 접근을 제어하기 위해 대리 객체를 사용하는 소프트웨어 설계 패턴입니다. 반면, 프록시 서버는 네트워크 상에서 클라이언트와 서버 사이에 중계 역할을 하는 서버로, 보안, 캐싱, 로깅 등 다양한 기능을 수행합니다.

---

### ❓ Q6. MVC, MVP, MVVM의 차이는 무엇인가요?
📌 **모범 답변**
- **MVC**는 Controller가 View와 Model을 연결합니다. Web 개발에 많이 사용됩니다.
- **MVP**는 Presenter가 모든 로직을 담당하며 View는 수동적으로 동작합니다. 테스트가 용이합니다.
- **MVVM**은 ViewModel을 통해 View와 Model이 양방향 데이터 바인딩을 합니다. 프론트엔드 프레임워크에서 주로 사용됩니다.

핵심은 **관심사의 분리**를 통해 **유지보수성과 테스트 용이성**을 확보하는 데 있습니다.

---
