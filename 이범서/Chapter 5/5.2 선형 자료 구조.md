# 5-2. 선형 자료 구조
요소가 일열로 나열되어 있는 자료 구조

---

## 1. 연결 리스트
- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료구조
- 삽입, 삭제 시간 복잡도: O(1)
- 탐색 시간 복잡도: O(n)

```
[head] -> [1] -> [2] -> [3] -> [NULL]
```

<br>

## 2. 배열
- 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복 허용, 순서 보장
- 접근 시간 복잡도: O(1), 랜덤 접근 가능
- 삽입, 삭제 시간 복잡도: O(n)

```
[0] [1] [2] [3] [4] ... [n-1]
```

<br>

###  랜덤 접근과 순차적 접근
- 랜덤 접근(직접 접근): 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 순차적 접근: 데이터를 저장된 순서대로 검색

<br>

## 3. 벡터
- 벡터(vector): 동적으로 요소를 할당할 수 있는 동적 배열.
- 컴파일 시점에 개수를 모른다면 벡터를 사용
- 중복 허용, 순서 보장, 랜덤 접근 가능
- 탐색, 뒤의 요소 삽입 및 삭제 시간 복잡도: O(1)
- 중간 요소 삽입 및 삭제 시간 복잡도: O(n)

```
[0] [1] [2] [3] ... [n-1] (동적 확장)
```

<br>

## 4. 스택
- 가장 마지막으로 들어간 데이터가 가장 첫번째로 나오는 자료 구조(LIFO)
- 재귀적인 함수, 알고리즘에 사용, 웹 브라우저 방문 기록 등에 사용
- 삽입 및 삭제 시간 복잡도: O(1)
- 탐색 시간 복잡도: O(n)

```
bottom <- 1 <- 2 <- 3 (top)
```

<br>

## 5. 큐
- 큐: 먼저 집어넣은 데이터가 먼저 나오는 성질을 가지는 자료 구조(FIFO)
- CPU 작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용
- 삽입 및 삭제 시간 복잡도: O(1)
- 탐색 시간 복잡도: O(n)

```
front -> 1 -> 2 -> 3 -> rear
```

---

##  STL 주요 메서드 표

| 자료구조 | 삽입 | 삭제 | 접근 | 기타 |
|----------|------|------|------|------|
| vector   | push_back, insert | pop_back, erase | [i], at(i) | clear, size |
| list     | push_front, push_back, insert | pop_front, pop_back, erase | X | clear, size |
| stack    | push | pop | top | size, empty |
| queue    | push | pop | front, back | size, empty |

---

##  실무 활용 예시

- 스택: 함수 호출 기록, 웹 브라우저 뒤로가기, 괄호 검사
- 큐: BFS, 프린터 대기열, 네트워크 패킷 처리
- 배열/벡터: 데이터 집합, 순차적 데이터 처리
- 연결 리스트: 음악 재생 목록, 삽입/삭제가 잦은 데이터 관리

---

##  자료구조 선택 가이드

| 상황 | 추천 자료구조 | 이유 |
|------|--------------|------|
| 데이터 크기 고정, 빠른 접근 | 배열, vector | O(1) 접근 |
| 삽입/삭제 빈번 | list | O(1) 삽입/삭제 |
| LIFO 필요 | stack | O(1) 삽입/삭제 |
| FIFO 필요 | queue | O(1) 삽입/삭제 |

---

## 면접 질문

### 기본 질문

1. 배열과 연결 리스트의 차이는 무엇인가요?
   - 배열은 연속된 메모리 공간에 저장되어 임의 접근이 빠르며, 연결 리스트는 노드가 포인터로 연결되어 삽입/삭제가 빠릅니다.
2. 벡터(Vector)와 배열(Array)의 차이는 무엇인가요?
   - 벡터는 크기가 동적으로 변하고, 배열은 크기가 고정되어 있습니다.
3. 벡터의 push_back()이 O(1)인 이유는?
   - 메모리 확장 시에는 O(n)이지만, 대부분의 경우는 상수 시간에 동작하므로 평균적으로 O(1)입니다.
4. 스택과 큐의 차이는 무엇인가요?
   - 스택은 LIFO, 큐는 FIFO 구조입니다.
5. 연결 리스트에서 중간에 데이터를 삽입하려면 어떻게 하나요?
   - 해당 위치까지 순회 후, 포인터를 조정하여 삽입합니다.
6. 배열과 벡터 중 어떤 자료구조를 선택해야 할까요?
   - 요소 수가 고정이면 배열, 가변적이면 벡터가 적합합니다.

### 심화 질문

1. 연결 리스트의 단점은 무엇인가요?
   - 임의 접근이 불가능하고, 포인터 저장으로 메모리 사용량이 많으며, 캐시 효율이 떨어집니다.
2. STL의 list, vector, deque의 차이를 설명해주세요.
   - vector: 동적 배열, list: 이중 연결 리스트, deque: 양쪽 끝 삽입/삭제가 빠름.
3. 큐(Queue)의 활용 예시는?
   - BFS, OS의 프로세스 스케줄링, 네트워크 패킷 처리 등.
4. 벡터 대신 연결 리스트를 쓰면 안 되는 이유는?
   - 연결 리스트는 메모리 접근 효율이 낮고, 실제 성능이 벡터보다 떨어질 수 있습니다.
5. Stack을 실무에서 활용하는 예시는?
   - 함수 호출 기록, 트랜잭션 롤백, 중첩 구조 파싱 등.
6. Queue에서 탐색이 O(n)인 이유와 보완 방법은?
   - 순차 탐색이 필요하기 때문이며, HashMap과 조합해 보완할 수 있습니다.

---