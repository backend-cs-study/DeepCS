# Chapter1-1. 디자인 패턴

## 1) 디자인 패턴 개요

> * **라이브러리**: 공통으로 사용될 수 있는 특정한 기능들을 모듈화
> * **프레임워크**: 라이브러리 + 규칙 + 엄격

* **디자인 패턴**: 프로그램을 설계할 때 발생했던 **문제점** -> **해결**할 수 있는 **규약 형태**로 만들어 놓음

<br>

## 2) 싱글톤 패턴 (singleton pattern)

* **싱글톤 패턴** (singleton pattern): **하나의 클래스**에 **하나의 인스턴스**만 가지는 패턴
  * 장점
    * 하나의 인스턴스를 다른 모듈이 공유하면서 **인스턴스를 생성할 때 드는 비용 절약**
  * 단점
    * TDD(Test Driven Development)할 때 어려움(각 단위테스트마다 독립적인 인스턴스를 만들기 어려움)
    * 의존성 상승 (✅ 의존성 주입으로 해결 가능)
  * 사용
    * 데이터베이스 연결 모듈: 데이터베이스 연결에 관한 인스턴스 정의, 인스턴스 기반으로 쿼리를 전송

> ### 📢 의존성 주입
> * **의존성(종속성)**: A가 B의 의존성이 있다는 것은 B의 변경사항에 A 또한 변해야 함
> * **의존성 주입(DI, Dependency Injection)**
>   * **의존성 주입자**가 **의존성을 부여**할 수 있도록 메인 모듈이 **간접적으로 의존성을 주입** (👉 의존성 저하, 디커플링)
>   * 원칙
>     * 상위 모듈은 하위 모듈에서 아무것도 가져오지 말아야 함
>     * 둘다 **추상화에 의존**해야하며, 추상화는 세부사항에 의존하면 안됨
>   * 장점
>     * 모듈을 쉽게 교체할 수 있는 구조 👉 태스팅 또는 마이그레이션(구현체를 바꿈) 쉬움
>     * 추상화 레이어를 통한 구현체 주인으로 **의존성 방향이 일관적**, **쉬운 애플리케이션 추론**, **모듈간 관계 명확**
>   * 단점
>     * 클래스 및 복잡도 증가, 런타임 패널티

<br>

## 3) 팩토리 패턴 (factory pattern)

* **팩토리 패턴** (factory pattern): 객체를 사용하는 코드에서 **객체 생성부분만 추상화**하여, **전달받은 값에 따라 다른 객체 타입 생성**
  * 장점
    * 상위 하위 클래스를 분리하여 **느슨한 결합**을 가지며 **유연성**을 가짐
    * 객체의 생성조직 분리로 **코드 유지보수성 증가**

> ### 📢 static 메서드 (정적 메서드) ( ↔️ 인스턴스 메서드)
> * 클래스 기반으로 객체를 만들지 않고 호출 가능 
> * 해당 메서드에 메모리 할당을 한번만 한다. 
> * 인스턴스 변수를 사용할 수 없다.

> ### 📢 Enum 자료형이란?
> * 상수의 집합을 정의할 때 사용
> * 상수 집합에 대한 조직 수정시 이 부분만 수정하면 되기 때문에 코드 유지보수성에 좋음
> * 스레드 세이프 하여 싱글톤 패턴 생성시 도움이 됨
> > ### ✅ 스레드 세이프(Thread-safe)란?
> > * 여러 스레드에서 동시에 접근해도 문제가 발생하지 않음 
> > * 공유 자원을 사용할 때 동기화가 잘 되어 있어야 스레드 세이프함
> 

<br>

## 4) 전략 패턴 (strategy pattern) / 정책 패턴 (policy pattern)
* **전략 패턴** (strategy pattern): 행위를 바꾸고 싶은 경우 직접 수정하지 않고 **캡슐화한 알고리즘을 컨텍스트 안에서 바꾸**면서 교체
  * 예시
    * Passport 패턴: 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리 (전략 기반 인증)

> ### 📢 컨텍스트
> * 개발자가 어떠한 작업을 완료하는데 필요한 모든 정보

<br>

## 5) 옵저버 패턴 (observer pattern)
* **옵저버 패턴** (observer pattern): 주체가 객체의 상태 변화가 있을 때 마다 옵저버 목록에게 변화를 주는 패턴
  * 사용
    * 이벤트 기반 시스템
    * MVC 패턴: Model에 변경 사항이 생길 경우 옵저버인 뷰에 알려줌, 이를 기반으로 컨트롤러 동작

> ### 📢 이벤트 기반 시스템이란?
> * **이벤트** 가 발생하면 이를 감지하고 처리하는 방식으로 동작하는 시스템 
> * 시스템의 흐름이 이벤트에 의해 결정됨 
> * 컴포넌트 간 직접 호출이 아닌, **메시지를 통한 간접 통신 사용** 
> * 이벤트가 발생하면 → 이벤트를 발행(Publish) → 다른 곳에서 구독(Subscribe) 하고 처리함

> ### 📢 상속(extends)과 구현(implements)
> * **상속(extends)**: 자식클래스가 부모클래스의 메서드 등을 상속 받아 확장 👉 **재사용성, 중복성 최소화**
> * **구현(implements)**: 부모 인터페이스를 자식클래스에서 재정의 하여 구현

> ### 📢 프록시 객체
> 어떠한 대상의 기본적인 동작의 작업을 **가로챌 수** 있는 객체

> ### 📢 DOM (Document Object Model)
> 문서 객체 모델, 웹브라우저상의 화면을 이루는 요소

<br>

## 6) 프록시 패턴 (proxy pattern)
* **프록시 패턴** (proxy pattern): 대상 객체에 접근하기 전 그 접근 흐름을 가로채 해당 접근을 필터링 또는 수정하는 계층(프록시 계층)이 있는 패턴
  * 객체의 속성, 변환 등을 보완
  * 보안, 데이터 검증, 캐싱, 로깅에 사용

> ### 📢 캐싱
> 캐시안에 정보를 넣어두고 캐시 안에 있는 정보를 요구하는 요청에 대해 캐시 안 데이터 활용 👉 불필요한 외부 연결 및 트래픽 감소

### 6-1) 프록시 서버
서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있도록 해주는 시스템 및 응용 프로그램

#### ❶ Nginx
* 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹서버
* Node.js의 앞단에 Nginx를 두어 익명사용자가 직접적으로 서버에 접근하는 것을 차단

> ### 📢 버퍼 오버플로우
> * 버퍼: 데이터가 저장되는 메모리 공간
> * 버퍼 오버플로우: 메모리 공간을 초과하여 데이터 손실이 발생하는 것

> ### 📢 gzip 압축이란?
> DEFLATE 알고리즘을 기반으로한 압축 기술, 데이터 전송량을 줄일 수 있지만, 압축을 해제했을 때 서버에서의 CPU 오버헤드 고려 필요

#### ❷ CloudFlare
* 전세계적으로 분산된 서비스가 있고 이를 통해 어떠한 시스템 전달을 빠르게 할 수 있는 CDN 서비스
* 웹서버 앞에서 프록시 서버로 두어 DDOS 공격 방어, HTTPS 구축에 사용

> ### 📢 DDOS 공격
> 짧은 시간동안 많은 네트워크 요청으로 마비시키는 공격 <br>
> 의심스러운 트래픽을 CloudFlare가 자동 차단

> ### 📢 CDN (Content Delivery Network)
> 각 사용자가 인터넷을 접속하는 곳에서 콘텐츠를 캐싱 및 배포하는 서버 네트워크로 서버 향상

#### ❸ CORS (Cross-Origin Resource Sharing)
* 서버가 웹 브라우저에서 리소스를 로드할 때, 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘

> ### 📢 오리진이란?
> 프로토콜 + 호스트이름 + 포트의 조합

<br>

## 7) 이터레이터 패턴 (iterator pattern)
* **이터레이터 패턴** (iterator pattern): 이터레이터를 이용하여 컬렉션 요소에 접근하는 디자인 패턴
  * 자료형의 구조를 불문하고 이터레이터 인터페이스로 순회가능
  * 이터레이터 프로토콜: 이터러블한 객체들을 순회할 때 쓰이는 규칙
  * 이터러블한 객체: 반복가능한 객체로 배열을 일반화한 객체

<br>

## 8) 노출 모듈 패턴 (revealing module pattern)
* **노출 모듈 패턴** (revealing module pattern): 즉시 실행 함수(함수를 정의하자마자 호출하는 함수)를 통해 접근 제어자를 만드는 패턴

> ### 📢 접근 제어자
> * `public`: 클래스에 정의된 함수에서 접근 가능, 자식 클래스와 외부 클래스에서 접근 가능
> * `protected`: 클래스에 정의된 함수에서 접근 가능, 자식 클래스에서 접근 가능하나, 외부 클래스에서는 접근 불가
>* `private`: 클래스에 정의된 함수에서 접근 가능하지만, 자식 클래스나 외부 클래스에서는 접근 불가능

| 접근 제어자      | 클래스 내부 | 자식 클래스 | 외부 클래스 |
|-------------|--------|--------|--------|
| `public`    | ✅ 가능   | ✅ 가능   | ✅ 가능   |
| `protected` | ✅ 가능   | ✅ 가능   | ❌ 불가능  |
| `private`   | ✅ 가능   | ❌ 불가능  | ❌ 불가능  |

<br>

## 9) MVC 패턴 (model-view-controller pattern)
* **MVC 패턴**: 모델, 뷰, 컨트롤러로 이루어진 패턴
  * 모델: 애플리케이션의 데이터인 데이터베이스, 상수, 변수
  * 뷰: 사용자의 인터페이스 요소, 모델을 기반으로 사용자가 볼 수 있는 화면
  * 컨트롤러: 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리역할을 하며 이벤트 등 메인 로직 담당
  * 장점
    * 각각의 구성요서에 대해 집중 개발 가능 👉 재사용성, 확장성 용이
  * 단점
    * 앱이 복잡해질수록 모델과 뷰의 관계가 복잡해짐

|  뷰<br/>view  | ---유저 이벤트--><br/><---- 갱 신 ----- | 컨트롤러<br/>controller | ----- 갱 신 ----><br/><---- 알 림 ----- | 모델<br/>(model) |
|:------------:|:--------------------------------:|:-------------------:|:-----------------------------------:|:--------------:|

<br>

## 10) MVP 패턴 (model-view-presenter pattern)
* 뷰와 프레젠터는 1대1 관계 👉 강한 결합

|  뷰<br/>view  | ---유저 이벤트--><br/><---UI 갱신---- | 프레젠터<br/>presenter | ----모델 갱신---><br/><---모델 변경---- | 모델<br/>(model) |
|:------------:|:--------------------------------:|:-------------------:|:-------------------------------:|:--------------:|

<br>

## 11) MVVM 패턴 (model-view-view model pattern)
* 뷰 모델은 뷰를 추상화한 계층
* 커맨드와 데이터 바인딩을 가져 UI를 별도의 코드 수정 없이 재사용 할 수 있고 단위테스트 하기 쉬움
* 예시: Vue.js (반응형 프런트엔드 프레임워크)

|  뷰<br/>view  | <-데이터 바인딩 및 커맨드-><br/><---- 알 림 ----- | 뷰 모델<br/>view model | ----모델 갱신---><br/><---- 알 림 ----- | 모델<br/>(model) |
|:------------:|:-------------------------------------:|:-------------------:|:---------------------------------:|:--------------:|

> ### 📢 커맨드
> 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법

> ### 📢 데이터 바인딩
> 화면에 보이는 데이터와 웹브라우저의 메모리 데이터를 일치 시키는 기법