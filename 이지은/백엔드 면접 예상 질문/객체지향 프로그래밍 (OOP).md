## 1. 객체지향 프로그래밍 (OOP)

> - **의도 :** 이 카테고리는 객체지향 프로그래밍(OOP)의 기본 개념을 이해하고 있는지 평가합니다. OOP는 백엔드 개발에서 매우 중요한 패러다임이므로, 지원자가 클래스, 객체, 상속, 다형성 등 OOP의 기본 원리를 제대로 이해하고, 실제 코딩에 어떻게 적용하는지를 확인하려고 합니다. 또한 **디자인 패턴이나 SOLID 원칙**을 알고 있으면, 지원자가 **유지보수 가능한 코드를 작성할 수 있는 능력**을 가진지 판단하는 데 도움이 됩니다.
> - **답변에 포함해야 할 키워드**
>    - 클래스(Class): 객체를 생성하기 위한 템플릿
>    - 객체(Object): 클래스의 인스턴스, 상태와 동작을 가짐
>    - 다형성(Polymorphism): 동일한 인터페이스를 구현하는 여러 객체가 다양한 방식으로 동작
>    - 상속(Inheritance): 클래스 간 코드 재사용
>    - 캡슐화(Encapsulation): 객체의 내부 상태를 숨기고 외부와 상호작용을 제어
>    - SOLID 원칙: OOP 설계 원칙 (단일 책임, 개방-폐쇄 원칙 등)

<br>

### 1. [하] Class와 Object에 대해 설명해주세요.

* 클래스란, java에서 객체를 만들기위해 속성과 메서드를 정의한 설계도 입니다.
  * 클래스의 특징으로는 <br>
  1️⃣ 논리적인 개념이기 때문에 메모리를 차지하지 않는다는 특징이 있습니다.


* 객체란, 클래스에서 정의한 속성과 메서드가 생성된 실체 즉 인스턴스를 가리킵니다. 
  * 객체의 특징으로는 <br>
  1️⃣ 클래스로부터 실체화 된 것이기 때문에 물리적인 메모리를 차지합니다.

<br>

<details>
<summary>✅ 꼬리 질문</summary>

#### 💬 클래스와 객체의 차이점은?
* 클래스는 객체를 만들기 위한 속성과 메서드가 정의된 설계도이고, 객체는 클래스를 통해 만들어진 실체입니다.
* 클래스는 메모리를 차지하지 않는 논리적인 개념인 반면, 객체는 메모리를 차지하는 물리적인 개념입니다.

<br>

#### 💬 JAVA에서 객체를 생성하는 방법은 무엇인가요?
* `new`를 사용하여 클래스의 생성자를 호출해 생성합니다.

<br>

#### 💬 생성자란 무엇인가요?
* 생성자는 객체가 생성될 때 초기화하기 위한 작업을 위해 수행하는 특수한 메서드입니다.
* 클래스 이름과 동일하며 반환타입이 없다는 특징이 있습니다.

<br>

#### 💬 클래스와 객체가 Spring에서 어떻게 활용되나요?
* Spring은 `POJO (Plain Old Java Object)`를 기반으로 하여 클래스를 빈으로 등록하고, 객체를 관리합니다.
* `DI(Dependency Injection)`을 통해 필요한 객체를 자동으로 주입합니다.

<br>

#### 💬 객체지향 프로그래밍에서 클래스와 객체의 역할은 무엇인가요?
* 클래스는 데이터와 행위를 묶은 설계도를 제공하여 **코드 재사용과 유지보수**를 쉽게 합니다.
* 객체는 그 설계도를 기반으로 실제 동작하는 독립적인 단위로 프로그램을 구성하는 단위가 됩니다.

</details>

<details>
<summary>✅ POJO와 DI 개념</summary>

> ### 📢 POJO와 Spring 빈 등록 이론
> * **POJO(Plain Old Java Object)**: 특별한 프레임워크나 라이브러리, 기술에 의존하지 않고, java의 규칙만을 따르는 자바 객체
>   * 기본 메서드만 존재하며, 다른 라이브러리의 상속 및 구현을 강제하지 않는다.
>   * `테스트 용이성`, `재사용성`, `단순성`
>   * 비즈니스 로직과 인프라/환경설정의 분리
> * POJO를 스프링 빈으로 등록하는 방법
>   * **Spring Bean**: POJO를 Spring IoC (제어의 역전) 컨테이너가 관리하도록 등록된 객체
>   * 자동 등록: `@Component`, `@Service`, `@Repository`, `@Controller` 등을 붙여 자동 빈 등록
>   * 수동 등록: `@Configuration`을 붙이고 내부에 빈으로 등록하고 싶은 객체 반환 메서드에 `@Bean` 붙임 (외부 라이브러리, 직접 제어가 필요한 객체에 사용)
> * 빈 관리
>   * 한 컨테이너에 하나의 인스턴스만 생성하는 싱글톤 패턴으로 빈을 관리한다.
>   * 객체 관리 책임이 spring 프레임워크에 있음
> 
> ```java
> // 자동 등록
> @Component
> public class MyService { ... }
> 
> // 수동 등록
> @Configuration
> public class AppConfig {
>   @Bean
>   public MyService myService() {
>       return new MyService();
>   }
> }
> ```

> ### 📢 DI(Dependency Injection) 의존성 주입
> * **DI(Dependency Injection, 의존성 주입)**: 객체 간의 의존관계가 개발자가 직접 코딩을 하지 않고, 외부 컨테이너가 대신하여 주입해주는 설계 원리
>   * `결합도 낮춤`, `코드의 유연성`, `테스트 용이성`, `확장성 향상`
> * DI 의존도 주입 종류
>   1. 생성자 주입 
>   2. 필드 주입 `@Autowired`
>   3. Setter 주입 `@Autowired`
> * 프레임워크가 의존성 주입을 했을 때 장점
>   *  의존 객체가 스프링 컨테이너에 미리 빈으로 등록되어 있으면, 객체가 필요할 때 자동으로 값을 주입해줌
>   * 변경과 확장이 쉬움, 테스트 용이성, 느슨한 연결

</details>

<br>

---

### 2. [중] Polymorphism 개념에 대해 설명하고, 개인/팀 프로젝트에 적용한 사례가 있다면 이야기해주세요.

* 다형성이란, 하나의 객체나 메서드가 여러 형태로 동작할 수 있도록 해주는 객체 지향 프로그래밍의 개념입니다.
* 다형성의 특징으로는 <br>
1️⃣ 코드의 유연성과 확장성을 제공하고 <br>
2️⃣ 상속과 인터페이스를 활용 <br>
3️⃣ 동적 바인딩(실행시간에 객체의 실제 타입에 따라 동작을 결정할 수 있습니다.)
* 구현 방법으로는 <br>
1️⃣ 메서드 오버라이딩,  2️⃣ 메서드 오버로딩,  3️⃣ 인터페이스 가 있습니다.

* 프로젝트 예시 (1)
  * 소셜 로그인이 포함된 프로젝트에서 로그인 정책 인터페이스를 만들어 공통 메서드를 정의 하였습니다. (외부 API와 통신하도록)
  * 이후 카카오, 구글, 네이버로 인터페이스를 상속받아 클래스를 생성하였습니다.
  * 이때, 카카오가 다른 소셜 로그인 방법이 달라 카카오는 따로 구현했던 경험이 있습니다.
* 프로젝트 예시 (2)
  * 이미지를 업로드 및 삭제하는 기능을 개발할 때 업로드 및 삭제하는 공통 메서드를 제공하는 인터페이스를 작성하였습니다.
  * 이 인터페이스는 저장소에 따라 다형성있게 사용하기 위해 `S3ImageService`로 상속받아 클래스를 구현하였습니다.

<br>

<details>
<summary>✅ 꼬리 질문</summary>

#### 💬 다형성과 상속의 차이점은?
* 상속은 기존 클래스를 확장하여 기능을 재사용하는 것이고
* 다형성은 하나의 객체나 메서드가 여러 형태로 동작할 수 있도록 코드 유연성과 확장성을 제공하는 것

<br>

#### 💬 Java에서 메서드 오버로딩과 오버라이딩 차이점은?
* 오버로딩은 같은 이름, 다른 매개변수로 여러 메서드를 선언하는 것이고,
* 오버라이딩은 부모의 메서드를 자식에서 재정의 하는 것

<br>

#### 💬 Spring에서 다형성을 어떻게 활용하나요?
* 인터페이스 기반으로 서비스 계층을 설계하고, 다양한 구현체를 만들어 상황에 따라 DI로 관리하거나, 전략 패턴 등 유연한 소프트웨어 구조를 설계할때 활용된다.

<br>

#### 💬 다형성을 활용하면 어떤 장점이 있는지?
* 기능 확장 및 정책 변경 시 코드 수정 최소화, 테스트/유지보수 용이, 중복 제거, 클래스/객체 간 결합도 감소와 같은 장점이 있습니다.

<br>

</details>

<br>

---

### 3. [하] Encapsulation(캡슐화)이란 무엇인가요?

* **캡슐화**: 변수와 메서드를 하나의 단위로 묶고 외부에서 직접 접근하지 못하도록 정보를 은닉하는 것이다.
* 주요 특징
  1) 데이터는 `private`로 선언하여 외부 접근 제한
  2) 데이터를 간접적으로 다루기 위해 `getter`, `setter` 메서드를 사용
  3) 객체의 무결성 보장
  4) 코드의 유연성과 유지보수성 향상
* Spring과의 연관
  * Spring에서는 Entity, DTO, Service 등 다양한 구조체에서 캡슐화를 활용하여 내부 데이터를 외부에 노출하지 않고 getter/setter로만 접근할 수 있도록 설계합니다.
  * 유연한 객체 설계, 테스트 및 유지보수성이 높은 코드 구현이 가능

<br>

<details>
<summary>✅ 꼬리 질문</summary>

#### 💬 캡슐화를 왜 사용하나요?
* 객체의 내부 상태를 보호하고, **외부에서의 잘못된 접근이나 변경을 방지**하여 프로그램의 안정성과 유지보수성을 높이기 위해 사용합니다.

<br>

#### 💬 캡슐화와 정보은닉의 차이는 무엇인가요?
* 캡슐화는 "데이터와 메서드 묶기"
* 정보은닉은 "외부에서 직접 접근하지 못하도록 숨기는 행위"입니다.
* 정보은닉은 캡슐화의 목적이자 효과입니다.

<br>

#### 💬 Java에서 캡슐화를 어떻게 구현하나요?
* 클래스의 멤버 변수는 `private`으로 선언하고, 
* 외부에서 접근 가능한 public getter/setter 메서드를 제공합니다.

<br>

#### 💬 캡슐화를 적용할 때 주의할 점은?
* 꼭 필요한 데이터만 getter/setter를 제공하고, 
* setter에는 유효성 검증 등의 로직을 추가하는 게 바람직합니다.

<br>

#### 💬 캡슐화와 추상화의 차이는?
* 캡슐화는 내부 구현을 숨기고 데이터 보호에 초점,
* 추상화는 필요한 기능/동작만 외부에 드러내는 것에 초점이 있습니다.

</details>

<br>

---

4. [중] 상속(Inheritance)의 개념을 설명하고, 상속의 장단점을 이야기해주세요.

* **상속(Inheritance)**: 기존 클래스(부모, Superclass)의 속성과 메서드를 새로운 클래스(자식, Subclass)가 물려받는 객체지향의 핵심 원리입니다.
* 공통 기능을 부모 클래스에 정의하고, 자식 클래스는 이를 그대로 사용하거나 필요에 따라 추가/변경(오버라이딩)할 수 있습니다.

* 장점 
  1) 코드의 재사용성 증가(중복 코드 줄이기)
  2) 유지보수성 향상(중앙에서 수정하면 하위 클래스 모두 적용)
  3) 자식 클래스 확장을 통한 프로그램의 유연성 제공

* 단점 
  1) 부모-자식 간 강한 결합으로 구조가 복잡해질 수 있음 
  2) 잘못 사용하면 코드 변경이 여러 곳에 영향(리스코프 치환 원칙 위배)
  3) 다중 상속 불가(자바 기준, 인터페이스로는 가능)

* 실제 프로젝트 경험
  * 상속을 사용하여 `RuntimeException` - 공통처리 예외 클래스 - 각 http 에러 메서드를 정의하는 예외 클래스 구조로 설계

<br>

<details> 
<summary>✅ 꼬리 질문</summary>

#### 💬 상속을 사용할 때 주의할 점은?
* 불필요하게 상속 남용을 지양하고, 공통 기능 중심으로 계층을 설계해야 합니다. 변경에 유연하게 대처하고 싶다면 조합(Composition)도 고려해야 합니다.

#### 💬 상속 대신 조합(Composition)을 쓰는 경우는?
* 클래스 간 강한 결합을 피하고 싶거나, **동적으로 행위를 변경·확장**하고 싶은 경우 조합이 상속보다 적합합니다.

<br>

</details>

<details>
<summary>✅ 조합에 대하여</summary>

> ### 📢 상속과 조합의 비교
> * **상속**: 기존 클래스(부모)의 속성과 메서드를 새로운 클래스(자식)가 물려받아 사용하는 객체지향 프로그래밍의 대표적 관계.
> * **조합**: 새로운 클래스가 기존 클래스를 자신의 멤버(필드)로 포함해 **필요한 기능만 선택적으로 사용**하는 방법.
> 
> * 불필요한 기능 상속 없이 원하는 기능만 조립
> * 내부 구현이 바뀌어도 포함한 클래스 외부에 영향이 적음 (낮은 결합도, 변경 용이)
> * 동적 객체를 런타임에 동적으로 교체 가능
> * 상속 계층의 비대화 방지, 중복 최소화
> 
> * 클래스 수와 복잡도 증가
> 
> ➡️ 상속은 계층적, 공통 기반 기능 재사용에, 조합은 유연하고 변경에 강한 구조에 각각 적합합니다. (조합 선호)

</details>

<br>

---

### 5. [상] SOLID 원칙이란 무엇인지, 각 원칙을 설명해주세요.

1) **SRP(단일 책임의 원칙)**: 클래스는 오직 하나의 책밈만 가져야 한다는 원칙
   * 예시: Service와 Repository를 분리해, 각각 비즈니스 로직과 DB 접근 책임을 나눔
2) **OCP(개방-폐쇄의 원칙)**: 소프트웨어 요소는 확장에 열려 있어야하지만, 수정에는 닫혀 있어야하는 원칙
   * 예시: 새 결제 방식이 추가될 때 기존 PaymentService 코드는 수정 없이, 새로운 구현체를 추가
3) **LSP(리스코프 치환의 원칙)**: 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.
   * 예시: 자식 클래스가 부모의 메서드를 오버라이드해도, 부모 타입 코드는 수정할 필요 없음
4) **ISP(인터페이스 분리의 원칙)**: 인터페이스는 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 여러 개의 인터페이스로 분리해야 한다.
   * 예시: 불필요하게 방대한 인터페이스 대신, 역할별 인터페이스를 만들어 필요한 것만 구현
5) **DIP(의존성 역전 원칙)**: 고수준 모듈이 저수준 모듈이 아닌, 추상화(인터페이스)에 의존해야 한다. (구현에 의존하지 않고, 추상에 의존 해야한다.)
   * 예시: 구현체가 아닌 인터페이스에 의존하고, Spring DI로 실제 객체 주입

<br>

<details> 
<summary>✅ 꼬리 질문</summary>

#### 💬 SRP(단일 책임 원칙)를 어기면 어떤 문제가 생기나요?
* 한 클래스가 여러 책임을 지면, 한 책임의 변경이 예상치 못한 다른 기능에 영향을 미쳐 버그, 유지보수 난이도 상승 등 문제가 발생합니다.

<br>

#### 💬 OCP(개방-폐쇄 원칙)는 어떻게 지킬 수 있나요?
* 상속, 인터페이스, 추상 클래스, 전략 패턴 등 확장 가능한 구조로 설계하여, 변경 없이 기능을 추가할 수 있게 합니다.

<br>

#### 💬 DIP(의존성 역전 원칙)을 적용하는 방법은?
* 클래스 내에서 직접 구현체를 생성하지 않고, 인터페이스(추상 타입)에 의존하도록 만들고, 
* 실제 객체 주입은 Spring DI(의존성 주입) 등 컨테이너에 맡깁니다.

<br>

#### 💬 실무에서 SOLID 원칙을 적용한 예시가 있나요?
* 회원 가입/로그인 서비스에서 SRP(역할 별 클래스 분리), 
* OCP(새 인증 방식 추가 시 코드 수정 없이 클래스 추가), 
* DIP(인터페이스 기반 DI)로 구조를 설계해, 확장성과 유지보수성을 크게 높였습니다.

</details>

<br>

---

### 6. [상] 인터페이스(Interface)와 추상 클래스(Abstract Class)의 차이점은 무엇인가요?
* 인터페이스는 **구현 객체들의 규약을 명세**만 하며, 다중구현이 가능하다.
* 추상 클래스는 **공통 속성/기능을 제공**하고 **추상 메서드의 강제 구현**이 있으며, 상속하는 구조이다.

<details> 
<summary>✅ 꼬리 질문</summary>

#### 💬 언제 인터페이스와 추상 클래스를 선택하나요?
* 공통된 '동작만 명세'(분리, 확장 유연) 필요하면 인터페이스, 
* 일부 공통 속성·로직까지 공유하면 추상 클래스가 적합합니다.

* 인터페이스는 주로 JPA 인터페이스를 상속 받는 repository 를 구현할 때나 공통 메서드의 상속을 위해 인터페이스 구현 사용하였고,
* 추상 클래스는 `TimeStamped`를 구현하여 생성일 수정일을 함께 저장하기 위해 엔티티 클래스에 상속하여 사용

</details>

<br>

---

### 7. [중] 추상화(Abstraction)란 무엇이며, 코드로 어떻게 구현할 수 있는지 설명해주세요.
* **추상화**: 복잡한 내부 구현은 감추고 필요한 기능만 외부에 드러내는 객체 지향 설계 (불필요한 것은 인터페이스나 추상클래스로 구현)
* `코드 작성 이해`, `유지보수 용이`, `유연한 설계`, `확장성 용이`
* 추상클래스나 인터페이스를 사용한 설계

<br>

<details> 
<summary>✅ 꼬리 질문</summary>

#### 💬 추상화와 캡슐화의 차이는?
* 추상화는 시스템의 필수적인 기능만 드러내서 복잡성을 줄이며,
* 캡슐화는 데이터를 외부에 숨기고 공개된 메서드로만 조작하게 합니다.

<br>

#### 💬 추상 클래스와 인터페이스의 차이는?
* 추상 클래스는 일부 구현(필드/메서드)을 포함할 수 있지만, 
* 인터페이스는 구현 없이 “무엇을 할지”만 정합니다.

* 또한 인터페이스는 다중 구현이 가능하고, 추상 클래스는 단일 상속만 가능합니다.

<br>

#### 💬 언제 추상 클래스와 인터페이스를 각각 사용하는 것이 좋나요?
* 공통 동작과 상태(필드·메서드)를 함께 묶어 여러 객체가 공유할 필요가 있으면 추상 클래스, 
* 다양한 구현만 필요하고, 다중 상속·확장성이 중요할 때는 인터페이스가 적합합니다.

<br>

#### 💬 추상화를 적용한 경험이 있다면?
* (예시) 서비스 계층 비즈니스 로직을 인터페이스로 추상화하여,
여러 데이터 소스나 비즈니스 전략에 따라 다양한 구현체를 쉽게 적용했습니다.

</details>

<br>

---

### 8. [중] 다형성(Polymorphism)을 프로젝트에서 어떻게 활용했는지 예를 들어 설명해주세요.
* 프로젝트 예시 (1)
    * 소셜 로그인이 포함된 프로젝트에서 로그인 정책 인터페이스를 만들어 공통 메서드를 정의 하였습니다. (외부 API와 통신하도록)
    * 이후 카카오, 구글, 네이버로 인터페이스를 상속받아 클래스를 생성하였습니다.
    * 이때, 카카오가 다른 소셜 로그인 방법이 달라 카카오는 따로 구현했던 경험이 있습니다.
* 프로젝트 예시 (2)
    * 이미지를 업로드 및 삭제하는 기능을 개발할 때 업로드 및 삭제하는 공통 메서드를 제공하는 인터페이스를 작성하였습니다.
    * 이 인터페이스는 저장소에 따라 다형성있게 사용하기 위해 `S3ImageService`로 상속받아 클래스를 구현하였습니다.
* 프로젝트 예시 (3)
    * `RefreshTokenRepository` 구현에서 저장소를 mySQL에서 redis로 바꿀때 `extends JpaRepository<Users, Long>`를 `extends CrudRepository<RefreshToken, String>`로 변경하여
    * 인터페이스로 정의한 저장소의 명세(예: save, findById 등 CRUD 메서드)는 동일하게 재사용할 수 있었습니다.
    * 상위 타입(Repository 인터페이스)에 의존하고, 실제 구현(JPA, Redis 등)은 필요에 따라 유연하게 교체할 수 있도록 설계한
      객체지향의 다형성 특징을 잘 활용한 대표적인 경험이라고 생각합니다.

<br>

---

### 9. [상] 의존성 주입(Dependency Injection)이란 무엇이며, 이를 적용했을 때의 장점을 설명해주세요.
* **의존성 주입**: 객체의 의존 객체를 개발자가 직접 만들지 않고 외부, Spring 컨테이너가 대신 주입해주는 설계 원리
* `결합도 감소`, `코드 확장성`, `테스트 용이성`, `객체 관리를 프레임워크가 담당`

<br>

---

### 10. [상] 디자인 패턴 중 싱글톤(Singleton) 패턴을 설명하고, 실제로 구현할 때 고려해야 할 사항을 이야기해주세요.
* **싱글톤 패턴**: 클래스의 인스턴스를 프로그램 전체에서 단 하나만 만들도록 보장하는 디자인 패턴
* Spring에서는 빈 기본 생명주기가 싱글톤

* 멀티스레드 환경에서 동시성 보장(동기화 적용 필요)
* 테스트 코드(의존성 순환 등)에서 예상치 못한 동작 
* 상태 정보(필드값) 관리에 주의(공유 자원 문제)

<br>

<details> <summary>✅ 꼬리 질문</summary>

#### 💬 싱글톤 패턴 사용 시 주의할 점은?
* 동시성 문제에 대비해 객체 생성에 대한 동기화 처리 필요, 상태를 가지는 필드 사용 자제, DI와 함께 쓸 때 순환참조 등 유의

</details>

<br>

---

- `참고` **이 카테고리에서 실무와 연관된 질문이 나온다면?**
### 1. [중] 객체지향 설계에서 SOLID 원칙 중 단일 책임 원칙(SRP)이 지켜지지 않으면 어떤 문제가 발생할 수 있나요? 이를 해결한 경험이 있다면 설명해 주세요.

- 문제점
  - 한 클래스가 여러 기능을 동시에 담당하면, **특정 기능의 변경이 다른 기능에도 예상치 못한 영향**을 미칩니다. 
  - **코드가 복잡**해지고, **테스트와 유지보수가 어려워**집니다. (예: 주문 API에서 검증, 재고 차감, 포인트 지급을 모두 담당)
  - **재사용성이 떨어지고**, 여러 액터(이해관계자)로부터 빈번하게 수정 요청이 들어오면 코드 품질이 약해집니다

- 해결 방법 및 경험
  - 주문 서비스가 검증, 결제, 장바구니 추가 등을 한 클래스에서 처리하다 보니, 기능 추가·변경이 번거로웠습니다.
  - 이를 각각 책임에 따라 따로 클래스를 구현하고 이를 의존성 주입으로 호출하는 방법을 사용하여 구현하였습니다.
  - 그 결과 서비스 단위가 명확해 졌으며 변경 영향이 줄어들었고 테스트도 용이했던 경험이 있습니다.

<br>

---

### 2. [상] 의존성 주입(Dependency Injection)을 프로젝트에 어떻게 적용했고, 이를 통해 얻은 장점은 무엇인가요?

- 실제 프로젝트에서 Controller, Service, Repository 등 각 계층을 인터페이스와 구현체로 분리하고, 생성자 주입방식을 통해 Spring의 DI 기능을 사용하였습니다. 
  - 계층간 결합도를 낮추고 각 역할에대해 로직을 작성할 수 있었습니다.
  - 각 계층은 필요한 구현체가 주입만 되어 있으면, 내부 동작을 알 필요 없이 본인의 역할만 충실히 담당할 수 있게 되었습니다.
- 수동 주입을 한 경험은 RedisConfig에서 커스텀한 RedisTemplate를 사용하려고 했을 때 
  - `@Configuration`과 `@Bean`으로 선언하여 컨테이너에 등록하게 만들었습니다.

- 의존성 주입의 장점
  - `유지보수성`, `확장성 향상`, `테스트 용이`, `결합도 감소`, `코드 재사용성 및 모듈화`

<br>

### 3. [중] 다형성(Polymorphism)을 통해 인터페이스와 구현체를 분리하여 설계한 예시를 설명해 주세요.

* 프로젝트 예시 (1)
    * 소셜 로그인이 포함된 프로젝트에서 로그인 정책 인터페이스를 만들어 공통 메서드를 정의 하였습니다. (외부 API와 통신하도록)
    * 이후 카카오, 구글, 네이버로 인터페이스를 상속받아 클래스를 생성하였습니다.
    * 이때, 카카오가 다른 소셜 로그인 방법이 달라 카카오는 따로 구현했던 경험이 있습니다.
* 프로젝트 예시 (2)
    * 이미지를 업로드 및 삭제하는 기능을 개발할 때 업로드 및 삭제하는 공통 메서드를 제공하는 인터페이스를 작성하였습니다.
    * 이 인터페이스는 저장소에 따라 다형성있게 사용하기 위해 `S3ImageService`로 상속받아 클래스를 구현하였습니다.
* 프로젝트 예시 (3)
    * `RefreshTokenRepository` 구현에서 저장소를 mySQL에서 redis로 바꿀때 `extends JpaRepository<Users, Long>`를 `extends CrudRepository<RefreshToken, String>`로 변경하여
    * 인터페이스로 정의한 저장소의 명세(예: save, findById 등 CRUD 메서드)는 동일하게 재사용할 수 있었습니다.
    * 상위 타입(Repository 인터페이스)에 의존하고, 실제 구현(JPA, Redis 등)은 필요에 따라 유연하게 교체할 수 있도록 설계한
      객체지향의 다형성 특징을 잘 활용한 대표적인 경험이라고 생각합니다.

* 서비스 코드 수정 없이 다양한 정책 적용 및 확장 가능 
* 테스트·유지보수 용이 
* 구현체 간 결합도 최소화

<br>

---

### 4. [중] 상속(Inheritance) 대신 구성(Composition)을 사용하는 것이 더 적합한 경우는 언제인가요? 이유와 함께 설명해 주세요.

- 상속은 코드 재사용에 좋지만, **부모–자식 간 강한 결합**, **불필요한 기능 상속**, 상위 클래스 변경 시 하위 클래스 영향 등 여러 한계가 있어 남용을 피해야 합니다.

- 구성(Composition) 사용이 더 적합한 경우 
  - 기능 교체/확장이 빈번하고, 동적으로 행위를 변경해야 하는 경우 
  - 불필요한 상위 클래스 기능을 물려받고 싶지 않을 때 
  - 유연성(런타임에 새로운 행위 조립)이 필요할 때 
  - 기존 클래스의 변경이 다른 클래스에 영향을 주면 안 되는 경우

<br>

---

### 5. [상] 디자인 패턴 중 싱글톤(Singleton)을 사용했을 때 발생할 수 있는 문제점과 해결 방안을 설명해 주세요.

- 싱글톤 패턴은 객체를 단 하나만 생성해 모든 곳에서 공통으로 사용하는 디자인 패턴입니다. Spring의 기본 빈 등록 방식도 싱글톤입니다.

- 문제점 
  - 1️⃣ 높은 결합도: 싱글톤 인스턴스를 참조하는 모든 코드가 강하게 연결됨(교체/확장 어려움)
  - 2️⃣ 테스트 어려움: 전역 상태를 공유해서, **테스트 케이스 간 독립성 저하** 
  - 3️⃣ 상속·다형성 제한: 생성자가 private이기 때문에 하위 클래스로의 확장 불가 
  - 4️⃣ 멀티스레드 문제: 직접 구현할 경우 동시성(동기화) 보장 필요

- 해결 방안 
  - 상태를 갖지 않는(Stateless) 빈으로 설계해 문제 최소화 
  - 직접 싱글톤 구현 대신 Spring의 싱글톤 빈 관리를 활용(필요 시 @Scope("prototype") 등으로 예외 처리)
  - 멀티스레드 환경에서는 synchronized/Holder 패턴 등 thread-safe한 구현 필요