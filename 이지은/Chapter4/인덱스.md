# Chapter4-5. 인덱스

## 1) 인덱스
* **인덱스**: 데이터를 빠르게 찾을 수 있는 장치

<br>

## 2) B-트리
* 인덱스는 B-트리 구조
* 루트 노드, 리프 노드, 브랜치 노드
* 전체 테이블을 탐색하는 것이 아닌, 특정 데이터가 있을 만한 리프노드로 들어가 탐색
* 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리 구조와 트리 깊이의 대수확장성
  * 대수확장성: 트리깊이가 리프 노드 수의 비해 매우 느리게 성장하는 것
    * 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배 증가
    * 트리 깊이는 10개 → 100만 개의 레코드 검색 가능

<br>

## 3) 인덱스 생성

### 1️⃣ MySQL
* **클러스터형 인덱스**
  * 테이블 당 하나 설정 가능
  * `primary key` + 기본키, 기본키 외 `unique not null` 옵션으로 생성
* **세컨더리 인덱스**
  * `create index ..` 명령어로 생성
  * 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스

<br>

### 2️⃣ MongoDB
* 도큐먼트를 만들면 자동으로 ObjectID, 기본키로 설정
* 세컨더리키 또한 부가 설정가능

<br>

## 4) 인덱스 최적화 기법
### 1️⃣ 인덱스는 비용이다
* 인덱스는 두 번 탐색하도록 강요 → 인덱스 리스트, 컬렉션 순으로 탐색하므로 읽기 비용
* 컬렉션이 수정되면 인덱스도 수정되어야 함
  * 이때 B-트리의 높이를 균형 있게 조정하거나 분산시키는 비용

<br>

### 2️⃣ 항상 테스팅 하라
* 서비스에서 사용하는 객체의 깊이, 테이블의 양이 달라 서비스 특징에 따라 최적화 기법이 다름
* `explain()`을 통해 인덱스를 만들고 쿼리를 보낸이후에 테스팅 및 시간 최소화 필요

<br>

### 3️⃣ 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.
* 복합 인덱스를 생성할 때는 순서가 있고, 생성 순서에 따라 인덱스 성능이 달라짐
* 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 함
  1) 어떠한 값고 같음을 비교하는 쿼리가 있으면 제일 먼저 설정
  2) 정렬에 쓰는 필드면 그 다음 인덱스로 설정
  3) 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 <등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정
  4) 유니크한 값의 정도를 카디널리티라고 하는데, 카디널리티가 높은 순서를 기반으로 인덱스 생성 필요