## 자료구조와 복잡도 관련 신입 백엔드 면접 예상 질문

---

#### 💬 자료구조란 무엇이고, 왜 중요한가요?

<details>
<summary>✅ 모범 답안</summary>

- **자료구조**란 데이터를 효율적으로 저장, 관리, 수정, 탐색, 삭제할 수 있도록 하는 데이터 집합 및 그 구조입니다.
- 효율적인 자료구조 선택은 프로그램의 성능(속도, 메모리 사용)에 직접적인 영향을 미칩니다.
- 예시: 배열, 리스트, 스택, 큐, 해시맵, 트리, 그래프 등
</details>

---

#### 💬 시간 복잡도와 공간 복잡도의 차이를 설명해주세요.

<details>
<summary>✅ 모범 답안</summary>

- **시간 복잡도**: 입력 크기(n)에 따라 알고리즘이 실행되는 데 걸리는 시간을 나타냅니다.
    - 주로 반복 횟수, 연산 횟수로 측정
    - 예시: O(1), O(n), O(n²) 등

- **공간 복잡도**: 프로그램이 실행될 때 필요한 메모리(자원) 공간의 양을 나타냅니다.
    - 변수, 배열, 재귀 호출 등으로 인한 메모리 사용량 포함

- 두 복잡도 모두 알고리즘의 효율성을 평가하는 중요한 척도입니다.
</details>

---

#### 💬 빅오(Big-O) 표기법이란 무엇이며, 왜 사용하나요?

<details>
<summary>✅ 모범 답안</summary>

- **빅오 표기법**은 입력 크기(n)에 따른 알고리즘의 성능(시간/공간 복잡도)을 수학적으로 표현하는 방법입니다.
- 상수, 저차항을 무시하고 가장 영향력이 큰 항만 표기합니다.
    - 예시: 10n² + n → O(n²)
- **사용 목적**: 코드의 효율성을 객관적으로 비교하고, 최적화 방향을 결정하기 위함입니다.
</details>

---

#### 💬 배열(Array)과 연결리스트(LinkedList)의 시간 복잡도를 비교해보세요.

<details>
<summary>✅ 모범 답안</summary>

| 연산         | 배열(Array) | 연결리스트(LinkedList) |
|--------------|-------------|-----------------------|
| 접근         | O(1)        | O(n)                  |
| 삽입/삭제(중간)| O(n)        | O(1) (노드 위치 알 때)|
| 삽입/삭제(끝)| O(1)        | O(1) (단일/이중 연결) |
| 탐색         | O(n)        | O(n)                  |

- 배열은 인덱스 기반 접근이 빠르지만, 중간 삽입/삭제는 느립니다.
- 연결리스트는 노드 위치만 알면 삽입/삭제가 빠르지만, 임의 접근이 느립니다.
</details>

---

#### 💬 자료구조 선택 시 평균 시간 복잡도와 최악 시간 복잡도를 왜 고려해야 하나요?

<details>
<summary>✅ 모범 답안</summary>

- **평균 시간 복잡도**는 일반적인 상황에서의 성능을 나타내고, **최악 시간 복잡도**는 가장 불리한 상황에서의 성능을 나타냅니다.
- 서비스의 특성상 최악의 경우가 자주 발생하면 시스템 전체 성능에 악영향을 줄 수 있습니다.
- 예시: 해시맵은 평균 O(1)이지만, 충돌이 많을 경우 최악 O(n)이 될 수 있습니다.
- 따라서 두 복잡도를 모두 고려해 안정적이고 효율적인 자료구조를 선택해야 합니다.
</details>

---

#### 💬 Java에서 자주 사용하는 컬렉션(List, Set, Map)의 시간 복잡도를 설명해주세요.

<details>
<summary>✅ 모범 답안</summary>

| 자료구조        | 접근 | 탐색 | 삽입 | 삭제 |
|----------------|------|------|------|------|
| ArrayList      | O(1) | O(n) | O(n) | O(n) |
| LinkedList     | O(n) | O(n) | O(1) | O(1) |
| HashSet/HashMap| -    | O(1) | O(1) | O(1) |
| TreeSet/TreeMap| -    | O(log n) | O(log n) | O(log n) |

- Hash 계열은 평균적으로 매우 빠르지만, 충돌이 많을 경우 성능 저하 가능
- Tree 계열은 항상 O(log n) 보장
</details>

---

#### 💬 시간 복잡도를 개선하기 위한 방법에는 어떤 것들이 있나요?

<details>
<summary>✅ 모범 답안</summary>

1. **적합한 자료구조 선택** (예: 탐색이 많으면 HashMap, 정렬이 많으면 TreeMap)
2. **불필요한 반복문 제거**
3. **효율적인 알고리즘 사용** (예: 이진 탐색, 정렬 알고리즘 등)
4. **캐싱/메모이제이션 활용**
5. **데이터 구조의 크기 제한 및 분할 처리**
</details>
