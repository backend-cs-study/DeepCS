# Chapter2 네트워크

<br>

# 📚 목차

> **[1. HTTP/1.0](#http10)**
>
> **[2. HTTP/1.1](#http11)**
>
> **[3.HTTP/2](#http2)**
>
> **[4. HTTPS](#https)**
> 
> **[5. HTTP/3](#http3)**

<br>

## HTTP/1.0 

기본적으로 **한 연결**당 **하나의 요청**을 처리하도록 설계 

➡️ 서버로부터 수신할 때마다 TCP 3 Way-HandShake를 계속 열어야 하기 때문에  **RTT가 증가**한다. 

> 💡 **RTT [패킷 왕복 시간]**
> 
> 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 
> 
> ![Image](https://github.com/user-attachments/assets/9a1720f1-a9e3-4ec3-b4c2-98561c519b3e)

<br>

### RTT 증가를 해결하기 위한 방법 

- 스플리팅
- 코드 압축
- 이미지 Base64 인코딩

<br>

#### 이미지 스플리팅 

**많은 이미지 다운로드 시 과부하**가 걸림 

➡️`많은 이미지가 합쳐 있는 하나의 이미지`를 다운로드 받고 이를 기반으로 **background-image의 position을 이용하여 이미지 표기** 

<br>

#### 코드 압축

코드를 압축하여 **개행문자**, **빈칸**을 없애서 <ins>코드의 크기를 최소화</ins>하는 방법이다. 

<br>

#### 이미지 Base64 인코딩

이미지 파일을 **64진법으로 이루어진 문자열로 인코딩** 하는 방법 

> 💡 **인코딩**
> 
> **정보의 형태나 형식**을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 **다른 형태나 형식으로 변환하는 처리 방식**

➡️ 서버와의 연결을 열고 이미지에 대해 서버에 **HTTP 요청을 할 필요가 없지만**, 변환 시 **37% 정도 크기가 더 커지는 단점**이 있다. 

<br>

## HTTP/1.1

한번 TCP 초기화 이후 `Keep-Alive`라는 옵션으로 **여러 개의 파일을 송수신**할 수 있다. 

✅ Keep-Alive 기능은 HTTP/1.1부터 표준화되어 기본 옵션으로 설정됨 


![Image](https://github.com/user-attachments/assets/4c58b0a7-3f5a-4dc5-b377-f027743742d9)

➡️ 문서 안에 포함된 다수의 리소스(이미지, 동영상, ..)등을 처리하려면 리소스 개수에 비례해서 대기 시간이 길어진다. 

<br>

### HOL Blocking(Head Of Line Blocking)

네트워크에서 `같은 큐`에 있는 **패킷**이 그 천번째 패킷에 의해 <ins>지연될 때 발생하는 성능 저하 현상

![Image](https://github.com/user-attachments/assets/09620997-afb8-4f7f-acdd-45c098b520a2)

<br>

### 무거운 헤더 구조

HTTP/1.1 헤더에는 쿠기 등 **많은 메타 데이터**가 들어있고 **압축이 되지 않아 무거움**

<br>

## HTTP/2

SPDY 프로토콜에서 파생된 **HTTP/1.x**보다 <ins>지연시간</ins>을 줄이고 <ins>응답 시간을 더 빠르게</ins> 할 수 있으며 <ins>멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선 순위 처리를 지원하는 프로토콜</ins>이다. 

> 💡 **HTTP2는 HTTPS 위에서 동작**


<br>

### 멀티 플렉싱 

여러 개의 스트림을 사용해서 송수신하는 것 

➡️ 특정 스트림의 패킷 손실 발생 시 다른 스트림에 영향 ❌


> 💡 **스트림(Stream)**
> 
>  시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름 

![Image](https://github.com/user-attachments/assets/cdc8f619-112d-4903-a5e9-c526e32e57c6)

![Image](https://github.com/user-attachments/assets/cfc214f9-98c1-40e0-8131-fe6edd0ec4df)

애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 후 다시 조립하여 데이터를 주고 받는다. 

<br>

### 헤더 압축

**허프만 코딩 압축 알고리즘**을 사용하는 `HPACK 압축 형식`을 가진다. 

<br>

> 💡 **허프만 코딩(Huffman Coding)**
> 
> 문자열을 **문자 단위로 쪼개 빈도수**를 세어 
> - `빈도가 높은 정보`➡️ 적은 비트 수를 사용하여 표현 
> - `빈도수가 낮은 정보` ➡️ 비트 수를 많이 사용하여 표현 
> 
> 전체 데이터의 표현에 필요한 비트양을 줄이는 원리 

<br>

### 서버 푸시

HTTP/2의 경우 클라이언트 **요청 없이 서버가 바로 리소스를 푸시**할 수 있다. 

<br>

## HTTPS

**애플리케이션 계층**과 **전송 계층** 사이에 신뢰 계층인 `SSL/TLS 계층`을 넣은 <ins>신뢰할 수 있는 HTTP 요청</ins>을 말한다. 

➡️ **통신 암호화**
 
<br>

### SSL/TLS 계층

- SSL(Secure Socket Layer): **버전** 1.0 ➡️ 2.0 ➡️ 3.0 
- TLS(Transport Layer Security Protocol): **버전** 1.0 ➡️ 1.3

클라이언트와 서버가 통신할 때 SSL/TLS를 통해 **제3자가 메시지를 도청하거나 변조하지 못하도록** 한다. 

![Image](https://github.com/user-attachments/assets/f4dfe712-7afc-49c6-8380-685257fd0be6)

<br>

SSL/TLS는 `보안 세션을 기반`으로 데이터를 암호화하며 보안 세션이 만들어질 때 

- 인증 메커니즘
- 키 교환 암호화 알고리즘
- 해싱 알고리즘 

이 사용된다. 

<br>

#### 보안 세션 

**보안이 시작되고 끝나는 동안 유지되는 세션**을 말하며, `SSL/TLS`는 <ins>핸드셰이크를 통해 보안 세션을 생성</ins>하고 이를 기반으로 상태 정보 등을 공유한다.  

> 💡 **세션**
> 
> 운영체제가 어떠한 사용자로부터 **자신의 자산 이용을 허락하는 일정한 기간**을 의미한다. 
> 
> 사용자는 일정 시간 동안 응용 프로그램, 자원 등을 사용할 수 있다. 

<br>

![Image](https://github.com/user-attachments/assets/27b1e1ab-9886-4889-b8d7-d40aff0e64e1)


**[흐름]**

- **클라이언트 ↔️ 서버**와 `Key`를 공유, 이를 기반으로 인증, 인증 확인 등의 작업이 일어남


- 1 RTT 발생 후 데이터를 송수신한다.


- 클라이언트에서 `사이퍼 슈트(Cypher Suites)`를 ➡️  서버에 전달


- 서버는 받은 **사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인**한다. 


- 제공 가능하다면, 서버에서 클라이언트로 인증서를 보내는 **인증 메커니즘이 시작**


- 해싱 알고리즘 등으로 암호화된 데이터의 송수신이 시작

<br>

#### 사이퍼 슈트(Cypher Suites)

프로토콜, AEAD 사이퍼 모드, 해실 알고리즘이 나열된 규약을 말한다. 

![Image](https://github.com/user-attachments/assets/dd916020-4f76-4a3d-bfee-a6aa4d09c34b)

![Image](https://github.com/user-attachments/assets/8d197e46-c85a-4875-a3bb-a3de9d8cc0cc)


> 💡 **AEAD(Authenticated Encrypion with Associated Data) 사이퍼 모드**
> 
> **데이터 암호화 알고리즘**
> 
> ex> **AES_128_GCM:** 128비트의 키를 사용하는 **표준 블록 암호화** 기술 ➕ 병렬 계산에 용이한 **암호화 알고리즘 GCM이 결합**된 알고리즘을 뜻한다. 


<br>

#### 인증 메커니즘

CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어진다. 

CA에서 발급한 인증서에는 `공개키`를 제공하여 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. 

**[인증서]**

- 서비스 정보
- 공개 키
- 지문
- 디지털 서명 

등으로 이루어짐

> 💡 **CA의 경우 공인 기업들만 사용 가능하다. [Comodo, GoDaddy, GlobalSign, 아마존]**  

<br>

#### CA 발급 과정 

**[CA 인증서 발급 과정]** 

1️⃣ 자신의 사이트 정보와 공개키를 CA에 제출

2️⃣ CA는 **공개키를 해시한 값**인 `지문`을 사용하는 <ins>CA의 비밀 키 등을 기반</ins>으로 CA 인증서 발급 


<br>

#### 암호화 알고리즘 

- 대수곡선 기반 ECDHE
- 모듈식 기반 DHE

➡️ `디피-헬만(Diffie-Hellman) 방식`을 근간으로 만들어짐 

<br>

#### 디피-헬만 키 교환 암호화 알고리즘

암호키를 교환하는 하나의 방식이다. 

`y = g^x mod p`

> 📕 **자세한 설명은 126 Page 참고**

<br>

#### 해싱 알고리즘

데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘이다. 

> 💡 SHA-256 알고리즘
> 
> 해시 **함수의 결괏값이 256비트**인 알고리즘 
> 
> ➡️ 해싱을 해야 할 메시지에 1을 추가하는 등 전처리를 하고 전처리된 메시지를 기반으로 해시를 반환한다. 
> 
> **사이트: https://emn178.github.io/online-tools/sha256.html**
> 
> ![Image](https://github.com/user-attachments/assets/e5ee4a60-5136-4d9b-970c-24c462bd25ac)

> 💡 **해시: 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값**
> 
> 💡 **해싱: 임의의 데이터를 해시로 바꿔주는 일(해시 함수가 담당함)**
> 
> 💡 **해시 함수: 임의의 데이터를 입력으로 받아 일정한 길이의 데이터로 바꾸어주는 함수**

> ✅ `TLS 1.`3은 사용자가 **이전 방문한 사이트로 다시 방문했을 때** 보안 세션을 만들 때 걸리는 통신을 하지 않는다. ➡️ **0-RTT**

<br>

### SEO에도 도움이 되는 HTTPS


**SEO(Search Engine Optimization)**

사용자들이 구글,네이버 같은 검색엔 진으로 웹 사이트 검색 시 그 결과를 **페이지 상단에 노출시켜 많은 사람이 볼 수 있도록 최적화 하는 방식**   

- 캐노니컬 설정 (link에 설정)
- 메타 설정 (html 파일의 meta)
- 페이지 속도 개선 ([PageSpeedIndights](https://pagespeed.web.dev/))
- 사이트맵 관리 (xml 파일)

<br>

### HTTPS 구축 방법

- CA에서 구매한 인증키를 기반
- 서버의 앞단의 HTTPS를 제공하는 로드 밸런서 두기
- 서버의 앞단의 HTTPS를 제공하는 CDN 두기

<br>

## HTTP/3

- HTTP/1.1 및 HTTP/2와 함께 World Wide Web에서 정보를 교환하는데 사용
- QUIC라는 계층 위에서 돌아간다. 
- UDP 기반
- **멀티플렉싱**이 되며, 초기 연결 설정 시 **지연 시간 감소**가 된다. 

<br>

### 초기 연결 설정 시 지연 시간 감소

3 Way HandShake를 거치지 않는다. 

➡️ 즉, 클라이언트가 서버에 신호를 한번 주고 서버도 그에 응답하면 바로 통신 시작이 가능

> 💡 **QUIC는 순방향 오류 수정 메커니즘(FEC, Foword Error Correction)이 적용**되어 있다. 
> 
> ➡️ 전송한 `패킷이 손실`되었다면 **수신 측에서 <ins>에러를 검출</ins>하고 <ins>수정</ins>하는 방식**으로, 열약한 네티워크 환경에서도 낮은 패킷 손실률을 낸다. 