# Chapter3.2 메모리
<br>

# 📚 목차

> **[1. 메모리 계층](#메모리-계층)**
>
> **[2. 메모리 관리](#메모리-관리)**

<br>

## 메모리 계층

![Image](https://github.com/user-attachments/assets/96cd49e6-16a3-4b3b-891c-c14e854a3d1d)

#### 레지스터

- CPU 안에 있는 작은 메모리, 휘발성
- 속도 가장 빠름
- 기억 용량 가장 적음 

<br>

#### 캐시

- L1, L2 캐시를 지칭한다. (L3도 존재)
- 휘발성
- 속도 빠름 
- 기억 용량 적음 

<br>

#### 주 기억 장치 

- RAM(메모리)을 지칭한다. 
- 휘발성
- 속도 보통
- 기억 용량 보통

> 💡**RAM**
> 
> `하드디스크`로부터 **일정량의 데이터를 복사해서 임시 저장**하고 이를 필요 시마다 <ins>CPU에 빠르게 전달</ins>하는 역할을 한다. 


<br>

#### 보조 기억 장치

- HDD, SSD 지칭한다.
- 비휘발성
- 속도 느림
- 기억 용량 많음


<br>

### 캐시 (Cache)

데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 `속도 차이`에 따른 **병목 현상을 줄이기 위한 메모리**를 말한다. 

➡️ 데이터 **접근 시간**을 줄이고 다시 **계산하는 시간**을 절약할 수 있다.

<br>

속도 차이를 해결하기 위해 **계층과 계층 사이에 있는 계층**을 `캐싱 계층`이라고 한다.

- `메모리`와 `CPU` 사이의 <ins>**속도 차이**</ins>가 너무 커 중간에 **레지스터 계층을 두어 속도 차이를 해결**
- `캐시` ↔️ `보조 기억 장치` 사이의 **주 기억 장치**

<br>

#### 지역성의 원리 

**캐시를 직접 설정하는 방법 ➡️ 자주 사용하는 데이터를 기반**

🔎 자주 사용하는 데이터에 대한 근거가 되는 것은?

 ➡️ **지역성** 


<br>

- **시간 지역성(temporal locality)**


    최근 사용한 데이터에다시 접근하려는 특성

    ex> for문의 변수 i [예시 코드: 144]

<br>

- **공간 지역성(spatial locality)**


    최근 접근한 데이터를 이루고 있는 공간이나 그 공간에 접근하는 특성

    ex> 배열내의 각 요소 [예시 코드: 145]


<br>

### 캐시히트와 캐시미스 

**캐시에서 원하는 데이터**를 찾았다면 ➡️ **캐시 히트**

해당 데이터가 캐시에 없다면 **주 메모리로 가서 데이터**를 찾아오는 것 ➡️ **캐시 미스**


> **💡 캐시 히트 vs 캐시 미스**
> 
> **캐시 히트**
> 
> - 제어장치를 거쳐 데이터를 가져온다. 
> 
> - CPU 내부 버스 기반으로 작동하기 때문에 빠르다. 
> 
> **캐시 미스**
> 
> - 시스템 버스 기반으로 작동이 느림 


![Image](https://github.com/user-attachments/assets/6b120dc9-0a6e-4264-bf01-f9bce7f594b9)


<br>

#### 캐시 매핑

캐시가 히트되기 위해 매핑하는 방법 

CPU의 `레지스터`와 `주 메모리` 간에 **데이터를 주고 받을 때를 기반**으로 한다. 


![Image](https://github.com/user-attachments/assets/cb5c0716-2ec9-4bf9-a239-71dd693336e2)

<br>

#### 웹 브라우저의 캐시


쿠키, 로컬 스토리지, 세션 스토리지 


**사용자의 커스텀한 정보**나 **인증 모듈 관련 사항**들을 웹 브라우저에 저장해서 
`추후 서버에 요청할 때` 자신을 나타내는 <ins>아이덴티티</ins>나 <ins>중복 요청 방지</ins>를 위해 쓰이며, **오리진(origin)에 종속**된다. 

<br>

**쿠기**

만료기한이 있는 키-값 저장소

- 4KB까지 데이터 저장이 가능하고 만료기한을 정할 수 있다. 
- **document, cookie로 쿠키**를 볼 수 없게 `httponly 옵션`을 거는 것이 중요하다. 
- 보통 서버에서 만료기한을 정한다. 


<br>

**로컬 스토리지**

만료기한이 없는 키-값 저장소


- 5KB까지 데이터 저장이 가능하고 웹 브라우저를 닫아도 유지된다. 
- HTML5를 지원하지 않는 웹 브라우저에서 사용 불가 
- 클라이언트에서만 수정 가능


<br>

**세션 스토리지**

만료기한이 없는 키-값 저장소


- 5KB까지 데이터 저장이 가능
- HTML5를 지원하지 않는 웹 브라우저에서 사용 불가
- 탭 단위로 세션 스토리지를 생성하고 탭을 닫을 때 해당 데이터가 삭제된다.
- 클라이언트에서만 수정 가능







<br>

## 메모리 관리

### 가상 메모리 (virtual memory)

실제로 **이용 가능한 메모리 자원을 추상화**하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것 


- `메모리 관리장치 (MMU)`에 의해 **실제 주소로 변환**되며, 이 덕분에 사용자는 실제 주소를 의식할 필요 없이 시스템 구축이 가능 


- 가상 메모리는 **가상 주소**(logical address)와 **실제 주소**(physical address)가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 `페이지 테이블`로 관리된다. 


- 이때 **속도 향상**을 위해 `TLB`를 사용한다.


<br>

> 💡 **TLB (캐시 계층)**
> 
>  메모리와 CPU 사이에 있는 **주소 변환을 위한 캐시** 
> 
> 페이지 테이블에 잇는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있다. 

<br>

#### 스와핑 (swapping)

마치 페이지 폴트가 일어나지 않은것 처럼 만든다. 

메모리에서 **당장 사용하지 않는 영역**을 하드디스크로 옮기고 <ins>하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것</ins>을 스와핑이라고 한다. 

>  💡**가상 메모리에는 존재 ⭕, 실제 메모리에는 존재 ❌ **데이터**나 **코드**에 접근 시 `페이지 폴트`가 발생한다.**  

<br>

**[흐름]**

>  📕 용어 정리
> 
> - **페이지(page)**: `가상 메모리`를 사용하는 최소 크기 단위 
> 
> - **프레임(frame)**: `실제 메모리`를 사용하는 최소 크기 단위 


<br>

1. 어떤 명령어가 `가상 주소에 접근`했으나 해당 **페이지가 없다면 트랩이 발생되어 운영체제에 알린다.** 


2. 운영체제는 **실제 디스크로부터 사용하지 않은 프레임을 찾는다.**  


3. 해당 프레임을 실제 메모리에 가져와서 `페이지 교체 알고리즘을 기반`으로 특정 페이지와 교체 (**스와핑이 일어남**)


4. 페이지 테이블을 갱신시킨 후 해당 명령어를 다시 시작한다. 

<br>

### 스레싱 (Thrashing) ⚠️ 심각한 성능 저하 초래

메모리에 너무 많은 프로세스가 동시에 올라가게 되면 **스와핑이 많이 일어나서 발생** (메모리의 페이지 폴트율이 높은 것)

<br>

**📉 페이지 폴트가 일어나면 ➡️ CPU 이용률이 낮아진다.**


- 페이지 폴트 발생 → CPU는 중단(interrupt)됨

- 현재 실행 중이던 프로세스가 **디스크 I/O를 기다리는 상태(블록 상태)**가 됨.

- 디스크에서 페이지를 읽는 동안 CPU는 이 작업에 관여하지 않음.

<br>

**[해결 방법]**

- 메모리 늘리기
- HDD 사용한다면 HDD를 SSD로 변경 
- 작업 세트와 PFF

<br>

#### 작업 세트 (working set)

프로세스의 과거 사용 이력인 **지역성을 통해 결정된 페이지 집합**을 만들어서 <ins>미리 메모리에 로드</ins>하는 것

<br>

#### PFF (Page Fault Frequency)

페이지 폴트 빈도를 조절하는 방법 

- 상한선과 하한선을 만든다. 
- 상한선 도달 시 프레임을 늘리고 하한선에 도달한다면 프레임을 줄인다. 


<br>

### 메모리 할당 

**시작 위치**, **할당 크기**를 기반으로 메모리를 할당한다. 


<br>

#### 연속 할당 

연속적으로 공간을 할당하는 것 

![Image](https://github.com/user-attachments/assets/ae37ddaa-ee4e-4650-82b7-0806a6175033)


<br>

- **고정 분활 방식 (fixed partition allocation)**
    
    - 메모리를 미리 나누어 관리 
    - 융통성이 없고 내부 단편화가 발생한다. 


- **가변 분활 방식 (variabel partition allocation)**

    - 프로그램 크기에 맞게 동적으로 메모리를 나누어 관리 
    - 외부 단편화가 발생할 수 있다. 

    | 이름               | 설명                                            |
    |------------------|-----------------------------------------------|
    | 최초적합 (First Fit) | 위쪽이나 아래쪽부터 시작해서 **홀을 찾으면 바로 할당**              |
    | 최적적합 (Best Fit)  | <ins>프로세스의 크기 이상</ins>인 공간 중 **가장 작은 홀부터 할당** |
    | 최악적합 (Worst Fit) | 프로세스 크기와 가장 많이 차이가 나는 홀에 할당                   |
    

> **📕 용어정리**    
> 
> - **내부 단편화(Internal fragmentation)**
> 
>   메모리를 나눈 크기보다 프로그램이 작아서 **들어가지 못하는 공간이 많이 발생하는 현상**
> 
> 
> - **외부 단편화(external fragmentation)**
> 
>     메모리를 나눈 크기보다 프로그램이 커서 **들어가지 못하는 공간이 많이 발생하는 현상**
> 
> 
> - **홀(hole)**
> 
>   할당할 수 있는 비어 있는 메모리 공간 



<br>

#### 불연속 할당 (현대 사용)

`페이징 기법`을 사용하여 메모리를 **동일한 크기(4KB)의 페이지**로 나누고 <ins>프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당</ins>하는 것 


<br>

- **페이징**

 ➡️**동일한 크기의 페이지 단위**로 나누어 메모리의 서로 다른 위치에 프로세스 할당 
    

⚠️ 주소 변환이 복잡해짐


<br>

- **세그멘테이션(segmentation)**

의미 단위인 세그먼트(segment)로 나누는 방식 


> 💡 **프로세스를 이루는 메모리**
> 
> - 코드 영역
> - 데이터 영역
> - 스택 영역
> - 힙 영역


**코드**와 **데이터**로 나누거나 **코드 내의 작은 함수**를 세그먼트로 놓고 나눌 수 있다. 

➡️ 공유와 보안 측면에서 장점을 가진다. 

⚠️ 홀 크기가 균일하지 않다.  


<br>


- **페이지드 세그멘테이션(paged segmentation)**

의미 단위인 세그먼트로 나눠 **공유나 보안 측면에 강점**을 두고 임의의 길이가 아닌 **동일한 크기의 페이지 단위로 나누는 것**을 말한다. 


<br>

### 메모리 교체 알고리즘 

#### 오프라인 알고리즘 (offline algorithm)

미래에 참조되는 페이지 ↔️ 현재 할당하는 페이지 **change**

<br>

🔎 **미래에 참조되는 페이지?** ➡️ 알수 없음

- 사용할 수 없는 알고리즘이다. 
- 가장 좋은 알고리즘이기 때문에 다른 알고리즘과의 성능 비교에 대한 상한 기준을 제공한다. 


<br>

#### FIFO

가장 먼저 온 페이지를 가장 먼저 놓는다. 

<br>

#### LRU (Least Recently Used)

가장 오래된 페이지를 바꾼다.

➡️ 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 한다. 


2개의 자료 구조로 구현한다. 

- **해시 테이블**: 이중 연결 리스트에서 빠르게 찾을 수 있도록 사용
- **이중 연결 리스트**: 한정된 메모리를 나타냄 

**[예시 코드 155 ~ 156]**

<br>

#### NUR (Not Used Recently)

LRU에서 발전한 알고리즘으로 일명 clock 알고리즘이라고 한다. 

**[흐름]**

1. 0과 1을 가진 비트를 둔다. 


2. 1은 최근에 참조된 것


3. 0은 참조되지 않은 것 


4. 시계방향으로돌면서 0을 찾고 찾은 순간 해당 프로세스 교체 


5. 해당 부분을 1로 변경

<br>

#### LFU (Least Frequently Used)

가장 참조 횟수가 적은 페이지를 교체한다. 