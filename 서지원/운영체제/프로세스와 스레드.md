# Chapter3.3 프로세스와 스레드

<br>

# 📚 목차

> **[1. 프로세스와 컴파일 과정](#프로세스와-컴파일-과정)**
>
> **[2. 프로세스의 상태](#프로세스의-상태)**
>
> **[3. 프로세스의 메모리 구조](#프로세스의-메모리-구조)**
>
> **[4. PCB](#pcb)**
>
> **[5. 멀티프로세싱](#멀티프로세싱)**
> 
> **[6. 스레드와 멀티스레딩](#스레드와-멀티스레딩)**
> 
> **[7. 공유 자원과 임계 영역](#공유-자원과-임계-영역)**
> 
> **[8. 교착 상태](#교착-상태)**

<br>

> **🔎 프로세스란?**
> 
> 프로세스는 컴퓨터에서 실행되고 있는 하나의 프로그램이라고 생각하면 된다.
> 
> CPU 스케줄링의 대상이 되는 **작업 (Task)**
> 
> ![Image](https://github.com/user-attachments/assets/8e92c260-de6b-415e-8738-d4438b75caae)
> 

## 프로세스와 컴파일 과정

프로그램(크롬 실행 파일)의 인스턴스화(2번 클릭) ➡️ **프로세스**

프로그램을 만드는 과정은 언어마다 다를 수 있다. 

> 📗 예시: C언어 기반 프로그램
> 
> 컴파일러가 **컴파일 과정**을 통해 컴퓨터가 이해할 수 있는 <ins>기계어로 번역</ins>하여 실행할 수 있는 파일을 만들게 된다. 

### 프로그램의 컴파일 과정 

![Image](https://github.com/user-attachments/assets/fc181d04-2568-464d-a90d-1b64a487b621)


- 전처리 

소스 코드의 <ins>주석을 제거</ins>하고 #include 등 <ins>헤더 파일을 병합</ins>하여 **매크로를 치환** 

> **💡 매크로**
> 
> 자주 사용하는 여러개의 명령어를 묶어서 하나의 키 입력 동작으로 만든 것
> 
> [[IT 용어] 매크로(macro)란?](https://blog.naver.com/kimjungsim89/221340510166)

<br>

- **컴파일러**

오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환

<br>

- **어셈블러**


목적 코드(object code)로 변환된다. (운영체제마다 다름)


<br>

- **링커**

프로그램 내에 있는 **라이브러리 함수** or 다른 **파일들과 목적 코드를 결합**하여 실행 파일로 만든다. 

> **✔️ 실행 파일 확장자: `.exe` or `.out`**

<br>

#### 📌 정적 라이브러리 vs 동적 라이브러리

| 항목           | 정적 라이브러리       | 동적 라이브러리       |
|----------------|------------------------|------------------------|
| 연결 시점      | 컴파일(빌드) 시        | 실행(run) 시           |
| 메모리 사용    | 중복 가능성 ↑          | 공유 가능성 ↑          |
| 실행 파일 크기 | 커짐                   | 작음                   |
| 외부 의존도    | 낮음                   | 높음                   |
| 예시           | `.lib`, `.a`           | `.dll`, `.so`          |

- 정적 라이브러리

프로그램 빌드 시 **라이브러리가 제공하는 모든 코드를 실행 파일에 넣는** 방식으로 라이브러리를 쓰는 방법

➡️ 시스템 환경 등 외부 의존도가 낮지만 코드 중복 등 메모리 효율성이 떨어지는 단점이 있다. 


<br>

- 동적 라이브러리

프로그램 실행 시 필요할 떄만 DLL 이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법 


➡️ 메모리 효울성에서의 장점을 지니지만 외부 의존도가 높아진다는 단점이 있다. 


<br>

## 프로세스의 상태
### 생성 상태

fork() 또는 exec() 함수를 통해 생성되며 PCB가 할당된다. 

#### fork()

부모 프로세스의 **주소 공간을 그대로 복사**하며, <ins>새로운 자식 프로세스를 생성</ins>하는 함수 

> **💡 주소 공간만 복사할 뿐 부모의 비동기 작업 등을 상속하지 않는다.** 

<br>

#### exec()

새롭게 프로세스 생성 


<br>


### 대기 상태 

메모리 공간이 충분하면 **메모리를 할당** 받고 

아니면 **아닌 상태로 대기**하고 

**CPU 스케줄러**로부터 <ins>CPU 소유권</ins>이 넘어오기를 기다리는 상태이다. 

<br>

### 대기 중단 상태

메모리 부족으로 일시 중단된 상태

<br>

### 실행 상태

`CPU 소유권`과 `메모리를 할당`받고 인스트럭션을 수행 중인 상태 

➡️ CPU burst가 일어났다고 표현

<br>

### 중단 상태

어떤 이벤트가 발생한 후 기다리며 프로세스가 차단된 상태 

**[예시]**

I/O 디바이스로 의한 **인터럽트로 이런 현상**이 많이 발생하기도 한다. 

➡️ 인쇄버튼 클릭 시 프로세스가 잠깐 멈춘 듯할 때 

<br>


### 일시 중단 상태

메모리 부족으로 일시 중단된 상태

<br>

### 종료 상태 

메모리와 CPU 소유권을 모두 놓고 가는 상태 

**[종료 종류]**

- 자연스러운 종료 
- 부모가 자식 프로세스를 강제시키는 비자발적 종료(abort)
- 자식 프로세스에 할당된 자원의 한계치로인한 종료
- 부모 프로세스의 종료
- 사용자의 명령어

<br>


## 프로세스의 메모리 구조

![Image](https://github.com/user-attachments/assets/3327cf45-4f23-4c33-8583-051f36989329)

### 스택과 힙

- 동적 할당이 되며, 동적 할당은 **런타임 단계에서 메모리를 할당** 받는 것을 의미한다. 

**[스택]**
- `지역변수`, `매개변수`, `실행되는 함수`에 의헤 <ins>늘어나거나 줄어드는</ins> 메모리 영역


- **함수가 호출될 때마다** 호출될 때의 환경 등 <ins>특정 정보가 스택에 계속해서 저장</ins>된다. 


- **재귀함수가 호출**된다고 했을 떄 <ins>새로운 스택 프레임이 매번 사용</ins>되기 때문에 함수 내의 변수 집합이 해당 함수의 **다른 인스턴스 변수를 방해하지 않는다.** 

<br>

**[힙]**
- 변수들을 담는다.


- malloc(), free() 함수를 통해 관리할 수 있으며, 동적으로 관리되는 **자료 구조의 경우 힙 영역을 사용**한다, (vetor는 내부적으로 힙 영역을 사용한다. )

<br>

> 💡 **함수 내 컬렉션이나 객체가 선언되어 있는 경우 동작 방식**
> 
> **[예시 코드]**
> ```java
> public void doSomething() {
>    int number = 5;     // 스택에 저장됨
>    List<String> names = new ArrayList<>();    // names는 스택, 실제 리스트 객체는 힙
>    names.add("Alice"); //힙에 저장됨 
>}
> ```
> 
> 스택은 👉 “어디 있는지(주소)”만 기억하는 곳
> 
> 힙은 👉 “실제 값”이 저장되는 곳

<br>

### 데이터 영역과 코드 영역

- 정적 할당이 되며, 정적 할당은 **컴파일 단계에서 메모리를 할당** 받는 것을 의미한다.

<br>

**[데이터 영역 & 코드 영역]**

- BSS segment, Data segment, code/text segment로 나뉘어 저장된다. 


- BSS는 **전역변수** 또는 **static**, **const로** 선언되어 있고 `0으로 초기화` 또는 `어떠한 값으로도 초기화가 되어있지 않은` 변수들이 할당된다. 


- Data segment **전역변수** 또는 **static**, **const로** 선언되어 있고 `0이 아닌 값으로 초기화`된 변수가 할당된다. 


- code segment는 프로그램의 **코드**가 들어간다. 

<br>

## PCB

- PCB(Proceess Control Block)는 운영체제에서 프로세스에 대한 메타데이터를 저장한 `데이터`를 말한다. 

> 💡 **메타데이터**
> 
> - 데이터에 대한 **구조화된 데이터**이자 `데이터`를 **설명하는 작은 데이터**,
> 
> 
> - 대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 **규칙에 따라 콘텐츠에 대해 부여되는 데이터**이다. 

- `프로세스 제어 블록`이라고 하기도 한다. 


- 프로세스가 생성되면 운영체제는 해당 PCB를 생성한다. 


**[흐름]**

프로그램 실행 

➡️ 프로세스 할당

➡️ 프로세스 주소 값들에 스택, 힙 등의 구조를 기반으로 메모리 할당

➡️ 프로세스의 메타데이터들이 PCB에 저장되어 관리 

⚠️ 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 **커널 스택의 가장 앞부분에서 관리**된다. 

<br>

### PCB 구조

- **프로세스 스케줄링 상태**: CPU에 대한 소유권을 얻은 이후의 상태 (`준비`, `일시중단`)


- **프로세스 ID:** 프로세스 ID, 해당 프로세스의 자식 프로세스 ID


- **프로세스 권한**: 컴퓨터 자원 or I/O 디바이스에 대한 권한 정보


- **프로그램 카운터**: 실행되어야 할 다음 명령어 주소에 대한 포인터


- **CPU 레지스터**: 실행을 위해 저장해야 할 레지스터에 대한 정보


- **CPU 스케줄링 정보**: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보


- **계정 정보**: 실행에 사용된 CPU 사용량, 유저 정보


- **I/O 상태 정보** : 할당된 I/O 디바이스 목록


<br>


### 컨텍스트 스위칭 (Context Switching)

PCB를 기반으로 프로세스의 **상태를 저장**하고 **로드**시키는 과정을 말한다. 

- 할당된 시간이 끝나거나 인터럽트에 의해 발생


- 컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 실제 실행되는 프로세스는 단 한개이다. 
    
    ➡️ 다른 프로세스와 **컨텍스트 스위칭이 아주 빠른 속도로 실행**되기 때문에 <ins>동시에 구동되는 것 처럼 보인다.  
    

> 💡 **현대 컴퓨터는 멀티 코어의 CPU를 가지기 때문에 한 시점에 한 개의 프로그램이라는 설명은 틀린 설명이다.** 
> 
> 다만, 컨텍스트 스위칭을 설명할 때는 싱글 코어를 기준으로 설명한다. 

<br>

**[문제점]**

![Image](https://github.com/user-attachments/assets/50bd9ee0-b656-4008-9601-027f89574b2e)

- 유후 시간(idle time) 발생


- `캐시 미스`로 인한 **비용 발생**

 > ⚠️ **스위칭이 일어날 때** 프로세스가 가지고 있는 <ins>메모리 주소가 그대로 있으면 잘못된 주소 변환</ins>이 생기므로 `캐시 클리어 과정`을 겪게 되고 
 > 
> ➡️ 이 때문에 캐시 미스가 발생한다. 

> 💡 **스레드에서도 스위칭은 일어난다.** 
> 
> 
> 스레드는 <ins>스택 영역을 제외한 모든 메모리를 공유</ins>하기 떄문에 스레드 컨텍스트 스위칭의 경우 **비용이 더 적고** **시간도 더 적게** 걸린다. 


<br>

## 멀티프로세싱

## 스레드와 멀티스레딩

## 공유 자원과 임계 영역

## 교착 상태