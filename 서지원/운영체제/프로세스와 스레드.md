# Chapter3.3 프로세스와 스레드

<br>

# 📚 목차

> **[1. 프로세스와 컴파일 과정](#프로세스와-컴파일-과정)**
>
> **[2. 프로세스의 상태](#프로세스의-상태)**
>
> **[3. 프로세스의 메모리 구조](#프로세스의-메모리-구조)**
>
> **[4. PCB](#pcb)**
>
> **[5. 멀티프로세싱](#멀티프로세싱)**
> 
> **[6. 스레드와 멀티스레딩](#스레드와-멀티스레딩)**
> 
> **[7. 공유 자원과 임계 영역](#공유-자원과-임계-영역)**
> 
> **[8. 교착 상태](#교착-상태)**

<br>

> **🔎 프로세스란?**
> 
> 프로세스는 컴퓨터에서 실행되고 있는 하나의 프로그램이라고 생각하면 된다.
> 
> CPU 스케줄링의 대상이 되는 **작업 (Task)**
> 
> ![Image](https://github.com/user-attachments/assets/8e92c260-de6b-415e-8738-d4438b75caae)
> 

## 프로세스와 컴파일 과정

프로그램(크롬 실행 파일)의 인스턴스화(2번 클릭) ➡️ **프로세스**

프로그램을 만드는 과정은 언어마다 다를 수 있다. 

> 📗 예시: C언어 기반 프로그램
> 
> 컴파일러가 **컴파일 과정**을 통해 컴퓨터가 이해할 수 있는 <ins>기계어로 번역</ins>하여 실행할 수 있는 파일을 만들게 된다. 

### 프로그램의 컴파일 과정 

![Image](https://github.com/user-attachments/assets/fc181d04-2568-464d-a90d-1b64a487b621)


- 전처리 

소스 코드의 <ins>주석을 제거</ins>하고 #include 등 <ins>헤더 파일을 병합</ins>하여 **매크로를 치환** 

> **💡 매크로**
> 
> 자주 사용하는 여러개의 명령어를 묶어서 하나의 키 입력 동작으로 만든 것
> 
> [[IT 용어] 매크로(macro)란?](https://blog.naver.com/kimjungsim89/221340510166)

<br>

- **컴파일러**

오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환

<br>

- **어셈블러**


목적 코드(object code)로 변환된다. (운영체제마다 다름)


<br>

- **링커**

프로그램 내에 있는 **라이브러리 함수** or 다른 **파일들과 목적 코드를 결합**하여 실행 파일로 만든다. 

> **✔️ 실행 파일 확장자: `.exe` or `.out`**

<br>

#### 📌 정적 라이브러리 vs 동적 라이브러리

| 항목           | 정적 라이브러리       | 동적 라이브러리       |
|----------------|------------------------|------------------------|
| 연결 시점      | 컴파일(빌드) 시        | 실행(run) 시           |
| 메모리 사용    | 중복 가능성 ↑          | 공유 가능성 ↑          |
| 실행 파일 크기 | 커짐                   | 작음                   |
| 외부 의존도    | 낮음                   | 높음                   |
| 예시           | `.lib`, `.a`           | `.dll`, `.so`          |

- 정적 라이브러리

프로그램 빌드 시 **라이브러리가 제공하는 모든 코드를 실행 파일에 넣는** 방식으로 라이브러리를 쓰는 방법

➡️ 시스템 환경 등 외부 의존도가 낮지만 코드 중복 등 메모리 효율성이 떨어지는 단점이 있다. 


<br>

- 동적 라이브러리

프로그램 실행 시 필요할 떄만 DLL 이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법 


➡️ 메모리 효울성에서의 장점을 지니지만 외부 의존도가 높아진다는 단점이 있다. 


<br>

## 프로세스의 상태
### 생성 상태

fork() 또는 exec() 함수를 통해 생성되며 PCB가 할당된다. 

#### fork()

부모 프로세스의 **주소 공간을 그대로 복사**하며, <ins>새로운 자식 프로세스를 생성</ins>하는 함수 

> **💡 주소 공간만 복사할 뿐 부모의 비동기 작업 등을 상속하지 않는다.** 

<br>

#### exec()

새롭게 프로세스 생성 


<br>


### 대기 상태 

메모리 공간이 충분하면 **메모리를 할당** 받고 

아니면 **아닌 상태로 대기**하고 

**CPU 스케줄러**로부터 <ins>CPU 소유권</ins>이 넘어오기를 기다리는 상태이다. 

<br>

### 대기 중단 상태

메모리 부족으로 일시 중단된 상태

<br>

### 실행 상태

`CPU 소유권`과 `메모리를 할당`받고 인스트럭션을 수행 중인 상태 

➡️ CPU burst가 일어났다고 표현

<br>

### 중단 상태

어떤 이벤트가 발생한 후 기다리며 프로세스가 차단된 상태 

**[예시]**

I/O 디바이스로 의한 **인터럽트로 이런 현상**이 많이 발생하기도 한다. 

➡️ 인쇄버튼 클릭 시 프로세스가 잠깐 멈춘 듯할 때 

<br>


### 일시 중단 상태

메모리 부족으로 일시 중단된 상태

<br>

### 종료 상태 

메모리와 CPU 소유권을 모두 놓고 가는 상태 

**[종료 종류]**

- 자연스러운 종료 
- 부모가 자식 프로세스를 강제시키는 비자발적 종료(abort)
- 자식 프로세스에 할당된 자원의 한계치로인한 종료
- 부모 프로세스의 종료
- 사용자의 명령어

<br>


## 프로세스의 메모리 구조

![Image](https://github.com/user-attachments/assets/3327cf45-4f23-4c33-8583-051f36989329)

### 스택과 힙

- 동적 할당이 되며, 동적 할당은 **런타임 단계에서 메모리를 할당** 받는 것을 의미한다. 

**[스택]**
- `지역변수`, `매개변수`, `실행되는 함수`에 의헤 <ins>늘어나거나 줄어드는</ins> 메모리 영역


- **함수가 호출될 때마다** 호출될 때의 환경 등 <ins>특정 정보가 스택에 계속해서 저장</ins>된다. 


- **재귀함수가 호출**된다고 했을 떄 <ins>새로운 스택 프레임이 매번 사용</ins>되기 때문에 함수 내의 변수 집합이 해당 함수의 **다른 인스턴스 변수를 방해하지 않는다.** 

<br>

**[힙]**
- 변수들을 담는다.


- malloc(), free() 함수를 통해 관리할 수 있으며, 동적으로 관리되는 **자료 구조의 경우 힙 영역을 사용**한다, (vetor는 내부적으로 힙 영역을 사용한다. )

<br>

> 💡 **함수 내 컬렉션이나 객체가 선언되어 있는 경우 동작 방식**
> 
> **[예시 코드]**
> ```java
> public void doSomething() {
>    int number = 5;     // 스택에 저장됨
>    List<String> names = new ArrayList<>();    // names는 스택, 실제 리스트 객체는 힙
>    names.add("Alice"); //힙에 저장됨 
>}
> ```
> 
> 스택은 👉 “어디 있는지(주소)”만 기억하는 곳
> 
> 힙은 👉 “실제 값”이 저장되는 곳

<br>

### 데이터 영역과 코드 영역

- 정적 할당이 되며, 정적 할당은 **컴파일 단계에서 메모리를 할당** 받는 것을 의미한다.

<br>

**[데이터 영역 & 코드 영역]**

- BSS segment, Data segment, code/text segment로 나뉘어 저장된다. 


- BSS는 **전역변수** 또는 **static**, **const로** 선언되어 있고 `0으로 초기화` 또는 `어떠한 값으로도 초기화가 되어있지 않은` 변수들이 할당된다. 


- Data segment **전역변수** 또는 **static**, **const로** 선언되어 있고 `0이 아닌 값으로 초기화`된 변수가 할당된다. 


- code segment는 프로그램의 **코드**가 들어간다. 

<br>

## PCB

- PCB(Proceess Control Block)는 운영체제에서 프로세스에 대한 메타데이터를 저장한 `데이터`를 말한다. 

> 💡 **메타데이터**
> 
> - 데이터에 대한 **구조화된 데이터**이자 `데이터`를 **설명하는 작은 데이터**,
> 
> 
> - 대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 **규칙에 따라 콘텐츠에 대해 부여되는 데이터**이다. 

- `프로세스 제어 블록`이라고 하기도 한다. 


- 프로세스가 생성되면 운영체제는 해당 PCB를 생성한다. 


**[흐름]**

프로그램 실행 

➡️ 프로세스 할당

➡️ 프로세스 주소 값들에 스택, 힙 등의 구조를 기반으로 메모리 할당

➡️ 프로세스의 메타데이터들이 PCB에 저장되어 관리 

⚠️ 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 **커널 스택의 가장 앞부분에서 관리**된다. 

<br>

### PCB 구조

- **프로세스 스케줄링 상태**: CPU에 대한 소유권을 얻은 이후의 상태 (`준비`, `일시중단`)


- **프로세스 ID:** 프로세스 ID, 해당 프로세스의 자식 프로세스 ID


- **프로세스 권한**: 컴퓨터 자원 or I/O 디바이스에 대한 권한 정보


- **프로그램 카운터**: 실행되어야 할 다음 명령어 주소에 대한 포인터


- **CPU 레지스터**: 실행을 위해 저장해야 할 레지스터에 대한 정보


- **CPU 스케줄링 정보**: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보


- **계정 정보**: 실행에 사용된 CPU 사용량, 유저 정보


- **I/O 상태 정보** : 할당된 I/O 디바이스 목록


<br>


### 컨텍스트 스위칭 (Context Switching)

PCB를 기반으로 프로세스의 **상태를 저장**하고 **로드**시키는 과정을 말한다. 

- 할당된 시간이 끝나거나 인터럽트에 의해 발생


- 컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 실제 실행되는 프로세스는 단 한개이다. 
    
    ➡️ 다른 프로세스와 **컨텍스트 스위칭이 아주 빠른 속도로 실행**되기 때문에 <ins>동시에 구동되는 것 처럼 보인다.  
    

> 💡 **현대 컴퓨터는 멀티 코어의 CPU를 가지기 때문에 한 시점에 한 개의 프로그램이라는 설명은 틀린 설명이다.** 
> 
> 다만, 컨텍스트 스위칭을 설명할 때는 싱글 코어를 기준으로 설명한다. 

<br>

**[문제점]**

![Image](https://github.com/user-attachments/assets/50bd9ee0-b656-4008-9601-027f89574b2e)

- 유후 시간(idle time) 발생


- `캐시 미스`로 인한 **비용 발생**

 > ⚠️ **스위칭이 일어날 때** 프로세스가 가지고 있는 <ins>메모리 주소가 그대로 있으면 잘못된 주소 변환</ins>이 생기므로 `캐시 클리어 과정`을 겪게 되고 
 > 
> ➡️ 이 때문에 캐시 미스가 발생한다. 

> 💡 **스레드에서도 스위칭은 일어난다.** 
> 
> 
> 스레드는 <ins>스택 영역을 제외한 모든 메모리를 공유</ins>하기 떄문에 스레드 컨텍스트 스위칭의 경우 **비용이 더 적고** **시간도 더 적게** 걸린다. 


<br>

## 멀티프로세싱

> 📌 **멀티 프로세스를 통해 동시에 2가지 일을 수행할 수 있는 것을 말한다.** 

- 하나 이상의 일을 병렬로 처리 가능


- 특정 프로세스의 **메모리**, **프로세스** 중 일부에 `문제가 발생`되더라도 <ins>다른 프로세스를 이용해서 처리할 수 있어 신뢰성</ins>이 높다. 


<br>

### 웹 브라우저 

![Image](https://github.com/user-attachments/assets/ced2c6ab-a216-48b0-ad73-04761b15060e)

- **브라우저 프로세스**

    - 주소 표시줄, 북마크 막대, 앞/뒤로가기 버튼 등을 담당

    - 네트워크 요청이나 파일 접근 같은 권한을 담당


- **렌더러 프로세스**

    웹사이트가 **보이는 부분**의 모든 것을 제어 


- 플러그인 프로세스

    웹 사이트에서 사용하는 플러그인 제어


- GPU 프로세스 

    GPU를  이용해서 화면을 그리는 부분을 제어한다. 


<br>

### IPC (Inter Process Communication)

> 📌 **프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 매커니즘을 뜻한다.** 

**[예시]**

클라이언트는 데이터 요청 ➡️ 서버는 요청에 응답

<br>

**[종류]**

- 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐

➡️ 이들은 모두 메모리가 완전 <ins>공유되는 스레드보다 속도가 느리다. 


<br>

#### 공유 메모리

여러 프로세스에 `동일한 메모리 블록`에 대한 **접근 권한이 부여**되어 프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 것 


![Image](https://github.com/user-attachments/assets/c7c8f371-78d0-43f2-8f88-a96b50aa2627)

- 메모리 자체를 공유하기 때문에 **불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르다.**


- 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 **동기화가 필요**하다. 


- 하드웨어 관점에서는 **RAM**을 가르킨다. 

<br>

#### 파일 & 소켓

**[파일]**

**디스크에 저장된 데이터** or **파일 서버에서 제공한 데이터**

➡️ 이를 기반으로 통신

<br>

**[소켓]**

동일 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 `네트워크 인터페이스`를 통해 **전송하는 데이터**를 의미

➡️ **TCP나 UDP가 있다.** 


<br>

#### 익명 파이프

프로세스 간에 `FIFO방식`으로 읽히는 **임시 공간인 파이프**를 기반으로 데이터를 주고받으며, <ins>단방향 방식</ins>의 **읽기 전용**, **쓰기 전용** 파이프를 만들어서 작동하는 방식을 말한다. 

➡️ **부모, 자식 프로세스 간에만 사용 가능** 


<br>

#### 명명된 파이프

`파이프 서버`와 하나 이상의 `파이프 클라이언트` 간의 통신을 위한 명명된 **단방향** 또는 **양방향** 파이프를 말한다. 

**[옵션 1: 하나의 파이프 인스턴스]**

![Image](https://github.com/user-attachments/assets/c47324be-b285-4523-8462-5b8011f1c61c)


<br>

**[옵션 2: 여러개의 파이프 인스턴스]**

![Image](https://github.com/user-attachments/assets/2bdd63b0-dc4e-45a2-95f6-3c2e386cbbfa)


➡️ 클라이언트/서버 통신을 위한 별도의 파이프 제공

➡️ 여러 파이프를 동시에 사용할 수 있다. 

➡️ **컴퓨터의 프로세스**끼리 또는 **네트워크상의 컴퓨터**와도 통신할 수 있다. 

<br>

<br>

#### 메시지 큐

큐(Queue) 데이터 구조 형태로 관리하는 것 

- 커널의 전역변수 형태 등 **커널에서 전역적으로 관리**


- 다른 IPC 방식에 비해 **사용 방법이 매우 직관적이고 간단**


- 다른 코드의 수정 없이 단지 몇줄의 코드를 추가 시켜 간단하게 메시지 큐에 접근 가능 

<br>

`공유 메모리`를 통해 **IPC 구현 시** 쓰기 및 읽기 빈도가 높으면 <ins>동기화로 인해 기능 구현이 복잡</ins>해 지는데 

➡️ 이때 메시지 큐를 사용하기도 한다.

## 스레드와 멀티스레딩

### 스레드 

>  📌 **프로세스 실행 가능한 가장 작은 단위**


- 프로세스는 여러개의 스레드를 가질 수 있다. 


- 스레드는 `코드`, `데이터`, `힙`은 **스레드끼리 서로 공유** (그외 (스택)은 각각 생성)

<br>

### 멀티스레딩 

멀티스레드로 처리하는 기법으로 스레드끼리 서로 자원을 공유하기 때문에 효율성이 높다. 

- 한 스레드가 중단되어도 다른 스레드는 실행 가능 


- 동시성에 큰 장점


⚠️ 다만, **한 스레드에 문제가 생길 시** <ins>다른 스레드에도 영향</ins>을 끼쳐 **스레드로 이루어져 있는 프로세스에 영향을 줄 수 있는 단점**이 있다. 

<br>

**[예시]**

**렌더러 프로세스** 

메인 스레드, 워커 스레드, 컴포지터 스레드, 레스터 스레드가 존재

<br>

## 공유 자원과 임계 영역

### 공유 자원 (shared redource)

`프로세스`, `스레드`가 함께 접근할 수 있는 **모니터**, **프린터**, **메모리**, **파일**, **데이터** 등의 <ins>자원이나 변수

> **⚠️ 공유자원을 2개 이상의 프로세스가 동시에 읽거나 쓰는 상황 ➡️ 경쟁 상태(race condition)**


<br>

### 임계 영역 (critical section)

2개 이상의 프로세스, 스레드가 **공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역** 

**[해결 방법]**

- 뮤텍스, 세마포어, 모니터가 있다. 

    ➡️ **상호 배제(mutual exclusion), 한정 대기(bounded wating), 융통성(progress)이라는 조건을 만족한다.** 

    > 💡 **상호 배제: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 ❌**
  > 
    >  💡 **한정 대기: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안된다.**
    > 
    > 💡 **융통성: 임계 영역에 아무도 사용하지 않는다면 외부에 어떠한 프로세스도 들어갈 수 있다. (프로세스끼리 서로 방해 ❌)**

<br>

**토대가 되는 매커니즘 ➡️ Lock(잠금)**

<br>

#### 뮤텍스 (mutex)

프로세스나 스레드가 공유 자원을 `lock() 설정`하고 사용한 후 `unlock() 해제`하는 객체

➡️ 상태: **잠금** or **잠금해제**

<br>

#### 세마포어 (semaphore)

일반화된 뮤텍스이다. 

`정수 값`과 `wait(P 함수)` 및 `signal(V 함수)`로 공유 자원에 대한 접근을 처리한다. 

- wait(): 자신의 차례가 올 때까지 대기


- signal(): 다음 프로세스로 순서를 넘겨준다. 


- 상호 배제를 명시적으로 구현해주어야 한다. 

> **💡 바이너리 세마포어** 
> 
> **0/1 값만 가질 수 있는 세마포어**
> 
> **뮤텍스**는 `잠금 매커니즘`이고 **세마포어**는 신호 기반으로 상호 배제가 일어나는 `신호 매커니즘`이다. 

> **💡 카운팅 세마포어**
>여러개의 값을 가질 수 있는 세마포어
> ****
> 
> ➡️ 여러 자원에 대한 접근을 제어하는데 사용
>

<br>

#### 모니터

공유 자원을 숨기고 해당 **접근에 대해 인터페이스만 제공**

![Image](https://github.com/user-attachments/assets/cc704258-02e6-4bb0-ad68-bc4e2fe75c35)

- **상호 배제가 자동이다**. 

<br>

## 교착 상태 (deadLock)

>  📌 **2개의 프로세스들이 서로 가진 자원을 기다리며 중단된 상태**
> 
> ![Image](https://github.com/user-attachments/assets/639d6110-dd97-4a88-8478-ccb62f1d8d74)

**[원인]**

- 상호 배제: 자원 독점으로 다른 프로세스들의 접근을 제한


- 점유 대기: 특정 프로세스가 점유한 자원에 다른 프로세스가 요청하는 상태


- 비선점: 다른 프로세스의 자원을 강제로 가져올 수 ❌ 


- 환형 대기: 서로가 서로의 자원을 요구하는 상황


<br>

**[해결 방법]**

- 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계


- 교착 상태 가능성이 없을 때만 할당되며, 요청할 자원들의 최대치를 통해 **자원 할당 가능 여부를 파악**하는 `은행원 알고리즘`을 쓴다. 

    > 💡 **은행원 알고리즘**
    > 
    > `총 자원의 양`과 현재 `할당된 자원의 양`을 기준으로 **안정** 또는 **불안정** 상태로 나누고 <ins>안정 상태로 가도록 자원을 할당
  
- **교착 상태 발생 시** <ins>사이클이 있는지 찾아보고 관련 프로세스를 하나씩 지운다. 


- 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커 발생 시 <ins>작업을 종료</ins>한다. (**현대 채택**)


