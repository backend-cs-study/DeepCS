# Chapter3.3 프로세스와 스레드

<br>

# 📚 목차

> **[1. 프로세스와 컴파일 과정](#프로세스와-컴파일-과정)**
>
> **[2. 프로세스의 상태](#프로세스의-상태)**
>
> **[3. 프로세스의 메모리 구조](#프로세스의-메모리-구조)**
>
> **[4. PCB](#pcb)**
>
> **[5. 멀티프로세싱](#멀티프로세싱)**
> 
> **[6. 스레드와 멀티스레딩](#스레드와-멀티스레딩)**
> 
> **[7. 공유 자원과 임계 영역](#공유-자원과-임계-영역)**
> 
> **[8. 교착 상태](#교착-상태)**

<br>

> **🔎 프로세스란?**
> 
> 프로세스는 컴퓨터에서 실행되고 있는 하나의 프로그램이라고 생각하면 된다.
> 
> CPU 스케줄링의 대상이 되는 **작업 (Task)**
> 
> ![Image](https://github.com/user-attachments/assets/8e92c260-de6b-415e-8738-d4438b75caae)
> 

## 프로세스와 컴파일 과정

프로그램(크롬 실행 파일)의 인스턴스화(2번 클릭) ➡️ **프로세스**

프로그램을 만드는 과정은 언어마다 다를 수 있다. 

> 📗 예시: C언어 기반 프로그램
> 
> 컴파일러가 **컴파일 과정**을 통해 컴퓨터가 이해할 수 있는 <ins>기계어로 번역</ins>하여 실행할 수 있는 파일을 만들게 된다. 

### 프로그램의 컴파일 과정 

![Image](https://github.com/user-attachments/assets/fc181d04-2568-464d-a90d-1b64a487b621)


- 전처리 

소스 코드의 <ins>주석을 제거</ins>하고 #include 등 <ins>헤더 파일을 병합</ins>하여 **매크로를 치환** 

> **💡 매크로**
> 
> 자주 사용하는 여러개의 명령어를 묶어서 하나의 키 입력 동작으로 만든 것
> 
> [[IT 용어] 매크로(macro)란?](https://blog.naver.com/kimjungsim89/221340510166)

<br>

- **컴파일러**

오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환

<br>

- **어셈블러**


목적 코드(object code)로 변환된다. (운영체제마다 다름)


<br>

- **링커**

프로그램 내에 있는 **라이브러리 함수** or 다른 **파일들과 목적 코드를 결합**하여 실행 파일로 만든다. 

> **✔️ 실행 파일 확장자: `.exe` or `.out`**

<br>

#### 📌 정적 라이브러리 vs 동적 라이브러리

| 항목           | 정적 라이브러리       | 동적 라이브러리       |
|----------------|------------------------|------------------------|
| 연결 시점      | 컴파일(빌드) 시        | 실행(run) 시           |
| 메모리 사용    | 중복 가능성 ↑          | 공유 가능성 ↑          |
| 실행 파일 크기 | 커짐                   | 작음                   |
| 외부 의존도    | 낮음                   | 높음                   |
| 예시           | `.lib`, `.a`           | `.dll`, `.so`          |

- 정적 라이브러리

프로그램 빌드 시 **라이브러리가 제공하는 모든 코드를 실행 파일에 넣는** 방식으로 라이브러리를 쓰는 방법

➡️ 시스템 환경 등 외부 의존도가 낮지만 코드 중복 등 메모리 효율성이 떨어지는 단점이 있다. 


<br>

- 동적 라이브러리

프로그램 실행 시 필요할 떄만 DLL 이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법 


➡️ 메모리 효울성에서의 장점을 지니지만 외부 의존도가 높아진다는 단점이 있다. 


<br>

## 프로세스의 상태
### 생성 상태

fork() 또는 exec() 함수를 통해 생성되며 PCB가 할당된다. 

#### fork()

부모 프로세스의 **주소 공간을 그대로 복사**하며, <ins>새로운 자식 프로세스를 생성</ins>하는 함수 

> **💡 주소 공간만 복사할 뿐 부모의 비동기 작업 등을 상속하지 않는다.** 

<br>

#### exec()

새롭게 프로세스 생성 


<br>


### 대기 상태 

메모리 공간이 충분하면 **메모리를 할당** 받고 

아니면 **아닌 상태로 대기**하고 

**CPU 스케줄러**로부터 <ins>CPU 소유권</ins>이 넘어오기를 기다리는 상태이다. 

<br>

### 대기 중단 상태

메모리 부족으로 일시 중단된 상태

<br>

### 실행 상태

`CPU 소유권`과 `메모리를 할당`받고 인스트럭션을 수행 중인 상태 

➡️ CPU burst가 일어났다고 표현

<br>

### 중단 상태

어떤 이벤트가 발생한 후 기다리며 프로세스가 차단된 상태 

**[예시]**

I/O 디바이스로 의한 **인터럽트로 이런 현상**이 많이 발생하기도 한다. 

➡️ 인쇄버튼 클릭 시 프로세스가 잠깐 멈춘 듯할 때 

<br>


### 일시 중단 상태

메모리 부족으로 일시 중단된 상태

<br>

### 종료 상태 

메모리와 CPU 소유권을 모두 놓고 가는 상태 

**[종료 종류]**

- 자연스러운 종료 
- 부모가 자식 프로세스를 강제시키는 비자발적 종료(abort)
- 자식 프로세스에 할당된 자원의 한계치로인한 종료
- 부모 프로세스의 종료
- 사용자의 명령어

<br>


## 프로세스의 메모리 구조

## PCB

## 멀티프로세싱

## 스레드와 멀티스레딩

## 공유 자원과 임계 영역

## 교착 상태