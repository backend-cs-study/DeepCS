# Chapter4.1 데이터베이스의 기본

<br>

# 📚 목차

> **[1. 엔터티](#엔터티)**
>
> **[2. 릴레이션](#릴레이션)**
>
> **[3. 속성](#속성)**
> 
> **[4. 도메인](#도메인)**
> 
> **[5. 필드와 레코드](#필드와-레코드)**
> 
> **[6. 관계](#관계)**
> 
> **[7. 키](#키)**


<br>

> **💡 데이터 베이스란?**
> 
> 일정한 규칙, 혹은 규약을 통해 `구조화되어 저장되는 데이터의 모음`을 의미합니다. 
> 
> 해당 데이터베이스를 제어, 관리하는 시스템을 **DBMS(DataBase Management System)이라고 합니다** 

> 💡 **DBMS**
> 
> 특정 DBMS마다 정의된 쿼리 언어를 통해 `삽입`, `삭제`, `수정`, `조회` 등을 수행할 수 있습니다. 
> 
> **실시간 접근과 동시 공유가 가능합니다.** 

흐름은 아래와 같습니다. 

- 응용 프로그램에서 데이터베이스 안에 있는 데이터를 꺼내 사용 가능

<img width="447" height="647" alt="Image" src="https://github.com/user-attachments/assets/54373610-cdf0-49e4-82f1-6135e83dd3d9" />

<br>

## 엔터티

Entity는 사람, 장소, 물건 등의 명사를 의미합니다. 

### 약한 엔터티 (게시판)

혼자서 존재하지 못하고 다른 존재에 종속적인 엔티티

<br>

### 강한 엔터티(리뷰)

혼자서 존재하는 엔티티

<br>

## 릴레이션

데이터베이스에서 정보를 구분하여 저장하는 기본 단위를 의미합니다. 

관계형 데이터베이스 ➡️ **테이블**
NoSQL 데이터베이스 ➡️ **컬렉션**

<img width="1128" height="549" alt="Image" src="https://github.com/user-attachments/assets/a6f4d8a9-2451-4f71-b17a-fe85b65c6e14" />

위의 그림처럼 레코드가 쌓여 테이블이 되고 테이블이 쌓여 데이터베이스가 됩니다. 

<br>

## 속성

릴레이션에서 관리하는 구체적이고 **고유한 이름을 갖는 정보**입니다. 

**[예시]**

**차 엔티티의 속성**

- 바퀴
- 차종
- 차 번호

시스템이나 서비스의 목적, 기능, 그리고 사용자의 필요에 따라 관련 있는 속성만을 선택해서 데이터베이스에 저장하고 관리해야합니다.

<br>


## 도메인

릴레이션에 포함된 속성들이 가질 수 있는 값의 집합을 의미합니다. 

**[예시]**

회원이라는 엔티티에 포함된 성별이라는 속성에는 남, 여 2가지의 도메인이 포함됩니다. 


<br>

## 필드와 레코드

- **필드**: **속성**
- **레코드**: 테이블에 쌓이는 **행의 단위 데이터**

<img width="482" height="248" alt="Image" src="https://github.com/user-attachments/assets/8c46462b-ae73-4f69-8844-76a907b7ba39" />

<br>

### 필드 타입 

각 필드는 타입을 가집니다. ➡️ 타입은 MySQL을 기준으로 설명됩니다. 

<br>

#### 숫자 타입

- **TINYINT**
- **SMALLINT**
- **MEDIUMINT**
- **INT**
- **BIGINT**

<img width="696" height="234" alt="Image" src="https://github.com/user-attachments/assets/b692d516-2ab3-42cc-a889-4185f7bef361" />

<br>

#### 날짜 타입

- **DATE**: 날짜만 존재하고 시간은 없는 상태 (3바이트) **ex>** 2002-01-01 
- **DATETIME**: 시간까지 포함하는 상태 (8바이트) **ex>** 2002-01-01 11:59:59
- **TIMESTAMP**: 날짜 및 시간 모두 포함 (4바이트) **ex>** 2002-01-01 11:59:59

💡 **DATETIME과 TIMESTAMP 차이점**

| 특징         | DATETIME                                     | TIMESTAMP                                        |
| :----------- | :------------------------------------------- | :----------------------------------------------- |
| **시간대 처리** | 시간대 정보를 고려하지 않고 저장           | UTC로 변환하여 저장/조회 시 세션 시간대로 변환 |
| **저장 값**  | 입력된 그대로의 날짜 및 시간                 | UTC 기준의 날짜 및 시간                        |
| **바이트 수** | 8 바이트                                     | 4 바이트                                         |
| **저장 범위** | 1000년 ~ 9999년 (매우 넓음)                  | 1970년 ~ 2038년 (2038년 문제)                    |
| **주요 용도** | 특정 지역의 고정된 로컬 시간 기록            | 전역적으로 통일된 시점 관리, 자동 업데이트 시각 |
| **자동 업데이트** | 수동 설정 필요                               | `ON UPDATE CURRENT_TIMESTAMP` 등으로 자동화 용이 |

<br>

#### 문자 타입

- **CHAR**
- **VARCHAR**
- **TEXT**
- **BLOB**
- **ENUM**
- **SET**

💡 **CHAR와 VARCHAR**

두 타입 모두 안에 수를 입력하여 몇자까지 입력할지 정해야합니다. 

**[CHAR 예시]** - 고정적인 데이터에 유리 

- CHAR(30) ➡️ 30자까지 입력가능

- 고정 길이 문자열로 0 ~ 255 사이의 값을 가집니다.
- 레코드 저장 시 **무조건 선언한 길이 값으로 고정**됩니다.
  
**[VARCHAR 예시]** - 유동적 길이의 데이터에 유리

- 가변 길이 문자열로 0 ~ 65,535 사이의 값을 가집니다. 
- 입력된 데이터에 따라 용량을 가변시켜 저장합니다. 

<br>

💡 **TEXT와 BLOB**

두 타입 모두 큰 데이터를 저장할 때 사용합니다. 

| 특징          | TEXT                  | BLOB         |
|:------------|:----------------------|:-------------|
| **주요 용도**   | 큰 문자열 저장              | 이미지, 동영상 저장  |

⚠️ **이미지 저장**

이미지의 경우 보통 S3에 올린 후 해당 경로를 VARCHAR로 저장합니다. 

<br>

💡 **ENUM와 SET**

문자열을 열거한 타입입니다. 

**ENUM**

- ENUM 리스트 중 1개의 값만 선택 가능
- 최대 65,535개의 요소들을 넣을 수 있습니다. 
- ENUM 리스트에 존재하지 않는 값을 삽입할 경우 **빈 문자열이 대신 삽입**됩니다. 

**SET**

- 여러개의 데이터 선택 가능 
- 최대 64개의 요소를 넣을 수 있습니다. 


둘 모두 **공간적인 이점**을 볼 수 있지만 애플리케이션 수정에 따라 **DB의 ENUM이나 SET에서 정의한 목록을 수정**해야합니다. 

<br>

## 관계

- **1:1**
- **1:N**
- **M:N**

관계가 존재하며 M:N의 경우에는 **중간 테이블**을 두어 설계해야합니다. 

<br>

## 키

테이블 간의 관계를 좀 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치입니다. 

- 기본키
- 외래키
- 후보키
- 슈퍼키
- 대체키

가 존재합니다.

### 키 간의 관계 

<img width="1097" height="526" alt="Image" src="https://github.com/user-attachments/assets/c4cd626c-67fa-4af9-8861-a73612188086" />

💡 **최소성이란**

키를 만들 때 지켜야 할 **'효율성'** 또는 **'간결성'** 규칙입니다. 키의 불필요한 복잡성을 제거하는 목적

**[예시]**

주문번호와 메뉴이름을 조합한 (주문번호, 메뉴이름)이 키라고 가정해

그런데 <ins>**메뉴이름을 빼고 주문번호만으로도 유일하게 식별할 수 있다면**,

➡️ (주문번호, 메뉴이름)은 **최소성을 만족하지 않는 키가 됩니다.** (메뉴이름이 불필요하게 포함되었기 때문)

<br>

### 기본키 (Primary Key)

유일성과 최소성을 만족하는 키입니다. 


#### 자연키 

주민등록번호와 같은 자연적으로 중복이 없는 키입니다. 


#### 인조키

인위적으로 생성한 키입니다. (보통 기본키는 인조키로 설정합니다.)

<br>

### 외래키 (Foreign Key)

- 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용합니다. 

- 중복이 가능합니다. 

<br>

### 후보키 (candidate Key)

기본키가 될 수 있는 후보들이며 유일성과 최소성을 만족하는 키입니다. 

<br>

### 대체키 (alternate Key)

후보키가 2개 이상일 경우 어느 하나를 기본키로 지정하고 **남은 후보키들**



<br>

### 슈퍼키 (super Key)

각 레코드를 유일하게 식별할 수 있는 유일성을 가진 키 

