# Chapter4.7 조인의 원리

<br>

# 📚 목차

> **[1. 중첩 루프 조인](#중첩-루프-조인-nlj-nested-loop-join)**
>
> **[2. 정렬 병합 조인](#정렬-병합-조인)**
>
> **[3. 해시 조인](#해시-조인)**

<br>

## 중첩 루프 조인 (NLJ, Nested Loop Join)

for문과 같은 원리로 조건에 맞는 조인을 하는 방법

> ⚠️ **랜덤 접근에 대한 비용이 많이 증가하여 대용량 테이블에서는 사용 ❌**

**[예시]**

- t1, t2 테이블을 조인
- `1번째 테이블`에서 행을 하나씩 읽고 `2번째 테이블`에서도 행을 하나씩 읽어 **조건에 맞는 레코드를 찾아 결과값을 반환**한다.

```sql
for each row in matching reference key {
    for each row in matching reference key {
        if row satisfies join conditions, send to client
    }
}
```

>  💡 **블록 중접 루프 조인(BNL, Block Nested Loop)**
> 
> 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 방식

<br>

## 정렬 병합 조인

➡️ 각각의 테이블을 조인할 필드 기준으로 정렬

➡️ 정렬 이후 조인 작업 수행 

> 💡 조인할 때 쓸 <ins>인덱스가 없거나</ins> 대용량 테이블들을 조인하고 <ins>조인 조건으로 <, > 등 범위 비교 연산자가 있을 때 사용</ins>한다. 


<br>

## 해시 조인

해시 테이블을 기반으로 조인하는 방법 (조건: 동등 조인에서만 사용 가능)

> 💡 2개의 테이블을 조인할 때 **하나의 테이블이 메모리에 온전히 들어간다면 중첩 루프보다 더 효율적**이다.


> **⚠️ 크기가 클수록 디스크 사용 비용이 발생된다.** 


<br>

### MySQL8.0.18 해시 조인 단계 

#### 빌드 단계

- `입력 테이블 중 하나를 기반`으로 메모리 내 해시 테이블을 빌드 

    ➡️ persons, countries 중 **바이트가 더 적은 테이블을 기반으로 빌드**


- 조인에 사용되는 필드가 해시의 키가 된다. (countries_id)




<br>

#### 프로브 단계

레코드 읽기를 시작하며, 각 레코드에서 person.countries_id와 일치하는 레코드를 찾아 결과 값으로 반환

 ➡️ 이를 통해 각 테이블은 한번씩만 읽게되어 중첩보다 성능이 더 좋다.
 
> 💡 메모리양은 시스템 변수 `join_buffer_size`에 **의해 제어**된다. (런타임 시에 조절 가능)