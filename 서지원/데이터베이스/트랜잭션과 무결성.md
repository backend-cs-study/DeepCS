# Chapter4.3 트랜잭션과 무결성

<br>

# 📚 목차

> **[1. 트랜잭션](#트랜잭션)**
>
> **[2. 무결성](#무결성)**
>

<br>

## 트랜잭션

데이터베이스에서 **하나의 논리적 기능을 수행하기 위한 작업의 단위**이며, 여러 개의 쿼리들을 하나로 묶는 단위를 말한다. 

> 💡 **쿼리를 통해 데이터베이스에 접근한다.** 


**[특징]**

- 원자성 A
- 일관성 C 
- 독립성 I
- 지속성 D

<br>

### 원자성(atomicity) A

트랜잭션과 관련된 일이 <ins>모두 수행</ins>되거나 <ins>수행되지 않는 것</ins>을 **보장**하는 특징

➡️ 트랜잭션을 커밋했는데, `문제가 발생`하여 **롤백하는 경우** <ins>그 이후에 모두 수행되지 않음을 보장하는 것

> ⚠️ **트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안된다.** 

<br>

#### 커밋과 롤백

- 커밋(commit)

    - 쿼리가 `성공적으로 처리`되었다고 확정하는 명령어
    - 변경된 내용이 모두 영구적으로 저장되는 것


- 롤백(rollback)

    - 트랜잭션이 **처리한 하나의 묶음 과정**을 `일어나기 전`으로 돌리는 일을 말한다. 

---

➡️ 커밋과 롤백을 통해 **데이터 무결성을 보장**하고 데이터 변경 전에 **변경 사항을 쉽게 확인**할 수 있고 해당 **작업을 그룹화**할 수 있다. 


<br>

#### 트랜잭션 전파 

여러 트랜잭션 관련 **메서드의 호출을 하나의 트랜잭션에 묶이도록** 하는 것

> **💡 Spring 프레임워크에서는 @Transactional을 사용하여 관리한다.** 

<br>

### 일관성(consistency) C 

데이터베이스에 기록된 데이터는 여러개의 조건, 규칙에 따라 유효함을 가져야 한다. 

➡️ 계좌에 100만원이 있는데 500만원을 출금하는 것은 불가능하다. 


<br>

### 격리성(isolation) I

트랜잭션 수행 시 서로 끼어들지 못하는 것 

> ⚠️ 모든 트랜잭션을 순차적으로 처리할 경우 성능면에서 떨어질 수 있다. 

**[격리 수준]**

![Image](https://github.com/user-attachments/assets/f2c2e457-36dc-410a-956e-b69df99857ad)

#### SERIALIZABLE 

트랜잭션을 순차적으로 진행시키는 것 

> ⚠️ **SERIALIZABLE의 경우 데이터 무결성을 확보하지만 <ins>하나의 요청만 허용하기 떄문에 전체적인 성능을 저하</ins>시킬 수 있고 `교착 상태`가 일어날 확률이 많다.**

<br>

#### REPEATABLE READ

하나의 트랜잭션이 **수정한 행을 다른 트랜잭션이 수정할 수 없도록** 막아준다.

⚠️ 새로운 행 추가는 가능 

<br>

#### READ COMMITTED

가장 많이 사용되는 격리 수준으로, **커밋이 완료된 데이터에 대해서만 조회를 허용**한다. 

➡️ PostgreSQL, SQL Server, 오라클에서 기본값으로 설정 

> 💡 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수 있다. 


<br>

#### READ UNCOMMITTED

가장 낮은 격리 수준으로, 거대한 양의 데이터를 어림잡아 집계하는 데에 사용하기 좋다. 

<br>

**[격리 수준에 따라 발생하는 현상]**

#### 팬텀 리드 (REPEATABLE READ, READ COMMITTED, READ UNCOMMITTED)

한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 **조회 결과가 다른 경우**

**[예시]**

- 사용자가 "100원 이상 주문 수"를 조회 ➡️ 2건 


- 그 사이 다른 사용자가 300원짜리 주문을 추가


- 같은 쿼리를 다시 조회 요청 ➡️ 3건 

<br>

#### 반복 가능하지 않은 조회 (READ COMMITTED, READ UNCOMMITTED)

한 트랜잭션 내의 `같은 행`에 **2번이상 조회가 발생했는데 그 값이 다른 경우**

**[예시]**

- 사용자가 한 상품의 가격을 조회 ➡️ 100원


- 관리자가 그 상품 가격을 150원으로 변경


- 다시 조회 ➡️ 150원


<br>

#### 더티 리드 (READ UNCOMMITTED)

한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 `커밋되지 않은 행`의 **데이터를 읽을 수 있을 때 발생**

**[예시]**

- 사용자가 한 상품의 가격을 조회 ➡️ 100원


- 관리자가 그 상품 가격을 150원으로 변경 (아직 커밋 ❌)


- 동시에 사용자가 다시 가격을 조회 ➡️ 150원 (커밋되지 않은 값)


- 이후 관리자가 롤백하여 가격을 다시 100원으로 되돌림


- 사용자는 실제로 존재하지 않는 가격(150원) 을 보고 행동했


<br>


#### 3가지 현상 비교 

| 구분 | **더티 리드 (Dirty Read)**              | **반복 불가능한 조회 (Non-repeatable Read)** | **팬텀 리드 (Phantom Read)**             |
| -- | ------------------------------- | -------------------------------- | -------------------------------- |
| 대상 | **커밋되지 않은 행(Row)의 값**           | **같은 행(Row)**                    | **새로운 행(Row)**                   |
| 원인 | 누군가 데이터를 **변경했지만 아직 커밋하지 않음**   | 누군가 기존 행을 **수정하거나 삭제**함          | 누군가 **새로운 행을 추가**함               |
| 예시 | 커밋되지 않은 가격 150원을 조회했는데, 나중에 롤백됨 | 같은 행을 두 번 조회했더니 값이 달라짐           | 같은 조건으로 두 번 조회했더니 **더 많은 행이 나옴** |


<br>

### 지속성(durability) D

`성공적으로 수행`된 트랜잭션은 **영원히 반영**되어야 한다. 


 ➡️ 데이터베이스에 장애가 발생해도 원래 상태로 복구하는 회복 가능이 있어야 함을 의미한다. 

**[예시]**

- 사용자가 계좌에 10,000원을 이체하는 트랜잭션을 커밋


- 커밋 직후에 시스템이 갑자기 정전으로 다운

➡️ **시스템이 다시 살아났을 때 변경된 잔액이 그대로 유지되어야 한다**

<br>

> 💡 **체크섬**
> 
> ➡️ 중복 검사의 한 형태로, **오류 정정을 통해 송신된 자료의 무결성을 보호**하는 단순한 방법


> 💡 **저널링**
>
> ➡️ 파일 시스템 또는 데이터베이스 시스템에 **변경 사항을 반영하기 전에 로깅**하는 것, 


<br>


## 무결성

데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 

➡️ 무결성이 유지되어야 데이터베이스에 **저장된 데이터 값**과 **실제 값**이 일치하는지에 대한 신뢰가 생긴다. 

[무결성 종류]


| 이름         | 설명                                                           |
|------------|--------------------------------------------------------------|
| **개체 무결성** | `기본키`로 선택된 필드는 **빈 값을 허용하지 않는다.**                            |
| **참조 무결성** | `참조 관계`에 있는 **2 테이블의 데이터는 항상 일관된 값을 유지**해야한다.                |
| **고유 무결성** | **특정 속성에 대해 고유한 값을 가지도록 조건이 주어지는 경우** 그 속성 값은 모두 고유한 값을 가진다. | 
| **NULL 무결성**   | **NULL이 올 수 없다는 조건이 주어지는 경우** 그 속성 값을 모두 NULL이 될 수 없다.           |