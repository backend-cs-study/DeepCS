# Chapter1 프로그래밍 패러다임

<br>

# 📚 목차

> **[1. 선언형과 함수형 프로그래밍](#선언형과-함수형-프로그래밍)**
>
> **[2. 객체지향 프로그래밍](#객체지향-프로그래밍)**
>
> **[3. 절차형 프로그래밍](#절차형-프로그래밍)**
>
> **[4. 패러다임의 혼합](#패러다임의-혼합)**

<br>

> **💡 프로그래밍 패러다임**
> 
> 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 **개발 방법론**이다. 
> 
> 
> ➡️ 패러다임을 지원하는 언어로는 C++, 파이썬, 자바스크립트, 자바(jdk 1.8 이상)가 있다.
> 
> 프로그래밍 패러다임은 크게 선언형(하위:함수형), 명령형(하위:객체지향, 절차지향)으로 나눈다. 
> 
> ![Image](https://github.com/user-attachments/assets/c20f5e08-d4dc-4a74-af62-72f3381a98ad)

<br>

## 선언형과 함수형 프로그래밍

"무엇을" 풀어내는가에 집중하는 패러다임이며, "프로그램은 함수로 이루어진 것이다."라는 명제가 담겨있는 패러다임이다. 

```javascript
const list = [1,2,3,4,5,6]
const ret = list.reduce((max, min) => num > max ? num : max, 0) //6
```

`reduce()` 배열 누적한 결과 값을 반환하는 `순수 함수`이다. 

➡️ 함수형 프로그래밍은 이와 같은 **순수 함수들을 블록처럼 쌓아 로직을 구현**하고 `고차 함수`를 통해 <ins>재사용성을 높인 프로그래밍 패러다임</ins>이다. 

> 💡 자바스트립트는 함수가 일급 객체이기 때문에 함수형 프로그래밍에 적합하다. 

<br>

### 순수 함수 

출력이 입력에만 의존하는 것 

```javascript
const pure = (a,b) => {
    return a + b
}
```

a,b가 아닌 전역변수 c가 출력에 영향을 주면 순수 함수가 ❌


<br>

### 고차 함수

함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 말한다. 

[고차 함수를 쓰기 위한 일급 객체 특징]

- 변수나 메서드에 함수를 할당할 수 있다. 
- 함수 안에 함수를 매개변수로 담을 수 있다. 
- 함수가 함수를 반환할 수 있다. 

<br>

## 객체지향 프로그래밍

OOP(Object-Oriented Programmin)은 **객체들의 집합**으로 프로그램의 상호작용을 표현하며, 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식 

> ⚠️ **설계에 많은 시간이 소요**되며 `처리 속도`가 다른 프로그래밍 패러다임에 비해 **상대적으로 느리다.** 

<br>

### 객체지향 프로그래밍의 특징 

#### 추상화
핵심 개념 또는 기능을 간추려 내는 것 ➡️ 명세서

<br>

#### 캡슐화

객체의 속성과 메서드를 하나로 묶고 일부 정보를 외부에 감추러 은닉하는 것 

<br>

#### 상속성

상위 클래스의 특성을 하위 클래스가 이어 받아 재사용하거나 확장하는 것

- 코드의 재사용
- 유지 보수성
- 계층적인 관계 생성

<br>

#### 다형성

하나의 메서드나 클래스가 다양한 방법으로 동작하는 것 

- 오버로딩: 같은 이름을 가진 **메서드를 여러개** 두는 것  ➡️ 정적 다형성
- 오버라이딩: 상위 클래스로부터 <ins>상속받은 메서드</ins>를 **하위 클래스가 재정의하는 것** ➡️ 동적 다형성

<br>

### 설계 원칙 

객체지향 프로그래밍을 설계할 때는 SOLID 원칙을 지켜주어야 한다. 

<br>

#### 단일 책임 원칙(SRP, Single Responsibility Principle)

모든 클래스는 각각 하나의 책임만 가져야 한다. 

<br>

#### 개방 폐쇄 원칙(OCP, Open Closed Principle)

유지 보수 사항이 생길 때 **코드를 쉽게 확장할 수 있도록**하고 수정할 때는 닫혀있어야 한다. 

➡️ **수정은 적게 확장은 쉽게**

<br>

#### 리스코프 치환 원칙(LSP, Liskov Substitution Priciple)

객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것 

<br>

#### 인터페이스 분리 원칙(ISP, Interface Segregation Principle)

하나의 일반적인 인터페이스를 만들기 보다 여러 개의 구체적인 인터페이스를 만들어야 하는 것

<br>

#### 의존 역전 원칙(DIP, Dependency Inversion Principle)

상위 계층(인터페이스, 부모 클래스)은 하위 계층의 변화에 영향을 받지 않도록 해야하는 것 

➡️ 구체적인 것에 의존하지 말고 **추상화에 의존**

<br>

## 절차형 프로그래밍

로직이 수행되어야 할 **연속적인 계산 과정으로 이루어짐** (순차적으로 로직을 구현하면 됨)

➡️ 가독성이 좋고 실행속도가 빠름 (ex> 많은 연산작업에 사용, 머신 러닝의 배치 작업) 

> ⚠️ 모듈화하기 어렵고 유지 보수성이 떨어짐

<br>

## 패러다임의 혼합

비즈니스 로직이나 서비스의 특징을 고려하여 패러다임을 정하는 것이 좋다. 