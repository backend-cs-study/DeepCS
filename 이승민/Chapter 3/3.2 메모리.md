## 메모리

### 3.2.1 메모리 계층
메모리 계층은 레지스터, 캐시, 미모리, 저장장치로 구성
- 레지스터 : CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억용량 작음
- 캐시 : L1, L2 캐시를 지칭, 휘발성, 속도 빠름, 기억용량 적음
- 주기억장치 : RAM을 지칭, 휘발성, 속도 보통, 기억용량 보통
- 보조기억장치 : HDD, SSD를 지칭, 비휘발성, 속도 낮음, 기억 용량 많음

캐시
- 데이터를 미리 복사해 놓는 임시 저장소
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상 감소 >>> 데이터 접근 시간 감소, 계산 시간 절약

캐싱 계층
- 메모리와 CPU사이의 속도차이가 크기에 중간에 레지스터 계층에서 속도차이 해결
- 이 속도차이를 해결하는 계층이 캐싱 계층

> 지역석의 원리
> - 캐싱 계층을 두는 것 말고 캐시를 직접 설정할 때는? >>> 데이터 기반
>   - 데이터의 근거 : 지역성 [ 시간 지역성, 공간 지역성 ]

- 시간 지역성
  - 최근 사용한 데이터에 다시 접근하려는 특성

- 공간 지역성
  - 최근 접근한 데이터를 이루고 있는 공간 이나 그 가까운 공간에 접근하는 특성

> 캐시 히트와 캐시 미스
> - 캐시 히트 : 캐시에서 원하는 캐시를 찾은 경우
> - 캐시 미스 : 해당 캐시가 없어 주 메모리에 가서 데이터를 찾아오는 경우

- 캐시 매핑 : 캐시가 히트 되기 위해 매핑하는 방법
  1) 직접 매핑 : 1:1~10 의 방식으로 매핑 [처리가 빠르지만 충돌 잦음]
  2) 연관 매핑 : 순서를 일지시키지 않고 관련 캐시와 메모리를 매핑 [충돌이 적지만 모든 블럭을 탐색해 느림]
  3) 집합 연관 매핑 : 순서를 일치시키지만 집합을 둬서 저장, 블럭화되어 있어 검색에 효율적

- 웹 브라우저의 캐시
  - 웹 브라우저의 작은 저장소 쿠키, 로컬 스토리지, 세션 스토리지
    - 쿠키 
      - 만료기한 있는 키-값 저장소 
      - document.cookie를 통해 쿠키를 볼 수 없게 httponly 옵션을 걸어야함
      - 클라 또는 서버에 만료기한 설정
    - 로컬 스토리지
      - 만료기한 없는 키-값 저장소
      - 5MB까지 저장가능[브라우저 닫아도 유지]
      - HTML5를 지원하지 않는 웹 브라우저에선 사용 불가, 클라만 수정 가능
    - 세션 스토리지
      - 만료기한 없는 키-값 저장소
      - 탭 단위로 세션 스토리지 생성, 탑 닫을 때 해당 데이터 삭제
      - HTML5 미지원 브라우저에서 사용불가, 클라만 수정가능
- 데이터 베이스의 캐싱 계층
  - 메인 데이터베이스 위에 레디스를 캐싱 계층으로 둬서 성능 향상

<br>

### 3.2.2 메모리 관리
운영체제의 대표적인 할 일 중 하나가 메모리 관리 [한정된 메모리를 극한으로 활용해야함]

- 가상 메모리
  - 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용자들에게 매우 큰 메모리로 보이게 만드는 것 
  - 가상주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 '페이지 테이블'로 관리
  - 속도 향상을 위해 TLB를 사용
> TLB
> - 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
> - 페이지 테이블에 있는 리스트를 보관하여 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상 시키는 캐시 계층

- 스와핑
  - 가상 메모리에는 존재하지만 RAM에는 현제 없는 데이터나 코드가 접근할 경우 페이지 폴트 발생
  - 메모리에서 당장 사용하지 않는 영역을 HDD에 옮기고 HDD일부를 메모리처럼 불러와 쓰는 것
  - 이를 통해 페이지 폴트가 발생 하지 않은 것처럼 만듦

> 페이지 폴트
> - 프로세스 주소 공간에는 존재하지만 RAM에는 없는 데이터에 접근할 때 발생
>   1) 명령어가 유요한 가상주소에 접근 했으나 페이지가 없으면 트랩이 발생되어 운영체제에 알림
>   2) 운영체제는 실제 디스크로부터 사용하지 않는 프레임을 찾음
>   3) 해당 프레임을 실제 메모리에 가져와 페이지 교체 알고리즘을 기반으로 특정 페이티와 교체 [스와핑 발생]
>   4) 페이지 테이블을 갱신 후 해당 명령어 다시 시작
> 
> **페이지**
> - 가상 메모리를 사용하는 최소 크키 단위
> 
> **프레임**
> - 실제 메모리를 사용하는 최소 크기 단위

- 스레싱
  - 메모리의 페이지 폴트율이 높은 것 >>> 컴퓨터의 심각한 성능 저하를 초래
  - 페이지 폴트 발생 >> CPU 이용율 하락 >> 가용성을 위해 많은 프로세스를 메모리에 올림 >> 반복되어 스레싱 발생
  - 해결 방법 : 메모리 업글, HDD를 SSD로 변경 / 작업 세트 및 PFF

> 작업 세트
> - 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이즈 집할을 만들어 미리 메모리에 로드
> - 미리 메모리에 올려 탐색에 드는 비용을 줄이고 스와핑을 줄임
> 
> PFF
> - 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법
> - 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄임

- 메모리 할당
  - 메모리에 프로그램을 할당할 떄 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당
  - 연속 할당과 불연속 할당으로 나뉨

- 연속 할당
  - 메모리에 '연속적으로' 공간을 할당하는 것
  - 메모리를 미리 나누어 관리하는 '고정 분할 방식' / 매 시점 프로그램의 크기에 맞게 분할 하는 '가변 분할 방식' 존재

**고정 분할 방식**
- 메모리를 미리 나누어 관리
- 미리 나눠져 있기에 융통성 없음
- 내부 단편화 발생

**가변 분할 방식**
- 매 시점 브로그램의 크기에 맞춰 동적으로 활용
- 내부 단편화 발생 X
- 외부 단편화 발생 가능 
  1) 최초적합 : 위쪽이나 아랫쪽부터 시작해 홀을 찾으면 바로 할당
  2) 최적적합 : 프로세스의 크기 이산인 공간 중 가장 작은 홀부터 할당
  3) 최악접합 : 프로세스의 크기와 가장 많이 차이나는 홀에 할당

> 내부 단편화
> - 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
> 
> 외부 단편화
> - 메모리를 나눈 크기보다 프로그램이 커서 못들어가는 공간이 많을 때 발생하는 현상
> 
> 홀
> - 할당할 수 있는 비어있는 메모리 공간

- 불연속 할당
  - 프로그램마다 페이지 테이블을 두어 이를 통해 메모리 프로그램 할당
    1) 페이징
       - 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
       - 홀의 크기가 균일하지 않은 문제를 지우지만 주소 변환이 복잡해짐
    2) 세그멘테이션
       - 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식
       - 공유와 보안 측면에선 장점을 가지지만 홀 크기가 균일하지 않으
    3) 페이지드 세그멘테이션
       - 의미 단위인 세그먼트로 나눠 공유나 보안 측면의 장점을 두고 임의의 길이가 아닌 동일 크기의 페이지로 나눔
- 페이지 교체 알고리즘
  - 스와핑이 많이 발생하지 않게 설계를 하며 이는 페이지 교체 알고리즘 기반으로 발생
    1) 오프라인 알고리즘
       - 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
       - 사용할 수 없는 알고리즘이나 가장 좋은 알고리즘이로 다른 알고리즘과 비교에 상한 기준을 제공
    2) FIFO
       - 가장 먼저온 페이지를 교체영역에 가장 먼저 놓는 방법
    3) LRU
       - 참조가 가장 오래된 페이지를 바꿈
       - '오래된'것을 찾기 파악하기 위해 페이지마다 계수기, 스택을 쌓아둠
    4) NUR
       - LRU에서 발전한 알고리즘 [clock 알고리즘이라고도 함]
       - 0과1을 가진 비트를 두고 시계방향으로 돌면서 0을 찾고 찾은 순간 1로 바꿈
    5) LFU
       - 가장 참조 횟수가 적은 페이지를 교체하는 방법