## ✅ 1. HTTP 관련 면접 예상 질문 & 답안

### 🔸 Q1. HTTP/1.0과 HTTP/1.1의 차이점은 무엇인가요?
A.
HTTP/1.0은 한 번의 요청에 하나의 TCP 연결만 사용했기 때문에 요청마다 3-way-handshake가 발생해 지연이 큽니다.
반면 HTTP/1.1은 Keep-Alive를 통해 연결을 재사용할 수 있어, 여러 요청을 하나의 연결로 처리합니다.
하지만 여전히 순차 처리 방식이라 다수 리소스 요청 시 HOL Blocking과 같은 성능 저하가 발생할 수 있습니다.

### 🔸 Q2. HOL Blocking이란 무엇인가요?
A.
Head-of-Line Blocking은 큐에 있는 첫 번째 요청이 지연되면, 뒤의 요청들도 함께 지연되는 현상입니다.
HTTP/1.1에서는 순차적으로 요청을 처리하기 때문에 이 문제가 발생하고, HTTP/2부터는 멀티플렉싱으로 해결됩니다.

### 🔸 Q3. HTTP/2의 핵심 개선점은 무엇인가요?
A.
HTTP/2는 다음과 같은 점에서 개선되었습니다:

멀티플렉싱: 하나의 TCP 연결에서 여러 요청/응답을 동시에 처리

헤더 압축(HPACK): 중복된 헤더를 허프만 코딩 방식으로 압축

서버 푸시: 클라이언트 요청 없이도 서버가 리소스를 푸시

이를 통해 성능이 크게 향상됩니다.

### 🔸 Q4. HTTP/2는 왜 HTTPS 위에서 동작하나요?
A.
HTTP/2는 설계상 보안 강화를 목표로 하며, 대부분의 브라우저가 HTTPS 환경에서만 HTTP/2를 허용합니다.
따라서 SSL/TLS를 통해 암호화된 통신 위에서 HTTP/2 프로토콜이 동작하게 됩니다.

### 🔸 Q5. TLS에서 핸드셰이크 과정이란 무엇인가요?
A.
TLS 핸드셰이크는 클라이언트와 서버가 보안 세션을 생성하기 위한 키 교환, 인증 등을 수행하는 과정입니다.
이 과정에서 **인증서(CA 기반)**를 통해 서버의 신뢰성을 검증하고, 디피-헬만 기반 알고리즘으로 암호화 키를 교환합니다.

### 🔸 Q6. HTTP/3은 왜 TCP 대신 UDP를 사용하나요?
A.
HTTP/3은 QUIC 프로토콜 위에서 동작하며 UDP를 사용합니다.
TCP의 3-way-handshake를 거치지 않아 초기 지연이 적고, 멀티플렉싱 중 하나의 패킷 손실이 전체에 영향을 주는 문제도 없습니다.
따라서 모바일 환경이나 WiFi 환경에서 더 좋은 성능을 기대할 수 있습니다.

### 🔸 Q7. Base64 인코딩을 이미지에 사용하는 이유는?
A.
Base64는 이미지를 문자열로 바꾸어 HTTP 요청을 줄이기 위해 사용됩니다.
하지만 이미지가 커질 경우 인코딩된 문자열 크기도 증가하므로, 작은 아이콘이나 스프라이트 이미지에만 사용하는 것이 일반적입니다.

----------------

## ✅ HTTP 심화 면접 질문 (백엔드 기준)
### 🔸 Q1. HTTP/2의 멀티플렉싱이 TCP 기반인데, 왜 여전히 HOL Blocking이 존재할 수 있을까요?
의도: HTTP/2의 기술적 한계와 네트워크 깊이 이해

팁: HTTP/2는 애플리케이션 레벨에서의 HOL Blocking은 해결했지만, TCP 레벨에서는 여전히 존재

답변 예시:

HTTP/2는 스트림 단위로 멀티플렉싱하여 애플리케이션 레벨에서의 HOL Blocking을 해결했지만, 여전히 TCP 기반이기 때문에 하위 레이어인 TCP에서의 패킷 손실이 모든 스트림에 영향을 줄 수 있습니다. 이는 TCP의 흐름 제어 특성 때문이며, 이를 보완한 것이 바로 UDP 기반의 QUIC입니다.

### 🔸 Q2. TLS Handshake 과정에서 성능 병목이 생긴다면, 어떤 해결책이 있을까요?
의도: 실무 보안 설정 및 성능 최적화 경험 평가

팁: 세션 재사용, HTTP/3, TLS 1.3

답변 예시:

TLS 핸드셰이크는 암호화 통신 수립 시 비용이 큰 과정입니다. 이를 줄이기 위해 TLS 세션 재사용(Session Resumption)을 적용하거나, 핸드셰이크 단계를 줄인 TLS 1.3을 사용하는 방법이 있습니다. 또한 HTTP/3는 TLS over QUIC을 사용해 0-RTT 핸드셰이크를 통해 초기 지연을 줄입니다.

### 🔸 Q3. HTTP/3가 UDP 기반인데도 신뢰성 있는 전송을 보장할 수 있는 이유는?
의도: 전송 계층 수준 이해

팁: QUIC은 애플리케이션 계층에서 신뢰성 구현

답변 예시:

QUIC은 UDP 기반이지만, 애플리케이션 계층에서 재전송, 순서 보장, 흐름 제어 등을 직접 구현함으로써 TCP 수준의 신뢰성을 제공합니다. 또한 스트림 단위로 처리되어, 하나의 패킷 손실이 전체 요청 지연으로 이어지지 않습니다.

### 🔸 Q4. HTTP 요청의 지연이 느려졌을 때 분석 순서는 어떻게 되나요?
의도: 트러블슈팅 능력 평가

팁: DNS → TCP 핸드셰이크 → TLS → TTFB → 응답 바디

답변 예시:

요청 지연 발생 시 일반적으로 다음 순서로 분석합니다:

DNS 조회 지연

TCP 핸드셰이크 및 재시도

TLS 핸드셰이크 지연

서버 처리 시간 (TTFB: Time to First Byte)

응답 전송 지연 (네트워크, 패킷 손실 등)
각 단계별로 로그, APM, Wireshark 등을 활용해 병목을 추적합니다.

### 🔸 Q5. HTTP 헤더 최적화를 통해 성능을 개선하려면 어떤 조치를 할 수 있나요?
의도: 실전 퍼포먼스 최적화 능력

팁: 헤더 크기 축소, 압축, ETag, 캐싱

답변 예시:

불필요한 쿠키 전송 제거, 헤더 압축 적용(HTTP/2 이상), Gzip 압축, ETag 사용, 캐싱 정책 설정을 통해 성능을 개선할 수 있습니다. 특히 대용량 응답의 경우 Content-Encoding을 적용해 네트워크 비용을 줄이는 것도 효과적입니다.

### 🔸 Q6. HTTP/2와 HTTP/3의 서버 설정 시 주요 차이점은 무엇인가요?
의도: 실무 배포 경험 평가

팁: HTTP/3는 UDP 열어야 함, TLS 필수, 클라이언트 호환성

답변 예시:

HTTP/2는 일반적인 TCP 포트(443)에서 동작하지만, HTTP/3는 UDP 포트를 열어야 하고, QUIC 지원이 필요합니다. 또한 모든 브라우저가 HTTP/3를 기본 지원하지 않기 때문에, 클라이언트와 서버 양쪽 설정을 신중히 해야 합니다. HTTP/3는 TLS 1.3 이상을 필요로 합니다.

### 🔸 Q7. 클라이언트와 서버 간의 통신을 캡처해 HTTP의 실제 동작을 어떻게 분석하나요?
의도: 네트워크 패킷 분석 경험 평가

팁: Wireshark, Postman, curl, Chrome Devtools

답변 예시:

보통 Chrome DevTools의 Network 탭이나 Wireshark를 사용하여 패킷 흐름을 분석합니다. DevTools로는 상태 코드, 요청 헤더, 응답 시간 등을 확인할 수 있고, Wireshark로는 DNS, TLS Handshake, TCP/UDP 전송 흐름 등까지 세부적으로 분석할 수 있습니다.

### 🔸 Q8. RESTful API에서 HTTPS는 필수인가요?
의도: 보안 민감도 확인

팁: 개인정보, 인증, OAuth 등 이유 중심으로

답변 예시:

REST API는 민감한 데이터(로그인, 토큰 등)를 주고받기 때문에, HTTPS는 필수입니다. TLS를 사용하지 않으면 중간자 공격(MITM)에 노출되며, 인증정보 탈취나 응답 변조의 위험이 있습니다. 특히 OAuth2, JWT 등은 TLS 환경에서만 안전하게 사용할 수 있습니다.