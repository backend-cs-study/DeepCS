### HTTP

## HTTP/1.0
- 기본적으로 한 연결당 하나의 요청을 처리
- 단점 : RTT 증가
- 해결법 : 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩

> RTT
> - 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간, 패킷의 왕복 시간

<br>

> 이미지 스필리팅
> - 많은 이미지 다운을 하면 과부화가 걸려 이미지가 합처 있는 이미지를 다운 받고 이를 background-image의 position을 이용해 이미지를 표기하는 방법
> 
> 코드 압축
> - 모드를 압축해 개행 문자, 빈칸을 없애 코드의 크기를 최소화 하는 방법
> 
> 이미지 Base64 인코딩
> - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법
> - 서버와의 연결을 열고 이미지에 대해 서버에 HTTP요청을 안해도 됨
> - 변환시 37% 정도 크기가 커짐
> 
> 인코딩
> - 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약을 위해 다른 형태나 형식으로 변환하는 처리 방식

<br>

## 2.5.2 HTTP/1.1
- HTTP/1.0과 달리 매번 TCP 연결을 하지 않고 한번 TCP 초기화를 한 후 kepp-alive 옵션으로 여러 개의 파일을 송수신하는 방식
- 3way-handshake 이후 발생하지 않음
- 문서 안에 포함된 다수의 리소스를 처리하면 요청할 리소스 개수에 비례해 대기 시간이 길어짐

> HOL Blocking
> - 네트워크에서 같은 큐에 있는 패킷이 첫 패킷에 의해 지연될 때 발생하는 성능저하 현상
> 
> 무거운 헤더 구조
> - HTTP/1.1 헤더에는 쿠키등 많은 메타데이터가 들어가 있고 압축되지 않아 무거움

<br>

## 2.5.3 HTTP/2
- HTTP/1.x 보다 지연시간을 줄이고 응답시간이 더 빠르며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜
- 단일 연결을 사용해 병렬로 여러 요청을 받으며 응답을 줄일 수 있음
- HTTP/1.x에서 발생한 HOL Blocking 문제를 해결가능

> 멀티플렉싱
> - 여러 개의 스트림을 사용하여 송수신
> - 특정 스트림의 패킷이 손실되어도 해당 스크림에만 영향을 주고 다른 스트림은 영향을 받지 않음
> 
> 1) 스트림 - 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
> 
> 헤더 압축
> - 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식으로 해결
> 
> 1) 허프만 코딩 - 문자열을 문자 단위로 쪽대 빈도수를 세어 빈도가 높은 정보는 적은 비드 수를 사용해 표현하고 낮은 정보는 비트를 많이 사용해 데이터 표현에 필요한 비트양을 줄이는 원리
> 
> 서버 푸시
> - 클라이 언트 요청없이 서버가 바로 리소스를 푸시 가능

<br>

## 2.5.4 HTTPS
- HTTP/2는 HTTPS 위에서 동작
- 어플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣어 신뢰할 수 있는 HTTP 요청 [통신을 암호화]

> ### SSL/TLS
> - 전송 계층에서 보안을 제공하는 프로토콜
> - 클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제3자가 메세지를 도청하거나 변조하지 못하게 함
> - 네트워크상 인터셉터 방지
> - 보안 세션을 기반으로 데이터를 암호화하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘을 사용
> 
> ### 보안 세션
> - 보안이 시작되고 끝나는 동안 유지되는 세션
> - SSL/TLS는 핸드세이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등을 공유
>   1) 사이퍼 슈트 - 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약
>       - TLS_AES_128_GCM_SHA256
>       - TLS_AES_256_GCM_SHA384
>       - TLS_CHACHA20_POLY1305_SHA256
>       - TLS_AES_128_CCM_SHA256
>       - TLS_AES_128_CCM_8_SHA256
>   2) AEAD 사이퍼 모드 - 데이터 암호화 알고리즘[AES_128_GCM 등이 있음]
>   3) 인증 메커니즘 - CA에서 발급한 인증서를 기반으로 이루어짐[안전한 연결을 시작하는데 공개키를 클라에게 제종하고 신뢰가능한 서버림을 보장]
>      - CA 발급 과정
>        1) 자신의 사이트 정보와 공개키를 CA에 제출
>        2) 공개키를 해시한 값인 지문을 사용하는 CA 비밀키 등을 기반으로 CA 인증서 발급
> 
> ### 암호화 프로토콜
> - 키 교환 암호화 알고리즘으로 대수곡선 기반 ECSHE 또는 모듈식 기반 DHE를 사용 [둘다 디피-헬만 방식을 근간으로 만듦]
>   1) 디피-헬만 키 교환 알고리즘 <br>
>      이미지
>      1) 처음 공개 갮을 공유하고 각자의 비밀 값과 혼합 후 혼합 값을 공유
>      2) 각자의 비밀값과 혼합
> - 클라이언트와 서버 모두 개인키와 공유키를 생성하고 서로에게 공유키를 보내 공유키와 개인키를 결합하여 PSK를 생성해 악의적 공격자가 키를 가지고도 PSK가 없어 공격 불가
> 
> 해시 
> - 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값
> 
> 해싱
> - 임의의 데이터를 해시로 바꿔주는 일이며 해시 함수가 이를 담당
> 
> 해시 함수
> - 임의의 데이터를 입력으로 받아 일정한 길이의 데이터로 바꿔주는 함수

### 2.5.5 HTTP/3
- QUIC라는 계층에서 돌아며 TCP기반이 아닌 UDP기반으로 동작
- HTTP/2에서 장점이였던 멀티플렉싱을 가지고 있으며 초기 연결시 지연감소

> 초기 연결 설정 시 지연 감소
> - TCP를 사용하지 않기에 통신을 시작시 3way-handshake 과정을 거치지 않음
> - 열역한 네트워크 환경에서도 낮은 패킷 손실률