## 4.5.1 인덱스의 필요성
- 인덱스 : 데이터를 빠르게 찾을 수 있는 하나의 장치
- 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있음

## 4.5.2 B-트리
- 인덱스는 보통 B-트리라는 자료 구조로 이루어짐
- 루트 노드, 리프 노드, 그리고 그 사이에 브랜치 노드로 나눠짐

### 인텍스가 효율적인 이유와 대수확장성
- 인덱스가 효율적인 이유는 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리 구조와 트리 깊이의 대수확장성 때문

> 대수확장성이란?
> - 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미
> - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가
> - 다만 실제 인덱스는 이것보다 더 효율적이며 그렇기에 인덱스가 더 효율적이라고 볼 수 있음

## 4.5.2 인덱스 만드는 법

### MySQL
- 클러스트형 인덱스와 세컨더리 인덱스가 있음
  - 클러스트형 인덱스
    - 데이블당 하나를 설정가능
    - primary key 옵션으로 기본키를 만들면 클러스트형 기본키로 만들지 않고 unique noy null로 해도 클러스트형
    - 하나의 인덱스만 생성할꺼면 클러스트형이 성능이 좋음
  - 세컨더리 인덱스
    - 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스
    - 하나의 필드를 만든다면 클러스트형을 사용하지만 여러 필드를 기반으로 쿼리를 보낼 때는 세컨더리를 사용
    
### MongoDB
- 도큐먼트를 만들면 자동으로 objectID가 형성되,며, 해당 키가 기본키로 설정
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정 가능

<br>

## 4.5.3 인덱스 최적화 기법
- 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 같음

### 1. 인덱스는 비용이다
- 인덱스는 두 번 탐색하도록 강요
- 인덱스 리스트, 컬렉션 순으로 탐색하기에 관련 읽기 비용이 듦
- 컬렉션이 수정되면 인덱스도 수정해야함
- 쿼리에 있는 모든 필드에 인덱스를 설정하는 것은 답이 아니며 가져와야하는 양이 많을 수록 인덱스를 활용하는 것은 비효율적

### 2. 향상 데스팅하라
- 최적화 기법은 서비스 특징에 따라 달라짐 [객체의 깊이 데이블의 양 등이 다르기 때문]
- explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 데슽킹을 하여 걸리는 시간을 최소화 해야함

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
- 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 사용
- 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라짐
  1) 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
  2) 정렬에 쓰는 필드라면 그다음 인덱스로 설정
  3) 다중 값을 출력해야하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
  4) 유니크한 값의 정도를 카더널리티라고 함, 이 카더널리티가 높은 순서를 기반으로 인덱스를 생성