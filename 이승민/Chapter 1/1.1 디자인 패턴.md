## 디자인 패턴
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호관계 등을 이용하여 해결할 수 있는 하나의 '규약'형태로 만들어 놓은 것

### 1.1.1 싱글톤 패턴
하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

보통 데이터베이스 연결 모듈에 많이 사용

- **장점** : 인스턴스 생성비용 절감
- **단점** : 의존성 증가
  - TDD(Test Driven Development)에서 걸림돌
  - 주로 단위 테스르를 진행하는데 싱글톤은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴으로 테스트마다 독립적인 인스턴스 생성 어려움

**극복법**
- 의존성 주입
  - 모듈들을 쉽게 교체가 가능하고 관계가 명확해짐
  - 단 클래스 수의 증가로 인해 복잡성이 증가하고 약간의 런타임 패널티 발생

<br>

### 1.1.2 팩토리 패턴
객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화하고 하위 클래스에서 구체적인 내용을 결정하는 패턴

- 상위 하위가 분리되기 때문에 느슨한 결합을 가짐
- 상위에선 인스턴스 생성방식에 전혀 알지 못해 유연성을 가짐
- 객체 생성 로직이 따로 위치해 리팩토링에 유리해 유지보수성 증가

<br>

### 1.1.3 전략 패턴
전략 패턴(strategy pattern)은 정책 패턴(policy pattern)이라고도 칭함

- 객체의 행위를 변경하는 것이 아닌 다른 방식으로 만들어 컨텍스트 안에서 바꿔가며 상호 교체하는 패턴

> ### 컨텍스트
> 프로그래밍에서 상황, 맥략, 문맥을 의미하며 개발자가 어떤 작업을 완료하는데 필요한 모든 정보를 칭함

<br>

### 1.1.4 옵저버 패턴
주체가 어떤 객체의 상태 변화를 관찰하다 상태 변화가 있을 때마다 메소드를 통해 옵저버들에게 변화를 알려주는 패턴

주로 이벤트 기반 시스템에 사용하며 MVC 패턴에도 사용

![image.jpg](../../../../../Downloads/image.jpg)

> ### 자바에서 상속과 구현의 차이
> - **상속**
>   - 상속(extends)는 상위 클래스의 메소드를 상속받아 하위 클래스가 추가 및 확장하여 사용하는 것
>   - 재사용성, 중복성의 최소화
> - **구현**
>   - 구현(implements)는 상위 인터페이스(interface)를 하위 클래스가 재정의하여 구현하는 것
>   - 상속과 달리 상위 클래스의 매소드를 재정의하여 구현해야한다

<br>

### 1.1.5 프록시 패턴 / 프록시 서버
- **프록시 패턴**
  - 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 필터링하거나 수정하는 역활을 하는 계층이 있는 패턴 
  - 주로 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용
- **프록시 서버**
  - 서버와 클라 사이에서 클라가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 시스템이나 프로그램을 칭한다
  

> nginx와 cloudFlare
> - **nginx**
>   - 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리하는 웹 서버
>   - Node.js의 앞단에 두어 익명의 사용자의 직접적인 접근을 차단
> 
> - **cloudFlare**
>   - 전 세계적으로 분산된 서버를 두고 이를 통해 특정 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스 
>   - 웹서버 앞단에 프록시 서버로 두어 DDOS 공격방어나 HTTPS 구축에 사용

<br>

> DDOS 
> - 짧은 시간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시키는 사이버 공격
> - cloudFlare는 의심스런 트래픽, 사용자 접속이 아닌 시스템을 통한 트래픽을 자동으로 차단하여 보호

> CDN
> - 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크로 서버의 성능을 향상시킬 수 있음

<br>

### 1.1.6 이터레이터 패턴
이터레이터를 사용해 컬렉션의 요소들에 접근하는 디자인 패턴
- 자료형의 구조에 상관없이 순회가능

> 이터레이터 프로토콜 / 객체
> - **이터레이터 프로토콜**
>   - 이터러블한 객체를 순회할 때 쓰이는 규칙
> - **이터레이터 객체**
>   - 반복 가능한 객체로 배열을 일반화한 객체

<br>

### 1.1.7 노출모듈 패턴
즉시 실행 함수를 통해 접근제어자를 만드는 패턴

> **public**
> - 클래스의 정의된 함수에서 사용가능 / 자식과 외부 클래스에서 접근 가능
> 
> **protected**
> - 자식은 가능하나 외부 클래스 접근 불가
> 
> **private**
> - 자식과 외부 클래스에선 접근 불가

<br>

### 1.1.8 MVC 패턴
MVC패턴은 모델(model), 뷰(view), 컨트롤러(controller)로 이루어진 패턴

![image - 2.jpg](../../../../../Downloads/image%20-%202.jpg)
> **모델**
> - 어플리케이션의 데이터베이스, 상수, 변수
> 
> **뷰**
> - 인터페이스 요소
> - 모델을 기반으로 사용자가 볼 수 있는 화면
> 
> **컨트롤러**
> - 하나 이상의 모델과 하나 이상의 뷰를 이어주는 다리역할
> - 이벤트등 메인 로직을 담당

<br>

### 1.1.9 MVP 패턴
MVC패턴에서 파상된 것으로 컨트롤러 대신 프레젠터로 변경된 패턴
- 뷰와 프레젠터가 일대일 관계로 MVC보다 강한 결합을 가짐

<br>

### 1.1.10 MVVM 패턴
MVC의 컨트롤러 대신 뷰 모델(view model)로 변경된 패턴
- 뷰 모델을 뷰를 더 추상화한 계층
- MVC와 다르게 커맨드와 데이터 바인딩을 가짐
- 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원해 UI 별도 수정없이 재사용 및 단위 테스트가 쉬움

> **커맨드**
> - 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
> 
> **데이터 바인딩**
> - 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법