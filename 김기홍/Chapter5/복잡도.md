# 📦 자료구조 (Data Structure)

> 자료구조는 데이터를 효율적으로 저장, 관리, 처리하기 위한 구조와 방법입니다.  
> 적절한 자료구조 선택은 프로그램의 성능과 효율성을 크게 향상시킵니다.

---

## 🧮 1. 복잡도 (Complexity)

### 🔢 1.1 빅오 표기법 (Big-O Notation)

- 알고리즘의 효율성을 수학적으로 표현하는 방법
- 입력 크기(n)에 따른 연산 횟수의 상한을 나타냄  
  예시: O(1), O(log n), O(n), O(n log n), O(n²) 등

### ⏱️ 1.2 시간 복잡도 (Time Complexity)

- 알고리즘이 실행되는데 걸리는 시간의 증가율

### 💾 1.3 공간 복잡도 (Space Complexity)

- 알고리즘이 실행되는데 필요한 메모리의 증가율

### 🗂️ 1.4 자료구조별 시간 복잡도 비교

| 자료구조                 | 접근       | 탐색       | 삽입       | 삭제       |
|----------------------|----------|----------|----------|----------|
| 📚 **배열(Array)**     | O(1)     | O(n)     | O(n)     | O(n)     |
| 🔗 **연결리스트**         | O(n)     | O(n)     | O(1)     | O(1)     |
| 🔗 **이중 연결리스트**      | O(n)     | O(n)     | O(1)     | O(1)     |
| 🗂️ **스택(Stack)**    | O(n)     | O(n)     | O(1)     | O(1)     |
| 🗂️ **큐(Queue)**     | O(n)     | O(n)     | O(1)     | O(1)     |
| #️⃣ **해시 테이블**       | -        | O(1)     | O(1)     | O(1)     |
| 🌳 **이진 탐색 트리(BST)** | O(log n) | O(log n) | O(log n) | O(log n) |
| 🌲 **AVL 트리**        | O(log n) | O(log n) | O(log n) | O(log n) |
| 🔴 **레드블랙 트리**       | O(log n) | O(log n) | O(log n) | O(log n) |

> **참고:**
> - 배열은 인덱스를 통한 랜덤 접근이 가능(O(1)), 삽입/삭제는 데이터 이동 필요(O(n))
> - 연결리스트 계열은 삽입/삭제가 빠르지만 탐색이 느림
> - 스택/큐는 한쪽 끝에서만 삽입/삭제(O(1))
> - 해시 테이블은 평균적으로 모든 연산이 O(1), 충돌 시 성능 저하 가능
> - 트리 계열은 균형이 잡혀 있을 때 O(log n) 성능 보장

---

## 📏 2. 선형 자료구조 (Linear Data Structure)

### 📚 배열 (Array)

- **특징:** 고정 크기, 인덱스를 통한 빠른 접근(O(1))
- **활용:** 탐색이 많은 경우
- **단점:** 크기 변경 불가, 삽입/삭제 느림

### 🔗 연결리스트 (Linked List)

- **특징:** 노드들이 포인터로 연결, 동적 크기
- **종류:** 싱글/이중/원형 연결리스트
- **활용:** 삽입/삭제가 많은 경우
- **단점:** 탐색 느림

### 🗂️ 스택 (Stack)

- **특징:** LIFO(Last-In, First-Out), top에서만 삽입/삭제
- **활용:** 함수 호출, 괄호 검사, 웹 브라우저 방문 기록 등

### 🗂️ 큐 (Queue)

- **특징:** FIFO(First-In, First-Out), front/rear에서 삽입/삭제
- **활용:** 작업 예약, BFS, 프린터 대기열 등

### 📦 벡터(Vector, 동적 배열)

- **특징:** 크기 동적 조절, 배열과 유사
- **활용:** 크기를 미리 알 수 없는 배열

---

## 🌳 3. 비선형 자료구조 (Non-linear Data Structure)

### 🌳 트리 (Tree)

- **특징:** 계층적(부모-자식) 구조, 루트/내부/리프 노드
- **활용:** 파일 시스템, 데이터베이스 인덱스 등

#### 🌳 이진 탐색 트리 (BST)

- **특징:** 왼쪽 < 부모 < 오른쪽, 평균 O(log n)
- **단점:** 한쪽으로 치우치면 O(n)

#### 🌲 AVL 트리 / 🔴 레드블랙 트리

- **특징:** 항상 균형 유지, O(log n) 보장

### 🌐 그래프 (Graph)

- **특징:** 정점(Vertex)과 간선(Edge)으로 구성
- **활용:** 네트워크, 소셜 그래프, 경로 탐색 등

---

## #️⃣ 4. 해시 테이블 (Hash Table)

- **특징:** (Key, Value) 쌍 저장, 평균 O(1) 연산
- **활용:** 사전(Dictionary), 캐시, 중복 체크 등

---

## 🔺 5. 힙(Heap)

- **특징:** 완전 이진 트리 기반, 부모-자식 간 우선순위 유지
- **종류:**
    - 최대힙(Max Heap): 루트가 가장 큰 값
    - 최소힙(Min Heap): 루트가 가장 작은 값
- **활용:** 우선순위 큐, 힙 정렬, 최단 경로 알고리즘 등
- **연산:** 삽입/삭제 O(log n), 최대/최소값 조회 O(1)

---

## 🥇 6. 우선순위 큐 (Priority Queue)

- **특징:** 우선순위가 높은 데이터부터 꺼냄
- **구현:** 주로 힙(Heap) 사용
- **활용:** 작업 스케줄링, 다익스트라, 실시간 이벤트 처리

---

## 🗺️ 7. 맵 (Map, 해시맵/딕셔너리)

- **특징:** 키(Key)-값(Value) 쌍 저장, 키 중복 불가
- **구현:** 해시 테이블, 트리 맵 등
- **활용:** 사전, 캐시, 빈도수 세기, 중복 체크

---

## 🗃️ 8. 셋 (Set)

- **특징:** 중복 없는 데이터 집합, 빠른 포함 여부 확인
- **구현:** 해시셋, 트리셋 등
- **활용:** 중복 제거, 집합 연산(합/교/차집합)

---

## 📝 자료구조 선택 가이드

- 🔍 **탐색이 많은 경우:** 배열, 해시 테이블, 트리
- ➕➖ **삽입/삭제가 많은 경우:** 연결 리스트, 트리
- 🥇 **우선순위가 중요한 경우:** 힙(Heap)
- 🔤 **문자열 검색:** 트라이(Trie)
- 📊 **구간 쿼리:** 세그먼트 트리

---

> 자료구조의 시간 복잡도와 특성을 이해하고  
> 문제의 요구사항에 맞는 자료구조를 선택하는 것이 핵심!!
