# 프로그래밍 패러다임
```
┌─────────────┐ 
│ 패러다임    │
├─────────────┤
│ 선언형      │
│  └─ 함수형  │
│ 명령형      │
│  ├─ 객체지향│
│  └─ 절차지향│
└─────────────┘
```
- 프로그래밍 패러다임은 소프트웨어를 설계하고 구현하는 기본적인 사고방식 또는 방법론입니다.

- 대표적으로 선언형과 명령형 두 가지 큰 분류가 있으며, 그 아래에 다양한 하위 패러다임이 존재합니다.
## 1.2.1 선언형과 함수형 프로그래밍
### 🟦 선언형 프로그래밍
절차형 프로그래밍은 명령문의 순서와 제어 흐름을 중시하며, 프로그램을 함수와 절차의 집합으로 구성합니다. 대표적으로 C 언어가 있으며, 상태의 변화와 순차적 실행이 특징입니다.
- **무엇(What)**을 할 것인지에 집중합니다.
- 예시: SQL에서 SELECT name FROM users WHERE age > 20
- → "어떻게"가 아니라 "무엇을" 얻고 싶은지 선언합니다.
### 🟩 함수형 프로그래밍
함수형 프로그래밍은 선언형의 하위 집합으로, 데이터를 수학적 함수의 계산처럼 처리하고 상태와 가변 데이터를 피합니다. 순수 함수, 불변성(immutability), 고차 함수, 1급 함수(first-class function), 함수 조합(composability) 등이 핵심 키워드입니다
```
// JavaScript 예시
const double = x => x * 2; // 순수 함수
[1,2,3].map(double);       // 고차 함수(map)
```
#### 🔹순수 함수
순수 함수(pure function)는 동일한 입력에 대해 항상 동일한 출력을 반환하며, 외부 상태나 부작용(side effect)이 없습니다. 이로 인해 테스트와 예측이 쉬워지고, 프로그램의 신뢰성이 높아집니다
#### 🔹고차 함수
고차 함수(higher-order function)는 함수를 인자로 받거나 반환하는 함수로, 함수의 조합과 추상화, 재사용성을 높여줍니다. 언어가 1급 함수를 지원해야 고차 함수 사용이 가능합니다

## 1.2.2 객체지향 프로그래밍
OOP는 현실 세계의 개체(객체)를 소프트웨어로 모델링하여, 데이터(속성)와 메서드(행동)를 하나의 단위로 묶고, 객체 간 상호작용으로 시스템을 구성합니다. 클래스, 인스턴스, 메시지 전달, 캡슐화, 상속, 다형성, 추상화가 주요 키워드입니다
#### 🟠추상화
추상화(abstraction)는 복잡한 시스템에서 핵심 개념만을 모델링하여, 불필요한 세부사항을 감추고 공통된 속성이나 동작을 정의합니다. 이는 코드의 재사용성과 유지보수성을 높입니다
#### 🟠캡슐화
캡슐화(encapsulation)는 데이터와 메서드를 하나의 클래스로 묶고, 내부 구현을 외부에 감추어 정보 은닉과 보안을 강화합니다. 접근 제어자(private, public 등)를 통해 외부 접근을 제한합니다
#### 🟠상속성
상속성(inheritance)은 기존 클래스(부모)의 특성과 기능을 새로운 클래스(자식)가 물려받아 코드의 재사용성과 확장성을 높입니다. 오버라이딩을 통해 일부 기능을 재정의할 수 있습니다
#### 🟠다형성
다형성(polymorphism)은 동일한 인터페이스로 다양한 객체를 다룰 수 있게 하며, 오버로딩(같은 이름의 메서드를 매개변수로 구분)과 오버라이딩(상위 클래스 메서드를 하위 클래스에서 재정의)으로 구현됩니다

- 오버로딩: 같은 이름의 메서드를 매개변수 타입이나 개수로 구분하여 여러 번 정의

- 오버라이딩: 상위 클래스의 메서드를 하위 클래스에서 재정의하여 다양한 동작을 구현

```
class Animal { void speak() {} }
class Dog extends Animal { void speak() { System.out.println("멍멍"); } }
```
### 🟣 설계 원칙 (SOLID)
#### 단일 책임 원칙 (SRP) : 한 클래스는 한 책임만.
하나의 클래스는 하나의 책임만 가져야 하며, 변경의 이유도 하나여야 합니다.
#### 개방-폐쇄 원칙(OCP) : 확장엔 열려있고, 변경엔 닫혀있어야.
소프트웨어 요소는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 합니다.
#### 리스코프 치환 원칙(LSP) : 부모 타입을 자식 타입으로 바꿔도 문제 없어야.
상위 타입의 객체를 하위 타입의 객체로 대체해도 프로그램의 동작이 유지되어야 합니다.
#### 인터페이스 분리 원칙(ISP) : 큰 인터페이스보다 작은 인터페이스 여러 개.
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫습니다.
#### 의존 역전 원칙(DIP) : 구체가 아닌 추상에 의존.
상위 모듈이 하위 모듈에 의존하지 않고, 추상화에 의존해야 합니다.

## 1.2.3 절차형 프로그래밍

#### 절차형 프로그래밍(Procedural Programming)
절차형 프로그래밍은 명령문의 순서와 제어 흐름을 중시하며, 프로그램을 함수와 절차의 집합으로 구성합니다. 대표적으로 C 언어가 있으며, 상태의 변화와 순차적 실행이 특징입니다.
- 명령문 순서와 제어 흐름을 중시합니다.
- 프로그램을 함수와 절차의 집합으로 구성.
- 대표 언어: C, Pascal 등.
```
  int sum = 0;
  for(int i=1; i<=10; i++) {
  sum += i;
  }
```  
## 정리 및 결론
- 선언형: "무엇을"에 집중, 대표적으로 함수형.
- 명령형: "어떻게"에 집중, 절차형과 객체지향으로 세분화.
- 함수형: 순수함수, 불변성, 고차함수 등으로 예측 가능성 높음.
- 객체지향: 추상화, 캡슐화, 상속, 다형성으로 대규모 시스템에 적합.
- 절차형: 명령문과 흐름 중심, 단순한 구조에 적합.

### 마무리
- 각 패러다임은 문제의 성격, 프로젝트 규모, 팀의 역량에 따라 선택됩니다.
- 현대 소프트웨어는 여러 패러다임이 혼합되어 사용되는 경우가 많습니다.
- 다양한 패러다임을 이해하면 더 좋은 소프트웨어 설계와 구현이 가능합니다.

### QnA
1. 객체지향 프로그래밍(OOP)의 4대 특징을 설명하고, 실제로 어떻게 활용되는지 예를 들어보세요.
- 의도 : 객체지향의 핵심 개념(추상화, 캡슐화, 상속, 다형성)에 대한 이해와 실무 적용 능력을 확인
- 답변 : 객체지향 프로그래밍의 4대 특징은 추상화, 캡슐화, 상속, 다형성입니다.
    - 추상화는 복잡한 시스템에서 핵심적인 속성과 동작만 모델링하는 것입니다. 예를 들어, ‘동물’이라는 클래스를 만들고, 공통된 속성(이름, 나이)과 동작(소리내기)을 정의할 수 있습니다.
    - 캡슐화는 데이터와 메서드를 하나의 클래스로 묶고, 외부에서 접근하지 못하도록 정보를 숨기는 것입니다. 예를 들어, 멤버 변수를 private으로 선언하고, getter/setter를 통해 접근을 제어합니다.
    - 상속은 기존 클래스의 속성과 동작을 새로운 클래스가 물려받아 확장하는 것입니다. 예를 들어, ‘동물’ 클래스를 상속받아 ‘강아지’나 ‘고양이’ 클래스를 만들 수 있습니다.
    - 다형성은 같은 메서드 이름으로 다양한 동작을 수행할 수 있게 하는 것입니다. 예를 들어, ‘speak()’라는 메서드를 각 동물 클래스에서 다르게 구현하면, 같은 메서드 호출로 각 동물의 소리를 낼 수 있습니다.
- 이러한 특징들은 코드의 재사용성과 유지보수성을 높여주며, 실제로 백엔드 개발에서 도메인 모델을 설계할 때 많이 활용합니다.
2. 함수형 프로그래밍의 순수 함수와 고차 함수가 백엔드 개발에서 어떤 장점을 줄 수 있는지 설명해보세요.
- 의도 : 함수형 패러다임의 실제 장점(테스트 용이성, 예측 가능성, 코드 재사용성 등)에 대한 이해도 확인
- 답변 : 함수형 프로그래밍의 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하고, 외부 상태를 변경하지 않습니다. 이런 특성 덕분에 테스트가 쉽고, 코드의 예측 가능성이 높아집니다.
  고차 함수는 함수를 인자로 받거나 반환하는 함수로, 코드의 재사용성과 추상화 수준을 높여줍니다. 예를 들어, Java의 Stream API에서 map, filter와 같은 메서드는 고차 함수로, 데이터를 효율적으로 처리할 수 있게 해줍니다.
  이러한 함수형 프로그래밍의 특징은 백엔드에서 데이터 변환, 컬렉션 처리, 비동기 작업 등 다양한 상황에서 코드의 품질과 유지보수성을 높이는 데 큰 도움이 됩니다.
3. SOLID 원칙 짝찾기 문제

- A. 단일 책임 원칙 (SRP)  A. 한 클래스는 한 책임만.
- B. 개방-폐쇄 원칙(OCP) B. 확장엔 열려있고, 변경엔 닫혀있어야.
- C. 리스코프 치환 원칙(LSP) C. 부모 타입을 자식 타입으로 바꿔도 문제 없어야.
- D. 인터페이스 분리 원칙(ISP) D. 큰 인터페이스보다 작은 인터페이스 여러 개.
- E. 의존 역전 원칙(DIP) E. 구체가 아닌 추상에 의존.
