# CPU 스케줄링 알고리즘

## 비선점형 방식

1. FCFS (First-Come, First-Served, 선입선출)

- 가장 먼저 도착한 프로세스에게 CPU를 할당하는 방식입니다.
- 프로세스가 CPU를 할당받으면 작업이 끝날 때까지 CPU를 점유하며, 다른 프로세스는 대기해야 합니다.
- 구현이 간단하고 오버헤드가 적으나, 긴 작업이 먼저 오면 전체 대기시간이 길어지는 Convoy Effect가 발생할 수 있습니다.
- 배치 처리 시스템에 적합합니다.

2. SJF (Shortest Job First, 최단 작업 우선)

- 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 프로세스에 CPU를 우선 할당합니다.
- 평균 대기시간을 최소화할 수 있는 최적의 비선점형 스케줄링입니다.
- 실행 시간이 긴 프로세스가 계속 대기할 수 있어 기아(starvation) 현상이 나타날 수 있습니다.
- 실행 시간을 미리 예측해야 하므로 실용성에 한계가 있습니다.

3. 우선순위 스케줄링 (Priority Scheduling)

- 각 프로세스에 우선순위를 부여하고, 가장 높은 우선순위의 프로세스에 CPU를 할당합니다.
- 우선순위가 같은 경우에는 FCFS 방식으로 처리합니다.
- 우선순위가 낮은 프로세스가 무한정 대기하는 기아 현상이 발생할 수 있으며, 이를 방지하기 위해 에이징(aging) 기법을 적용하기도 합니다.

## 선점형 방식

1. 라운드 로빈 (Round Robin, RR)

- 각 프로세스에 동일한 시간 할당량(타임 퀀텀, time quantum)을 주고, 할당 시간이 끝나면 CPU를 강제로 반환시켜 다음 프로세스에 할당합니다.
- 모든 프로세스가 공평하게 CPU를 사용할 수 있으나, 타임 퀀텀이 너무 크면 FCFS와 비슷해지고, 너무 짧으면 문맥 교환 오버헤드가 커집니다.
- 대화형 시스템에 적합합니다.

2. SRF (Shortest Remaining Time First, SRTF)

- SJF의 선점형 버전으로, 현재 실행 중인 프로세스보다 남은 실행 시간이 더 짧은 프로세스가 도착하면, 현재 프로세스를 중단하고 새 프로세스에 CPU를 할당합니다.
- 평균 대기시간이 짧아지나, 짧은 작업이 계속 들어오면 긴 작업이 계속 대기하는 기아 현상이 발생할 수 있습니다.

3. 다단계 큐 (Multi-Level Queue, MLQ)

- 프로세스의 특성(예: 시스템, 대화형, 배치 작업 등)에 따라 여러 개의 준비 큐를 두고, 각 큐마다 다른 스케줄링 알고리즘을 적용합니다.
- 보통 우선순위가 높은 큐의 프로세스가 먼저 실행되며, 큐 간 프로세스 이동은 허용하지 않습니다(MLQ).
- 다단계 피드백 큐(MLFQ)는 프로세스가 큐 사이를 이동할 수 있도록 하여, CPU 사용량에 따라 우선순위를 동적으로 조정하고, 오랜 대기 프로세스는 상위 큐로 이동시켜 기아 현상을 방지합니다.

요약 비교

- FCFS: 구현이 단순하고 오버헤드가 적으나, 긴 작업이 먼저 오면 전체 대기시간이 길어질 수 있습니다.
- SJF: 평균 대기시간을 최소화할 수 있으나, 실행 시간 예측이 필요하고 기아 현상이 발생할 수 있습니다.
- 우선순위: 중요 작업을 우선 처리할 수 있으나, 기아 현상이 발생할 수 있습니다.
- 라운드 로빈: 공평성 보장이 가능하며 대화형 시스템에 적합하지만, 오버헤드와 타임 퀀텀 설정이 중요합니다.
- SRF(SRTF): 평균 대기시간이 최소화되나, 기아와 오버헤드가 발생할 수 있습니다.
- 다단계 큐: 다양한 작업 특성을 반영할 수 있으나, 기아와 유연성 부족(MLQ)이 단점입니다.

각 알고리즘은 시스템 목적(공평성, 효율성, 응답성 등)에 따라 선택적으로 사용되며, 실제 운영체제에서는 여러 스케줄링 기법을 조합하여 적용하는 경우가 많습니다.
