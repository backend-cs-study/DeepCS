# 프로세스와 스레드
---

## 프로세스와 컴파일 과정

- 전처리(Preprocessing) : 소스 코드에서 매크로 확장, 헤더 파일 포함, 조건부 컴파일 등 수행.
- 컴파일러(Compiler) : 전처리된 소스 코드를 어셈블리어로 변환.
- 어셈블러(Assembler) : 어셈블리어를 기계어(오브젝트 코드)로 변환.
- 링커(Linker) : 여러 오브젝트 파일과 라이브러리를 하나의 실행 파일로 결합.
    - 정적 라이브러리: 컴파일 시점에 실행 파일에 포함. 실행 파일 크기가 커지지만, 외부 의존성 없음.
    - 동적 라이브러리: 실행 시점에 메모리에 로드. 여러 프로그램이 공유하며, 메모리 효율적.

---

## 프로세스의 상태

- 생성 상태
    - fork(): 부모 프로세스를 복제해 자식 프로세스 생성.
    - exec(): 현재 프로세스의 메모리 이미지를 새로운 프로그램으로 교체.
- 대기 상태: 실행 준비가 되어 있으나, CPU 할당을 기다림.
- 대기 중단 상태: I/O 등 외부 이벤트를 기다리는 상태.
- 실행 상태: CPU를 점유해 명령을 실행 중.
- 중단 상태: 오류 등으로 실행이 일시 중단됨.
- 일시 중단 상태: 메모리에서 디스크로 스와핑된 상태 등, 일시적으로 비활성화.
- 종료 상태: 프로세스 실행이 완료되거나 강제 종료됨.

---

## 프로세스의 메모리 구조

- 스택(Stack) : 함수 호출, 지역 변수, 복귀 주소 등 임시 데이터 저장.
- 힙(Heap) : 동적으로 할당되는 메모리 영역. malloc, new 등으로 관리.
- 데이터 영역(Data) : 전역 변수, 정적 변수 등이 저장됨.
- 코드 영역(Text) : 실행할 프로그램 코드가 저장됨.

---

## PCB (Process Control Block)

- PCB의 구조
    - 프로세스 스케줄링 상태: 현재 프로세스의 상태(생성, 대기, 실행 등)
    - 프로세스 ID: 각 프로세스를 구분하는 고유 식별자
    - 프로세스 권한: 프로세스의 권한 정보
    - 프로그램 카운터: 다음에 실행할 명령어의 주소
    - CPU 레지스터: 프로세스가 사용하던 레지스터 값 저장
    - CPU 스케줄링 정보: 우선순위, 스케줄링 큐 포인터 등
    - 계정 정보: 사용자 ID, 그룹 ID 등
    - I/O 상태 정보: 할당된 I/O 장치, 열린 파일 등
- 컨텍스트 스위칭: 한 프로세스에서 다른 프로세스로 CPU 제어권을 넘길 때, 현재 프로세스의 상태(PCB)를 저장하고 새로운 프로세스의 PCB를 불러오는 작업.

---

## 멀티프로세싱

- 웹 브라우저
    - 브라우저 프로세스: UI, 네트워크, 파일 접근 등을 담당.
    - 렌더러 프로세스: 웹 페이지 렌더링(HTML, CSS, JS 실행).
    - 플러그인 프로세스: 플러그인(예: PDF 뷰어) 실행.
    - GPU 프로세스: 그래픽 가속 처리.
- IPC(Inter-Process Communication, 프로세스 간 통신)
    - 공유 메모리: 여러 프로세스가 동일 메모리 영역을 공유해 데이터 교환.
    - 파일: 파일을 통해 데이터 교환.
    - 소켓: 네트워크 소켓을 이용한 통신.
    - 익명 파이프(Anonymous Pipe): 부모-자식 프로세스 간 단방향 통신.
    - 명명된 파이프(Named Pipe): 파일처럼 이름이 있는 파이프로, 관련 없는 프로세스 간 통신 가능.
    - 메시지 큐(Message Queue): 메시지를 큐에 넣고 빼며 통신.

---

## 스레드와 멀티스레딩

- 스레드 : 프로세스 내에서 실행되는 흐름의 단위. 프로세스의 자원을 공유하며, 각 스레드는 스택만 별도로 가짐.
- 멀티스레딩 : 한 프로세스 내에서 여러 스레드를 동시에 실행. 병렬 처리 및 자원 공유로 효율적.

---

## 공유 자원과 임계 영역

- 공유 자원 : 여러 스레드/프로세스가 동시에 접근할 수 있는 자원.
- 임계 영역 : 공유 자원에 접근하는 코드 영역. 동시 접근 시 문제가 발생할 수 있음.
    - 뮤텍스(Mutex): 임계 영역에 한 번에 하나의 스레드만 접근 가능.
    - 세마포어(Semaphore)
        - 바이너리 세마포어: 0 또는 1의 값을 가지며, 뮤텍스와 유사.
        - 카운팅 세마포어: 여러 스레드가 동시에 접근 가능하지만, 허용 개수 제한.
    - 모니터(Monitor): 언어 수준에서 제공하는 동기화 메커니즘(예: Java의 synchronized).

## 교착 상태(Deadlock)

- 교착 상태의 원인
    - 상호 배제(Mutual Exclusion): 한 번에 한 프로세스만 자원을 점유.
    - 점유 대기(Hold and Wait): 프로세스가 자원을 점유한 채 다른 자원을 요청.
    - 비선점(No Preemption): 점유 중인 자원을 강제로 빼앗을 수 없음.
    - 환형 대기(Circular Wait): 프로세스들이 서로가 점유한 자원을 기다리는 순환 구조.
- 교착 상태의 해결 방법
    - 예방(Prevention): 네 가지 조건 중 하나라도 성립하지 않도록 설계.
    - 회피(Avoidance): 자원 할당 시 교착 상태 가능성을 미리 검사.
    - 탐지 및 복구(Detection & Recovery): 교착 상태 발생 시 탐지 후 복구.
    - 무시(Ignore): 교착 상태가 드물게 발생하는 경우 아무 조치도 하지 않음(현대 OS에서 많이 사용).

---

# 왜 배우는걸까?

1. 프로그램의 동작 원리 이해

- 컴파일 과정, 메모리 구조, 프로세스/스레드 개념을 알면, 내가 작성한 코드가 실제로 어떻게 컴퓨터에서 실행되는지 근본적으로 이해할 수 있습니다
- 메모리 누수, 스택 오버플로우, 힙 관리 등 버그의 원인을 파악하고 예방할 수 있습니다.

2. 성능 최적화와 효율적 자원 관리

- 캐시, 메모리 계층, 컨텍스트 스위칭, 멀티프로세싱/멀티스레딩을 이해하면, 애플리케이션의 성능을 최적화할 수 있습니다.
- 웹 브라우저, 서버, 데이터베이스 등 실제 소프트웨어가 어떻게 여러 프로세스와 스레드를 활용하는지 알면, 더 효율적인 코드와 아키텍처를 설계할 수 있습니다.
- 클라우드, MSA(Microservice Architecture) 환경에서는 여러 서비스가 독립적으로 동작하며, 프로세스와 IPC(프로세스 간 통신) 개념이 매우 중요합니다.

3. 동시성/병렬성 프로그래밍 대응

- 공유 자원, 임계 영역, 동기화(뮤텍스, 세마포어, 모니터) 개념을 이해하면, 멀티스레드 환경에서 데이터 경쟁, 데드락 등 복잡한 문제를 예방하고 해결할 수 있습니다.
- **교착 상태(Deadlock)**의 원인과 해결 방법을 알면, 시스템의 안정성을 높일 수 있습니다.

4. 확장성 있는 아키텍처 설계

- 멀티프로세싱, 멀티스레딩, IPC 등은 분산 시스템, 마이크로서비스, 클라우드 아키텍처 설계의 핵심입니다.
- 웹 브라우저, 서버, 데이터베이스 등 다양한 소프트웨어의 내부 동작을 이해하면, 확장성과 신뢰성을 높이는 시스템을 구축할 수 있습니다.

5. 문제 해결 및 디버깅 능력 향상

- 프로세스 상태, 메모리 구조, 스택/힙 등 운영체제의 동작을 이해하면, 복잡한 버그나 성능 문제의 원인을 빠르게 파악할 수 있습니다.
- 컨텍스트 스위칭, 페이지 폴트, 스레싱 등 시스템 리소스 관련 이슈도 체계적으로 분석할 수 있습니다
