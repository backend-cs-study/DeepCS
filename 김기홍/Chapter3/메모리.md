# 메모리

## 메모리 계층

> 메모리 계층은 컴퓨터 시스템에서 데이터 접근 속도, 용량, 비용을 고려해 여러 단계의 저장 장치를 계층적으로 구성하는 구조입니다.<br> 위쪽으로 갈수록 속도는 빠르고, 용량은 적으며, 비용은 높아집니다

- 레지스터: CPU 내부에 위치한 가장 빠른 소형 메모리. 연산에 필요한 데이터를 임시 저장.
- 캐시: CPU와 메인 메모리 사이에 위치, 자주 사용하는 데이터를 빠르게 접근할 수 있도록 저장.
- 메모리(RAM)/주기억장치: 프로그램 실행에 필요한 데이터와 명령어를 저장하는 휘발성 메모리.
- 저장장치(HDD, SSD)/보조기억장치: 대용량 데이터를 영구적으로 저장하는 비휘발성 장치.

---

### 캐시

- 지역성의 원리
    - 시간 지역성: 최근에 접근한 데이터가 가까운 미래에 다시 접근될 가능성이 높음.
    - 공간 지역성: 특정 위치의 데이터를 접근하면 그 근처의 데이터도 곧 접근될 가능성이 높음. 예를 들어 배열을 순회할 때 인접한 원소가 연속적으로 사용됨.

### 캐시히트와 캐시미스

- 캐시히트(Cache Hit): CPU가 요청한 데이터가 캐시에 존재할 때. 빠른 접근이 가능해 성능이 향상됨
- 캐시미스(Cache Miss): 요청한 데이터가 캐시에 없을 때. 메인 메모리나 디스크에서 데이터를 가져와야 하므로 속도가 느려짐

#### 캐시매핑

> 캐시는 메모리보다 작으므로, 메모리의 데이터를 효율적으로 캐시에 매핑하는 기법이 필요합니다

- 직접 매핑(Direct Mapping): 메모리 블록을 특정 캐시 위치에만 매핑. 구현이 간단하나 충돌이 잦음.

- 연관 매핑(Associative Mapping): 메모리 블록을 캐시의 어느 위치에나 저장할 수 있음. 충돌이 적으나 검색 속도가 느림.

- 집합 연관 매핑(Set-Associative Mapping): 직접 매핑과 연관 매핑의 중간 형태. 여러 개의 세트로 나누고, 각 세트 내에서는 연관 매핑 방식 사용.

#### 웹 브라우저의 캐시

- 브라우저 캐시: 이미지, CSS, JS 등 웹 리소스를 로컬에 저장해 재방문 시 빠르게 불러옴
- 쿠키: 서버와 클라이언트 간 상태 정보를 저장. 만료 기한이 있고, 매 요청마다 서버로 전송됨. 용량이 작음(약 4KB)
- 로컬 스토리지: 브라우저에 영구적으로 데이터 저장. 사용자가 삭제하지 않는 한 계속 남아 있음
- 세션 스토리지: 브라우저 탭이나 창을 닫으면 데이터가 삭제됨. 임시 데이터 저장에 적합
- 데이터베이스의 캐싱계층

> 데이터베이스 시스템은 자주 접근하는 데이터를 메모리(캐시)에 올려두어 성능을 향상시킵니다. 예를 들어, MySQL의 InnoDB 버퍼 풀, Redis와 같은 인메모리 데이터베이스가 대표적입니다.

## 메모리 관리

- 가상 메모리<br>
  > 프로그램이 실제 메모리보다 큰 메모리 공간을 사용할 수 있도록 하는 기술. 각 프로세스에 가상 주소 공간을 제공하고, 운영체제가 가상 주소를 물리 주소로 변환
    - 스와핑(Swapping): 메모리에 적재된 프로세스의 일부를 디스크로 옮기고, 필요할 때 다시 메모리로 불러오는 기법
    - 페이지 폴트(Page Fault): 가상 메모리에는 있지만 실제 메모리(RAM)에는 없는 데이터에 접근할 때 발생. 운영체제가 디스크에서 해당 데이터를 메모리로 불러옴
- 스레싱(Thrashing)
  > 정의: 페이지 폴트가 너무 자주 발생해 시스템 성능이 급격히 저하되는 현상.
    - 작업 세트(Working Set): 프로세스가 일정 시간 동안 실제로 사용하는 메모리 페이지 집합. 작업 세트가 메모리보다 커지면 스레싱 발생 가능
    - PFF(Page-Fault Frequency): 페이지 폴트 발생 빈도를 기준으로 메모리 할당량을 조절해 스레싱을 방지하는 알고리즘
- 메모리 할당
    - 연속 할당
        - 고정 분할 방식: 메모리를 미리 고정 크기로 나누고, 각 파티션에 프로세스를 할당. 내부 단편화 발생
        - 가변 분할 방식: 프로세스 크기에 맞게 메모리를 할당. 외부 단편화 발생
    - 불연속 할당
        - 페이징(Paging): 메모리를 고정 크기의 페이지로 나누고, 가상 메모리와 매핑. 외부 단편화 없음.
        - 세그멘테이션(Segmentation): 논리적 단위(세그먼트)로 메모리 할당. 내부 단편화는 없으나 외부 단편화 발생.
        - 페이징드 세그멘테이션(Paged Segmentation): 세그멘테이션과 페이징을 혼합한 방식.
- 페이지 교체 알고리즘
    - 오프라인 알고리즘(OPT): 미래에 접근할 페이지를 알고 있다고 가정한 이상적인 알고리즘. 실제로는 사용 불가.
    - FIFO(First In First Out): 가장 먼저 들어온 페이지를 교체.
    - LRU(Least Recently Used): 가장 오래전에 사용된 페이지를 교체.
        - NUR(Not Used Recently): 최근에 사용되지 않은 페이지를 우선적으로 교체. LRU의 근사치.
    - LFU(Least Frequently Used): 사용 빈도가 가장 적은 페이지를 교체.
