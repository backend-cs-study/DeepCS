# 자료 구조(data structure)
- 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합을 말함
- C++는 STL을 기반으로 전반적인 자료 구조를 가장 잘 설명할 수 있는 언어이며, 
  - 이를 기반으로 자료 구조에 대한 참고 코드를 제공함

✔️ 용어 <br>
- STL : C++의 표준 템플릿 라이브러리이자 스택, 배열 등 데이터 구조의 함수 등을 제공하는 라이브러리의 묶음
  <br><br>
- C++는 어려운 언어이지만 이 책에서 설명하는 C++의 수준은 '매우 쉬운 난이도'이며, 
  - 책에 실린 모든 C++ 코드는 별도의 프로그램 설치 없이 다음 링크에서 실행할 수 있음
- 링크: https://www.onlinegdb.com/online_c++ _compiler

---

# 5.1 복잡도
- 복잡도는 시간 복잡도와 공간 복잡도로 나뉨

---

# 5.1.1 시간 복잡도
## C++의 기본
- 시간 복잡도를 알아보기 전, 잠시 C++의 기본을 살펴보기 
- 먼저 입력받은 문자열을 출력하는 프로그램을 하나 만들어 봄

```C++
#include <bits/stdct+.h> // --- (1) 
using namespace std;     // --- (2) 
string a;                // --- (3) 
int main()
{
  cin >> a;              // --- (4) 
  cout << a << "\n";     // --- (5) 
  return 0;              // --- (6)
}
```
- 이렇게 만들고 실행시킨 이후 wow라고 입력하면 wow가 출력됨
- C++는 main 함수를 중심으로 돌아가므로 main 합수 하나를 무조건 만들어야 함 
  - 이후 검파일이 시작되면 전역변수 초기화, 라이브러리 import 등의 작업이 일어나고, 
  - main 함수에 얽혀 있는 함수들이 작동됨 
  - 그러고 나시 main 함수가 0을 리턴하며 프로세스가 종료됨
- 코드의 각 부분을 설명하면 다음과 같습니다.
  1. 헤더 파일 STL 라이브러리를 import함 이 중 bits/stdc++.h는 모든 표준 라이브러리가 포함된 헤더
  2. std라는 네임스페이스를 사용한다는 뜻. cin이나 cout 등을 사용할 때 원래는 std::cin처럼 네임스페이스를 달아서 호출해야 하는데, 이를 기본으로 설정한다는 뜻. 참고로 네임스페이스는 같은 클래스 이름 구별, 모듈화에 쓰이는 이름을 말함
  3. 문자열을 선언함. <타입> <변수명> 이렇게 선언함. string이라는 타입을 가진 a라는 변수를 정의함. ex) string a="큰돌" 이때 a를 1value라고 하며 큰 돌을 rvalue라고 함. 1value는 추후 다시 사용될 수 있는 변수이며, rvalue는한 번 쓰고 다시 사용되지 않는 변수를 말함
  4. 입력. 대표적으로 cin, scanf가 있음
  5. 출력. 대표적으로 cout와 printf가 있음
  6. return 0. 프로세스가 정상적으로 마무리됨을 뜻함

## 빅오 표기법
- 시간 복잡도 : '입력 크기에 대해 어떠한 알고리즘이 실행되는 데 걸리는 시간' 
- 주요 로직의 반복 횟수를 중점으로 측정되며, 보통 빅오 표기법으로 나타냄 
- ex) '입력 크기 n'의 모든 입력에 대한 알고리즘에 필요한 시간이 102n + n이라고 하면 다음과 같은 코드를 상상할 수 있음
```C++
for (int i = 0; i < 10; i++) {
   for (int j = 0; j く n; j++) {
    for (int k = 0; k < n; k++) {
     if (true) cout << k << '\n';
    }
  }
}
for (int i = 0; i < n; i++) {
 if (true) cout << i << '\n';
}
```
- 빅오 표기법이란 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것인데, 
- 앞서 말한 코드의 시간 복잡도를 빅오 표기법으로 나타내면 O(n2)이 됨 
- '가장 영향을 많이 끼치는' 항의 상수 인자를 빼고 나머지 항을 없앤 것 
- 다른 항들이 신경 쓰일 수도 있지만 증가 속도를 고려한다면 그렇지 않음
- 입력 크기가 커질수록 연산량이 가장 많이 커지는 항은 n의 제곱항이고, 
- 다른 것은 그에 비해 미미하기 때문에 이것만 신경 쓰면 된다는 이론인 것

## 시간 복잡도의 존재 이유
- 이 시간 복잡도는 왜 필요할까요? 
- 바로 효율적인 코드로 개선하는 데 쓰이는 척도가 됨 
- 버튼을 누르고 화면이 나타나는데 이 로직이 O(n2)의 시간 복잡도를 가지고 9초가 결 린다고 해봅시다. 
- 이를 O(n)의 시간 복잡도를 가지는 알고리즘으로 개선한다면 3초가 걸리게 되겠죠?

## 시간복잡도의 속도 비교
✔️ 그림5-2 시간 복잡도 속도 비교  <br>

<img src="https://github.com/user-attachments/assets/a62ef8d1-06df-46a2-a1b7-35715334f9cf" width="400"/>

- 앞의 그림처럼 O(1)과 O(n)은 입력 크기가 커질수록 차이가 많이 나는 것을 불 수 있음 
- O(n")은 말할 것도 없을 만큼 차이가 큼
- 즉, 0(n2)보다는 0(n), 0(n)보다는 0(1) 을 지향해야 함

---

# 5.1.2 공간 복잡도
- 프로그램을 실행시켰을 떄 필요로 하는 자원 공간의 양을 말함 
- 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함함
```C++
int a[1004];
```
- 예틀 들어 앞의 코드처럼 되어 있는 배열이 있다고 하면 
- a 배열은 1004 x 4바이트의 크기를 가지게 됨
- 이런 공간을 의미함

---

# 5.1.3 자료 구조에서의 시간 복잡도
- 자료 구조를 쓸 때는 이러한 시간 복잡도를 잘 생각해야 함
- 다음은 자주 쓰는 자료 구조의 시간 복잡도를 나타낸 모습 
- 보통 시간 복잡도를 생각할 때 평균, 그리고 최악의 시간 복잡도를 고려하면서씀

✔️ 표 5-1 자료 구조의 평균 시간 복잡도 <br>

<img src="https://github.com/user-attachments/assets/75dcf6c6-d93f-41c1-ae1f-bdae5b7028d4" width="600"/>

✔️ 표5-2 자료 구조 최악의 시간 복잡도 <br>

<img src="https://github.com/user-attachments/assets/f6b84d1d-2833-4da1-800d-2ea04f470572" width="600"/>

---
## ✅ 기본 질문과 답변

---

### ✅ Q1. 자료 구조란 무엇인가요?

**A.**
자료 구조는 데이터를 **효율적으로 저장, 탐색, 수정, 삭제**하기 위한 **데이터의 조직 방식**을 말합니다.
예를 들어 배열, 연결 리스트, 스택, 큐, 트리, 해시 테이블 등이 있습니다.
적절한 자료 구조 선택은 **프로그램의 성능과 직결되기 때문에 매우 중요**합니다.

---

### ✅ Q2. 시간 복잡도란 무엇인가요?

**A.**
시간 복잡도는 **알고리즘이 실행되는 데 걸리는 시간**을 **입력 크기 n에 대한 함수**로 나타낸 것입니다.
가장 많이 쓰이는 표기법은 \*\*빅오 표기법(Big-O notation)\*\*입니다.
예를 들어 반복문이 n번 수행된다면 O(n), 이중 반복문이면 O(n²)로 표현합니다.
이는 **성능을 예측하고, 효율적인 코드를 설계하기 위해 필수적으로 고려되는 지표**입니다.

---

### ✅ Q3. 빅오(Big-O) 표기법이 왜 필요한가요?

**A.**
빅오 표기법은 입력 크기가 커질 때 알고리즘의 **실행 시간 증가율**을 나타냅니다.
정확한 시간 측정이 어려운 상황에서 **알고리즘의 효율을 정량적으로 비교**할 수 있는 수단입니다.
예를 들어 O(n²) 알고리즘을 O(n)으로 개선하면 처리 시간이 획기적으로 줄어들 수 있습니다.

---

### ✅ Q4. 공간 복잡도란 무엇인가요?

**A.**
공간 복잡도는 **알고리즘이 실행되는 동안 필요한 메모리 공간의 양**을 의미합니다.
배열, 해시 테이블, 재귀 호출 등에 의해 공간이 소모되며,
시간 복잡도와 함께 **성능 최적화의 핵심 지표** 중 하나입니다.

---

### ✅ Q5. 자료 구조의 시간 복잡도는 왜 중요한가요?

**A.**
자료 구조에 따라 **삽입, 삭제, 탐색** 등의 연산 시간이 크게 달라집니다.
예를 들어 해시 테이블은 평균적으로 O(1)의 탐색 성능을 보이지만,
연결 리스트는 O(n)의 시간이 걸릴 수 있습니다.
따라서 문제에 맞는 자료 구조를 선택하려면 **시간 복잡도를 잘 이해하고 있어야 합니다.**

---

### ✅ Q6. 배열과 연결 리스트의 시간 복잡도 차이를 설명해주세요.

| 연산         | 배열 (Array) | 연결 리스트 (Linked List) |
| ---------- | ---------- | -------------------- |
| 접근         | O(1)       | O(n)                 |
| 삽입/삭제 (중간) | O(n)       | O(n) (검색 후 삽입/삭제)    |
| 삽입/삭제 (앞쪽) | O(n)       | O(1)                 |

**A.**
배열은 인덱스를 통한 접근이 빠르지만, 중간 삽입/삭제 시 데이터 이동이 필요해 O(n)입니다.
반면, 연결 리스트는 포인터만 조작하면 되므로 앞쪽 삽입/삭제가 O(1)이지만, 특정 위치를 찾는 데는 O(n)이 걸립니다.

---

### ✅ Q7. O(1), O(n), O(log n), O(n²)의 차이를 간단하게 설명해주세요.

**A.**

* **O(1)** : 입력 크기에 상관없이 항상 일정한 시간이 걸림 (예: 배열의 특정 인덱스 접근)
* **O(n)** : 입력 크기만큼 시간이 걸림 (예: 선형 탐색)
* **O(log n)** : 입력이 절반씩 줄어들면서 처리 (예: 이진 탐색)
* **O(n²)** : 이중 반복문처럼 입력이 증가할수록 제곱으로 증가 (예: 버블 정렬)

**입력 크기가 커질수록 O(1) → O(log n) → O(n) → O(n²) 순으로 속도가 느려집니다.**

---

### ✅ Q8. 알고리즘 개선을 할 때 가장 먼저 고려하는 것은 무엇인가요?

**A.**
먼저 **시간 복잡도 분석**을 통해 병목 구간을 파악합니다.
그다음 불필요한 반복을 제거하거나 더 효율적인 자료 구조로 변경해서
O(n²) → O(n log n) 또는 O(n)으로 개선하는 방법을 찾습니다.
경우에 따라서는 **공간을 더 사용해서 시간 복잡도를 줄이는** 방식도 고려합니다.

---

### ✅ Q9. 재귀 함수의 공간 복잡도는 왜 높은가요?

**A.**
재귀 함수는 호출될 때마다 **스택 메모리에 함수 호출 정보가 저장**되기 때문에,
호출 깊이가 깊어질수록 \*\*공간 복잡도는 O(n)\*\*으로 증가합니다.
따라서 재귀는 편리하지만 **메모리 부담이 크고 스택 오버플로우 위험**이 있어 주의해야 합니다.

---

## ✅ 심화 질문과 답변

---

### ✅ Q1. 시간 복잡도를 계산할 때 '가장 영향력이 큰 항만 남긴다'는 원칙은 어떤 의미인가요?

**A.**
시간 복잡도는 입력 크기(n)가 커질수록 실행 시간이 어떻게 증가하는지를 표현하기 때문에,
가장 큰 영향을 미치는 항(=지수 차수가 높은 항)만 남깁니다.
예를 들어 `102n + n`은 `O(n)`으로, `5n² + 10n + 15`는 `O(n²)`로 표기합니다.
이는 **성능 분석에서 불필요한 정보(상수, 낮은 차수)를 제거하여 직관적으로 알고리즘의 효율성을 파악하기 위해서**입니다.

---

### ✅ Q2. 시간 복잡도가 같은 O(n²)인데, 실제 성능 차이가 날 수 있는 이유는 무엇인가요?

**A.**
O(n²)라 하더라도 **상수 계수나 반복 구조에 따라 실제 실행 시간**은 크게 달라질 수 있습니다.
예를 들어 `100n²`과 `2n²`은 모두 O(n²)이지만, 전자는 후자보다 실제로 50배 느릴 수 있습니다.
또한 메모리 접근 패턴, 캐시 활용, 분기 예측 등 **하드웨어 레벨의 최적화 요소**에 따라 체감 성능 차이가 발생합니다.

---

### ✅ Q3. 공간 복잡도가 중요한 상황은 언제인가요?

**A.**
다음과 같은 경우 공간 복잡도가 중요합니다:

1. **임베디드 환경**: 제한된 메모리에서 동작해야 하는 경우
2. **대규모 데이터 처리**: RAM이 부족한 경우 디스크 스와핑 발생 → 성능 저하
3. **재귀 알고리즘**: 스택 메모리 초과로 인한 스택 오버플로우 가능
   따라서 공간 복잡도는 **시스템 환경, 데이터 크기, 동시 사용자 수에 따라 고려 대상이 됩니다.**

---

### ✅ Q4. 시간 복잡도 O(log n)인 대표적인 예시는 무엇인가요? 어떤 원리로 동작하나요?

**A.**
대표적인 예시는 **이진 탐색**입니다.
이진 탐색은 정렬된 배열에서 탐색 범위를 절반으로 줄이면서 원하는 값을 찾는 알고리즘입니다.
예: \[1, 2, 4, 7, 9, 13, 15]에서 9를 찾을 때 →
매 단계마다 중간값과 비교하며 범위를 반씩 줄이므로 O(log n)의 시간 복잡도를 가집니다.
이처럼 **입력 데이터의 크기를 반복적으로 나누는 로직**은 대부분 log n 복잡도를 갖습니다.

---

### ✅ Q5. 배열과 연결 리스트의 삽입·삭제 성능 차이가 나는 이유는 무엇인가요?

**A.**

* **배열**은 연속된 메모리 공간에 데이터를 저장하므로,
  중간 삽입/삭제 시 **뒤쪽 데이터를 한 칸씩 이동**시켜야 해 O(n)이 됩니다.
* **연결 리스트**는 포인터로 노드를 연결하므로,
  원하는 위치만 찾으면 포인터만 변경하면 되어 O(1)에 가까운 삽입/삭제가 가능합니다.
  하지만 연결 리스트는 \*\*임의 접근이 느려서 탐색에는 O(n)\*\*이 걸립니다.

---

### ✅ Q6. 시간 복잡도가 낮은데도 성능이 안 나올 수 있는 이유는 무엇인가요?

**A.**

1. **캐시 미스**: 데이터 접근 패턴이 비효율적이면 CPU 캐시를 잘 활용하지 못함
2. **I/O 병목**: 디스크 접근, 네트워크 요청 등 외부 I/O로 인해 병목 발생
3. **GC 또는 메모리 누수**: 메모리 할당/해제 문제로 처리 지연
4. **멀티스레딩**: 락이나 경합이 발생하면 논리적 성능보다 느려질 수 있음
5. **실제 구현 차이**: O(n)의 알고리즘이라도 반복문 내 연산이 많으면 느려짐

→ **빅오 표기법은 경향성을 보여줄 뿐, 실제 성능은 하드웨어·구현·환경에 따라 달라집니다.**

---

### ✅ Q7. 재귀 알고리즘의 시간 복잡도와 공간 복잡도는 각각 어떻게 계산하나요?

**A.**

* **시간 복잡도**: 함수가 몇 번 호출되고, 호출당 연산이 얼마나 발생하는지를 기준으로 계산
  예: 피보나치 수열은 `T(n) = T(n-1) + T(n-2)` → O(2ⁿ)
* **공간 복잡도**: 재귀 호출마다 **스택에 함수 상태가 쌓이므로 최대 호출 깊이만큼 필요**
  예: 깊이 n이면 O(n) 공간 복잡도

→ 따라서 재귀는 **시간·공간 모두 비효율적일 수 있어**, 가능한 반복문 또는 메모이제이션으로 대체하는 것이 좋습니다.

---

### ✅ Q8. 자료 구조를 선택할 때 고려해야 할 시간 복잡도는 어떤 것들이 있나요?

**A.**
자료 구조의 선택 시 아래 연산들의 시간 복잡도를 고려해야 합니다:

| 연산 | 중요 자료 구조                  | 시간 복잡도 예시                   |
| -- | ------------------------- | --------------------------- |
| 삽입 | Array, List, Queue, Stack | O(1) 또는 O(n)                |
| 삭제 | Array, List, Heap         | O(1) 또는 O(log n)            |
| 탐색 | Set, Map, Tree            | O(1), O(log n), O(n)        |
| 정렬 | Array, List + 정렬 알고리즘     | O(n log n) (최선), O(n²) (최악) |

→ 상황에 따라 **탐색이 빠른 HashMap(Set)**, **정렬이 필요한 TreeMap**,
**순차 처리에 좋은 Queue/Stack**, **빈번한 중간 삽입에 유리한 LinkedList** 등을 선택합니다.

---

### ✅ Q9. 해시 테이블은 평균 O(1)인데, 왜 최악은 O(n)인가요?

**A.**
해시 충돌이 발생하면 같은 버킷에 여러 항목이 저장되어 선형 탐색처럼 되기 때문입니다.
예를 들어 모든 키가 동일한 해시 값을 가질 경우, 체이닝 방식이라면 \*\*리스트로 연결되며 탐색은 O(n)\*\*이 됩니다.
이를 방지하기 위해선 **좋은 해시 함수, 적절한 해시 크기, 리사이징 전략**이 필요합니다.

---

### ✅ Q10. 시간 복잡도는 낮지만 공간 복잡도는 높은 알고리즘 예시는?

**A.**

* **메모이제이션(Memoization)** 기반 DP 알고리즘: 시간은 O(n)으로 줄지만 O(n) 공간 필요
* **캐싱을 활용한 탐색 로직**: 중복 연산 제거를 위해 해시나 배열을 활용해 공간을 더 씀
* **비트마스킹**: 특정 연산 속도 향상을 위해 정수형 비트를 공간 자원으로 활용

→ 따라서 알고리즘 설계 시에는 **시간과 공간의 trade-off**를 항상 고려해야 합니다.
