# 5.3 비선형 자료 구조
- 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 말함 
- 일반적으로 트리나 그래프를 말함

---

# 5.3.1 그래프 
- 정점과 간선으로 이루어진 자료 구조를 말함

## 정점과 간선
- 어떠한 곳에서 어떠한 곳으로 무인기를 풍해 간다고 했을 때
- '이띠한 곳'은 정점(vertex)이 되고 
- '무언가'는 간선(edge)이 됨

✔️ 그림 5-9 정점과 간선  <br>

<img src="https://github.com/user-attachments/assets/60f01ce9-dc4b-4d72-9bc2-71bc22323e80" width="600"/>

- 필자가 어떤 사람을 좋아한다고 해봄
- 필자와 어떤 사람은 정점이, 이러한 마음은 간선이 됨 
- 이때 저는 어떤 사람을 좋아하는데 그 사람은 저를 좋아하지 않는 짝사랑'이 라고 해봄
- 이것은 어떤 간선일까요? 바로 단방향 간선 
- 제 마음만 그 사람한테 가는 길밖에 없는 슬픈 관계

✔️ 그림5-10 단방향 간선 <br>

<img src="https://github.com/user-attachments/assets/06ec0e23-ac48-44a6-a0e9-5137040ad111" width="600"/>

- 하지만 그 어떤 사람도 저를 좋아한다면 어떻게 될까요? 
- 바로 양방항 간신이 됨
- 제 마음도 그 어떤 사람의 마음도 갈 수 있는 '사랑'이라고 하는 상태인 것

✔️ 그팀 5-11 잉빙향 간선  <br>

<img src="https://github.com/user-attachments/assets/dc842472-bccd-422b-8ff2-04fc8bdbc41e" width="600"/>

다음 그림을 보죠.

✔️ 그림 5-12 그래프  <br>

<img src="https://github.com/user-attachments/assets/df53242d-4bf6-482b-8cae-b326d98b062c" width="600"/>

- 정점으로 나가는 간선을 해당 정접의 outdegree라고 하며, 
- 들어오는 간선을 해당 정점의 indegree라고 함 
- 앞 그림의 정점 V는 outdegree는 세 개, indegree는 두 개인 상태
- 또한, 정점은 약자로 V 또는 U라고 하며, 보통 어떤 정점으로부터 시작해서 어떤 정점까지 간다를 "U에서부터 V로 간다."라고 표현함 
- 지금까지 설명한 정점과 간선 이루어진 집합을 '그래프(graph)'라고 함

### 가중치
- 간선과 정점 사이에 드는 비용을 뜻함 
- 1번 노드와 2번 노드까지 가는 비용 이 한 칸이라면 
- 1번 노드에서 2번 노드까지의 가중치는 한 칸 
- ex) 제가 성남 이라는 정점에서 네이버라는 정점까지 가는 데 걸리는 택시비가 13,000원이라편 
- 성남에서 네이버까지 가는 가중치는 13,000원이 됨

---

# 5.3.2 트리 
- 그래프 중 하나로 그래프의 특징처럼 정점과 간선으로 이루어져 있고, 
- 트리 구조로 배열된 일종의 계층적 데이터의 집합 
- 루트 노드, 내부 노드, 리프 노드 등으로 구성됨 
- 참고로 트리로 이루어진 집합을 숲이라고 함

## 트리의 특징

✔️ 그림 5-13 트리의 특징  <br>

<img src="https://github.com/user-attachments/assets/cc25c0ad-9dfd-481b-a87f-a587026d1b7a" width="600"/>

- 트리는 그레프의 일종이며 다양한 특장율 가진다는 점이 다름 
1. 부모, 자식 계층 구조를 가짐 지금 보면 5번 노드는 6번 노드와 7번 노드의 부모 노드이고, 6번 노드와 7번 노드는 5번 노드의 자식 노드. 같은 경로상에서 어떤 노드보다 위에 있으연 부모, 아래에 있으면 자식 노드가 됨.
2. V-1=E라는 특징이 있음. 간선 수는 노드 수 -1
3. 임의의 두 노드 사이의 경로는 '유일무이' 하게 '존재'함. 즉, 트리 내의 어떤 노드와 어떤 노드까지의 경로는 반드시 있음

## 트리의 구성 
- 트리는 루트 노드, 내부 노드, 리프 노드로 이루어져 있음

## 루트 노드 
- 가장 위에 있는 노드를 뜻함 
- 보통 트리 문제가 나오고 트리를 탐색할 때 루트 노드를 중십으로 탑색하면 문제가 쉽게 풀리는 경우가 많음

## 내부노드 
- 루트 노드와 리프 노드 사이에 있는 노드를 뜻함

## 리프노드 
- 실제 알고리즘 고인물과 카톡한 내용 
- 다음 그림처럼 리프 노드는 자식 노드가 없는 노드를 뜻함

✔️ 그림 5-14 리프 노드를 외우는 방법  <br>

<img src="https://github.com/user-attachments/assets/fea698d1-6cdc-4c17-a038-d1c73866887b" width="600"/>

### 트리의 높이와 레벨 
- 다음은 트리의 높이와 레벨은 설명한 그림 

✔️ 그림 5-15 트리의 높이와 레벨 <br>

<img src="https://github.com/user-attachments/assets/7e4b9fea-e9d4-455d-bd33-9ff45f0f7c14" width="600"/>

- 깊이 : 트리에서의 깊이는 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단 거리로 갔울 때의 거리를 말함. 
  - 예를 들어 4번 노드의 깊이는 2임 
- 높이 : 트리의 높이는 루트 노드부터 리프 노드까지 거리 중가장 긴 거리를 의미하며, 앞 그림의 트리 높이는 3임
- 레벨 : 트리의 레벨은 주어지는 문제마다 조금씩 다르지만 보통 깊이와 같은 의미를 지님. 
  - 1번 노드를 0레벨이라고 하고 2번 노드, 3번 노드까지의 레벨을 1레벨이라고 할 수도 있고, 
  - 1번 노드를 1레벨이라고 한다면 2번 노드와 3번 노드는 2레벨이 됨 
- 서브트리 : 트리 내의 하위 집합을 서브트리라고 함 
  - 트리 내에 있는 부분집합이라고도 보연 됨 
  - 지금 보면 5번, 6번, 7번 노드가 이 트리의 하위 집합으로 "저 노드들은 서브트리이다."라고함

## 이진 트리 
- 자식의 노드 수가 두 개 이하인 트리를 의미하며, 이를 다음과 같이 분류함

✔️ 그림 5-16 트리의 종류  <br>

<img src="https://github.com/user-attachments/assets/de45911a-1430-4cd7-a39a-10a06c052962" width="600"/>

- 정이진 트리(full binary tree) : 자식 노드가 0 또는 두 개인 이진 트리를 의미함
- 완전 이진 트리(complete binary tree) : 왼쪽에서부터 채워져 있는 이진 트리를 의미함
  - 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 경우 왼쪽부터 채워져 있음 
- 변질 이진 트리(degenerate binary tree) : 자식 노드가 하나밖에 없는 이진 트리를 의미함 
- 포화이진 트리(perfect binary tree) : 모든 노드가 짝 차 있는 이진 트리를 의미함
- 균형 이진 트리(balanced binary tree) : 안쪽과 오른쪽 노드의 높이 차이가 1이하인 이진 트리를 의미함 
  - map, set을 구성하는 레드 블랙 트리는 균형 이진 트리 중 하나

## 이진 탐색 트리
- 이진 탐색 트리(BST)는 노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고, 
- 왼쪽 하위 트리에는 '노드 값보다 작은 값'이 들어 있는 트리를 말함

✔️ 그림 5-17 이진 탐색 트리 <br>

<img src="https://github.com/user-attachments/assets/fec8afcb-b55b-403e-93e8-cc9b1207fd5b" width="600"/>


✔️ 그림 5-18 이진 탐색 트리의 선형적인 모습 평균 <br>
이때 왼쪽 및 오른쪽 하위 트리도 해당 특성을 가집니다. 이렇게 두면 검색'을 하기에 용 이합니다. 왼쪽에는 작은 값. 오른쪽에는 큰 값이 이미 정헤져 있기 때문에 10을 찾으려고 한다면 25의 왼쪽 노드들만 찾으면 된다는 것은 자명합니다 1,보통 요소를 찾을 때 이진탐 색트리의 경우 0(logn)이 걸립니다. 하지만 최악의 경우 0(n)이 걸립니다. 그이유는 . 이진 탐색 트리는 삽입 순서에 따라 선형적일 수 있기 때문입니다. 예를 들어 다음 그림처럼말이죠,
AVL 트리
AVL 트리(Adelson-Velsky and Landis tree)는 앞시 설명한 최악의 정우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리입니다. 자식 서브트리의 높이 두 는 항상 최대 1만큼 차이 난다는 특징이 있습니다.
미고 X 253

<img src="https://github.com/user-attachments/assets/67881748-c3ad-4e43-8c17-3a225743813d" width="600"/>


## AVL트리(Adelson-Velsky and Landis tree)
- 앞서 설명한 최악의 경우 선행적인 트리가 되는 것을 방지하고 
- 스스로 균형을 잡는 이진 탐색 트리 
- 두 자식 서브트리의 높이는 항상 최대 1만큼 차이 난다는 특징이 있음

✔️ 그림 5-19 AVL트리  <br>

<img src="https://github.com/user-attachments/assets/06cddbf2-ec1d-4bcd-ab8f-45ddb8286270" width="600"/>

- 이진 발색 트리는 선형적인 트리 형태물 가질 때 최악의 경우 O(n)의 시간 복잡도물 가짐
- "이러한 최악의 경우를 배제하고 항상 균형 잡인 트리로 만들자."라는 개념을 가진 트리가 바로 AVL 트리 
- 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)이며 
- 삽입, 삭제를 할 때마다 균형이 안 맞는 것을 맞추기 위해 
- 트리 일부를 왼쪽 혹은 오른쪽으로 회전 시키며 균형을 잡음


## 레드 블랙 트리 
- 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn).
- 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 
- 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는데 사용됨 
- C++ STL의 set, multiset, map, and multimap이 레드 블랙 트리를 이용하여 구현되어 있음

✔️ 그림 5-20 레드 블랙 트리  <br>

<img src="https://github.com/user-attachments/assets/81860a29-d187-4e44-8450-8d393e72247a" width="600"/>

- 참고로 "모든 리프 노드와 루트 노드는 불랙이고 
- 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다." 등의 규칙을 기반으로 균형을 잡는 트리

---
# 5.3.3 힙 
- 완전 이진 트리 기반의 자료 구조이며, 
- 최소힙과 최대힙 두 가지가 있고 
- 해당 힙에 따라 특정한 특징을 지킨 트리를 말함 
- 최대힙 : 루트 노드에 있는 키는 모든 자식에 있는 키중에서 가장 커야 함 
  - 또한, 각 노드의 자식노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함 
- 최소힙 : 최소힙에서 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어야 함
  - 또한,각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함

✔️ 그림 5-21 최소힙과 최대힙  <br>

<img src="https://github.com/user-attachments/assets/2a2ab504-078c-4df0-9167-d3bf5a0189d8" width="600"/>

- 힙에는 어떠한 값이 들어와도 특정 힘의 규칙을 지키게 만들어져 있음 
- 예를 들어 최대힙을 기반으로 설명하면 다음과 같음

## 최대힙의 삽입 
- 힙에 새로운 요소가 들어오면, 일단 새로운 노트를 힘의 마지막 노드에 이어서 삼입함
- 이 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킴

✔️ 그림 5-22 최대힙의 삽입 <br>

<img src="https://github.com/user-attachments/assets/c7e587c1-f96d-456d-9b61-acbcd32ea833" width="600"/>

- 예를 들어 8이라는 값을 가진 노드 밑에 15라는 값을 가진 노드를 삼입한다고 하면, 
- 이 노드가 점차 올라가면서 해당 노드 위에 있는 노드와 스왑하는 과정을 거쳐 최대험 조건을 만족하게 됨


## 최대힙의 삭제 
- 최대힙에서 최댓값은 루트 노드이므로 투트 노드가 삭제되고,
- 그 이후 마지막 노드와 루트 노드를 스왑하여 또다시 스왑 등의 과정을 거쳐 재구성됨 

---

# 5.3.4 우선순위 큐 
- 우선순위 큐는 우선순위 대기열이라고도 하며, 
- 대기열에서 우선순위가 높은 요소가 우선 순위가 낮은 요소보다 먼저 제공되는 자료 구조

✔️ 그림 5-23 우선순위 큐 <br>

<img src="https://github.com/user-attachments/assets/c203e1eb-4b6a-43d9-b697-a05ae9fbb26d" width="600"/>

- 우선순위 큐는 힙을 기반으로 구현됨 
- 다음 코드처럼 greater를 써서 오름차순, less를 씨서 내립차순으로 바꿀 수 있음 
- int뿐만 아니라 다른 자료 구조를 넣어서 할 수도 있음


```C++
#include <bits/stdc++.h>
using namespace std;
priority_queue<int, vector<int>, greater<int> > pa; // 오름차순 
// priority_queue<int, vector<int>, less<int> > pa; //내림차순 
int main() {
  pq.push(5); 
  pq.push(4); 
  pq.push(3); 
  pq.push(2); 
  pq.push(1); 
  cout << pq.top() << "\n"; 
  return 0;
}
/*
1
*/
```
- 오름차순으로 정렬하게 했고 5, 4, 3, 2, 1이 입력되었음에도 
- 우선순위가 높은 1이 출력되는 것을 볼 수 있음

---
## 5.3.5 맵(map)
- 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조 
  - 예를 들어 "이승철": 1, "박동영" : 2 같은 방식으로 string : int 형태로 값을 할당해야 할 때 있죠? 
  - 그럴 때 map을 씁니다. 
  - 레드 블랙 트리 자료 구조를 기반으로 형성되고, 삽입하면 자동으로 정렬됨 
- 맵을 쓸 때는 map<string, int> 형태로 구현함 
  - 배열과 비슷하게 clear() 함수로 맵에 있는 모든 요소를 삭제할 수 있으며, 
  - size()로 map 크기를 구할 수 있음 
  - 또한, erase()로 해당 키와 키에 매핑된 값을 지울 수 있음
- 참고로 map은 해시 테이블을 구현할 때 쓰며 
- 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는 map 두 가지가 있음

```C++
#include <bits/stdc++.h> 
using namespace std; 
int v[10];
int main() {
  unordered_map<string, int> umap; 
  // 다음과 같이 넣기도 가능하고 
  umap.insert({"test1", 1}); 
  // 이렇게 넣을 수도 있다 
  umap.emplace("test5", 5); 
  // 또한, 이렇게 변경도 가능, 추가할 수도 있다. 다음 형태를 권장한다. 
  umap["test1"] = 4;
  
  for (auto element umap) {
    cout << element.first << " :: " << element.second << '\n';
  }
  // map의 find 메서드는 찾지 못하면 end() 이터레이터를 반환한다. 
  auto search = umap.find("test4"); 
  if (search != umap.end()) {
    cout << "found :" << search -> first << " " << (*search).second << '\n';
  } else {
    cout << "not found.." << "\n';
  }
  // 다음과 같이 ++를 통해 test1이라는 키에 매핑된 int 값을 증가한다. 
  umap["test1"]++;
  cout << umap["test1"] << "\n";

  cout << umap.size() << "\n"; 
  umap,erase("test1");
  cout << umap,sizel) << "\n";
  
  return 0;
}  
/*
tes:5 :: 5 
test1 :: 4 
not found..
5
2
1
*/
```
- map을 순회할 때는 키에 해당하는 값(key)을 first, 
- 키에 매핑된 값(value)에 해당하는 값을 second로 탐색 가능함

```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
  map<string, int> map;
  _map["큰돌"]++;
  _map["큰돌"]++;
  for (auto c: _map) {
    cout << c.first << " : " << c.second << "\n";
   }
  return 0;
}
/*
큰돌 : 2
*/
```

---

# 5.3.6 셋(set)
- 특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며, 
- 중복되는 요소는 없고 오로지 희소한(unigue) 값만 저장하는 자료 구조

```C++
#include <bits/stdc++.h>
using namespace std; 
int main() {
  set<pair<string, int>> _set; 
  _set.insert({"test", 1}); 
  _set.insert({"test", 1}); 
  _set.insert({"test", 1}); 
  _set.insert({"test", 1}); 
  cout << _set.size() << "\n"; 
  return 0;
}
/*
1
*/
```
- 여기서 pair는 두 가지 형을 담을 수 있는 구조이며 
- first, second로 그 인자에 접근이 가능함 
- 이렇게 똑같은 값을 넣었더니 1이 나오는 것을 볼 수 있음 
- 나머지 사항은 map과 비슷함

---

# 5.3.7 해시테이블
- 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이불
- 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가지며 
- unordered_map 로 구현함

---
## ✅ 기본 질문과 답변


---

## ✅ 심화 질문과 답변

---

