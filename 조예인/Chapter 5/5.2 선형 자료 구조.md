# 5.2 선형 자료 구조
- 요소가 일렬로 나열되어 있는 자료 구조를 말함

---

# 5.2.1 연결 리스트 
- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조
- 삽입과 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸림

✔️ 그림 5-3 연결리스트  <br>

<img src="https://github.com/user-attachments/assets/f590722f-e1f4-4c69-bdcc-228e8ed47c2f" width="600"/>

- 앞의 그림처럼 prev 포인터와 nex 포인터로 앞과 뒤의 노드를 연결시킨 것이 연결 리스트이며, 
- 연결 리스트는 싱글 연결 리스트, 이중 연결 리스트, 원형 이중 연결 리스트가 있음
- 참고로 맨 앞에 있는 노트를 헤드(head)라고 함
  - 싱글 연결 리스트: next 포인터만 가짐
  - 이중 연결 리스트: next 포인터와 prev 포인터를 가짐 
  - 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것을 말함 
- 이 책에서는 이중 연결 리스트를 기반으로 설명함
- 이중 연결 리스트는 앞에서 부터 요소를 넣는 push_front(), 
- 뒤에서부터 요소를 넣는 push_back(), 
- 중간에 요소를 넣는 insert() 등의 함수가 있음

```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
  list<int> a;
  for (int i = 0; i < 10; i++)a.push_back(i); 
  for (int i = 0; i < 10; i++)a.push_front(i); 
  auto it = a.begin(); it++; 
  a.insert(it, 1000); 
  for (auto it : a) cout << it << " "; 
  cout << '\n'; 
  a.pop_front();
  a.pop_back(); 
  for (auto it : a) cout << it << " "; 
  cout < '\n'; 
  return 0;
}
/*
9 1000 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 
1000 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8
*/
```
---

# 5.2.2 배열(array
- 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
  - 또한, 중복을 허용하고 순서가 있음
- 여기서 설명하는 배열은 '정적 배열'을 기반으로 설명함 
- 접근(참조)에 O(1)의 시간 복잡도를 가지며 랜덤 접근(random access)이 가능함 
- 삽입과 삭제에는 O(n)이 걸림 
- 따라서 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 
- 접근(참조)을 많이 하는 것은 배열로 하는 것이 좋음

## 랜덤 접근과 순차적 접근
- 직접 접근이라고 하는 랜덤 접근은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 
  - 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 이는 데이터를 저장된 순서대로 검색해야 하는 순차적 접근과는 반대

✔️ 그림 5-4 랜덤 접근과 순차적 접근  <br>

<img src="https://github.com/user-attachments/assets/fdd5d02f-9ef5-489d-ab42-de3f7d9598f0" width="600"/>

## 배열과 연결 리스트 비교
- 배열은 상자를 순서대로 나열한 데이터 구조이며 
  - 몇 번째 상자인지만 알면 해당상자의 요소를 끄집어낼 수 있음 
- 연결 리스트는 상자를 선으로 연결한 형태의 데이터 구조이며, 
  - 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 한다는 점이 다름

✔️ 그림 5-5 배열과 연결 리스트의 비교 <br>

<img src="https://github.com/user-attachments/assets/685b999a-613b-474d-b46a-6c151d54a7cd" width="600"/>

- 앞의 그림에서 유추할 수 있듯이 n번째 요소의 접근(장조)은 배열은 빠르고 연길 리스트는 느림
  - 배열의 경우 그저 상자 위에 있는 요소를 접근하면 되기 때문에 O(1)의 시간 북 잡도를 가지고, 
  - 연걸 리스트는 매빈 상자를 열어야 하고 주어진 선을 기반으로 순차적으로 열어야 하기 때문에 
  - 접근(참조)의 경우 O(n)의 시간 북잡도를 가짐 
  - 즉, 참조가 많이 일어나는 작업의 경우 배열이 빠르고 연결 리스트는 느림 
- 하지만 데이터 추가 및 삭제는 연결 리스트가 더 빠르고 배열은 느림 
- 배열은 모든 상자를 앞으로 옮겨야 추가가 가능하지만, 연결 리스트는 선을 바꿔서 연결해주기만 하면 되기 때문

```C++
#include <bits/stdc++.h) 
using namespace std; 
int a[10]; 
int main() { 
  for (int i = 0; i < 10; i++)a[i]=i; 
  for (auto it : a) cout << it << " "; 
  cout << '\n'; 
  return 0; 
} 
/*
0 1 2 3 4 5 6 7 8 9
*/
```

---

# 5.2.3 벡터(vector)
- 동적으로 요소를 할당할 수 있는 동적 배열
  - 컴파일 시점에 개수를 모른다면 벡터를 써야 함 
  - 또한, 중복을 허용하고 순서가 있고 랜덤 접근이 가능함
  - 탐색과 맨 뒤의 요소를 삭제하거나 삽입하는 데 O(1)이 걸리며, 
  - 맨 뒤가 아닌 요소를 삭제하고 삽입하는 데 O(n)의 시간이 걸림 
- 참고로 뒤에서부터 삽입하는 push_back()의 경우 O(1)의 시간이 걸리는데, 
  - 백터의 크기가 증가되는 시간 복잡도가 amortized 복잡도, 
  - 즉 상수 시간 복잡도 O(1)과 유사한 시간 복잡도를 가지기 때문

✔️ 그림 5-6 push_back()을 할 때의 벡터 크기 증가  <br>

<img src="https://github.com/user-attachments/assets/f4f2b1f2-80e8-4f09-a3e1-efa7b2320fe1" width="600"/>

- 앞의 그림처럼 push_back()을 한다고 해서 매번 크기가 증가하는 것이 아니라 
- 2의 제곱승 +1마다 크기를 2배로 늘리는 것을 알 수 있음
- ci를 i번째 push_back()을 할 때 드는 비용(cost)이라고 한다면, 
- ci는 1 또는 1 + 2k이라는 것을 알 수 있음 
- 그렇다면 n번 push_back()을 한다고 했을 때 드는 비용 T(n)은 다음 과 같은 식이라는 것을 알 수 있음

<img src="https://github.com/user-attachments/assets/3f704311-ee6d-477f-89b5-a184d5f41c53" width="600"/>

- 이를 n으로 나누게 되면 push_back()을 할 때 평균적으로 드는 비용을 알 수 있는데, 
- 이것이 바로 3이기 때문에 이는 1이라는 상수 시간보다는 크지만 상수 시간에 가까운 amortized 복잡도를 가진다는 것을 알 수 있음 
- 그렇기 때문에 push_back()은 O(1)의 시간 복잡도를 가진다고 할 수 있음
- 
```C++
#include <bits/stdc++.h> 
using namespace std; 
vector<int> v; 
int main() {
  for (int i = 1; i <= 10; i++)v.push_back(i); 
  for (int a : v) cout << a << " "; 
  cout << "\n"; 
  v.pop_back();
  
  for (int a : v) cout << a << " "; 
  cout < "\n";
  
  v.erase(v.begin(), v.begin() + 1);
  
  for (int a : v) cout  << a << " "; 
  cout < "\n";
  
  auto a = find(v.begin(), v.end(), 100); 
  if (a == v.end()) cout << "not found" << "\n";
  
  fill(v.begin(), v.end(), 10); 
  for (int a : v) cout << a << " ";
  cout < "\n"; 
  v.clear();
  for (int a : v) cout << a << " ";
  cout << "\n";
  
  return 0;
}
/*
1 2 3 4 5 6 7 8 9 1 0 
1 2 3 4 5 6 7 8 9 
2 3 4 5 6 7 8 9 
not found 
10 10 10 10 10 10 10 10
*/
```
- 뒤부터 요소를 더하는 push_back(), 
- 맨 뒤부터 지우는 pop_back(), 
- 지우는 erase(), 
- 요소를 찾는 find(), 
- 배열을 초기화하는 clear() 함수가 있음

```C++
for (int a : v) cout << a << '\n'; 
for (int i = 0; i < v.size(); i++) cout << v[i] << '\n'; 
// 위의 두 코드는 같은 뜻
```
- 잠시 앞의 코드를 봄
  - 이는 "벡터의 요소를 순차적으로 탐색한다."라는 뜻이며, 전자와 후자 코드는 같습니다.
- 예를 들어 벡터 v에 pair라는 값이 들어간다면 어떻게 해야 할까요? 
  - for (pair<int, int> a: v) 방식으로 순회해야 함

---

# 5.2.4 스택
- 스택은 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조
- 재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰임 
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸림

✔️ 그림5-7 스택  <br>

<img src="https://github.com/user-attachments/assets/537d1d6d-421e-4f1e-97cf-708cbd2578d5" width="600"/>

```C++
#include <bits/stdc++.h> 
using namespace std; 
stack<int> stk; 
int main() {
  ios_base::sync_with_stdio(false); 
  cin.tie(NULL); 
  for (int i = 0; i < 10; i++)stk.push(i); 
  while (stk.size()) {
    cout << stk.top() << " "; 
    stk.pop();
  }
}
/* 
9 8 7 6 5 4 3 2 1 0
*/
```

# 5.2.5 큐(queue)
- 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 지닌 자료 구조이며, 
- 나중에 집어넣은 데이터가 먼저 나오는 스택과는 반대되는 개념을 가짐
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸림

✔️ 그림5-8 큐 <br>

<img src="https://github.com/user-attachments/assets/bbf2b105-1941-4713-8a6e-60b3026e9ce8" width="600"/>

- CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용됨

```C++
#include <bits/stdc++.h> 
using namespace std;
int main() {
  queue<int> q;
  q.push(1); 
  cout << q.front() << "\n";
  q.pop(); 
  cout << q.size() << "\n"; 
  return 0;
}
/*
1
0
*/
```
- 참고로 C++에서 enqueue()는 push(), dequeue() 는 pop()으로 구현되었습니다.


---
## ✅ 기본 질문과 답변

---

### 1. Q: 배열과 연결 리스트의 차이는 무엇인가요?

**A:**
배열은 메모리상에 연속된 공간을 가지는 자료 구조로, 임의 접근이 가능해 O(1)의 시간복잡도로 요소에 접근할 수 있습니다. 반면, 연결 리스트는 노드들이 포인터로 연결된 형태로, 삽입과 삭제는 O(1)이지만 특정 요소 접근 시 O(n)의 시간복잡도가 필요합니다. 따라서 참조가 많은 경우엔 배열을, 삽입/삭제가 많은 경우엔 연결 리스트를 사용합니다.

---

### 2. Q: 벡터(Vector)와 배열(Array)의 차이는 무엇인가요?

**A:**
벡터는 동적 배열로, 실행 중에도 크기를 조절할 수 있고, 자동으로 메모리를 확장합니다. 반면 배열은 정적 배열로 크기가 고정되어 있습니다. 벡터는 `push_back()`으로 요소를 추가할 수 있고, 평균적으로 O(1)의 시간복잡도를 가집니다. 배열은 컴파일 타임에 크기를 정해야 하지만 접근 속도는 동일하게 빠릅니다.

---

### 3. Q: 벡터의 `push_back()`이 O(1)인 이유는 무엇인가요?

**A:**
벡터는 내부적으로 2배씩 크기를 확장하는 방식으로 동작하며, 새로운 메모리를 할당하고 기존 데이터를 복사합니다. 이 과정은 특정 순간에는 O(n)이 들지만, 전체적인 연산 평균을 보면 `amortized`하게 O(1)에 가까운 시간으로 처리됩니다. 따라서 평균적으로 `push_back()`은 O(1)의 시간복잡도를 가진다고 합니다.

---

### 4. Q: 스택과 큐의 차이는 무엇인가요?

**A:**
스택은 LIFO(Last In First Out) 구조로, 가장 마지막에 넣은 데이터가 가장 먼저 나옵니다. 반면 큐는 FIFO(First In First Out) 구조로, 가장 먼저 넣은 데이터가 가장 먼저 나옵니다. 스택은 함수 호출이나 백트래킹 등에 사용되고, 큐는 너비 우선 탐색(BFS)이나 작업 처리 대기열에 사용됩니다.

---

### 5. Q: 연결 리스트에서 중간에 데이터를 삽입하려면 어떻게 하나요?

**A:**
이중 연결 리스트에서는 `iterator`를 해당 위치로 이동시킨 후 `insert()` 함수를 사용하여 삽입할 수 있습니다. `iterator`를 사용하면 포인터 기반으로 직접 위치를 제어할 수 있어 중간 삽입이 효율적입니다. 하지만 단순 연결 리스트에서는 이전 노드를 알아야 하므로 더 복잡해집니다.

---

### 6. Q: 배열과 벡터 중 어떤 자료구조를 선택해야 할까요?

**A:**

* 요소 수가 고정되어 있고 빠른 접근이 필요하면 배열,
* 요소 수가 가변적이고 삽입/삭제가 필요하면 벡터를 사용하는 것이 좋습니다.

---

### 7. Q: 연결 리스트의 단점은 무엇인가요?

**A:**

* 임의 접근이 불가능하므로 특정 요소에 접근할 때 O(n)의 시간이 걸립니다.
* 포인터를 추가로 저장해야 하므로 메모리 사용량이 많습니다.
* 캐시 메모리 효율이 떨어집니다 (배열은 연속된 메모리 블록을 사용하므로 캐시 친화적입니다).

---

### 8. Q: C++에서 연결 리스트, 스택, 큐는 각각 어떤 STL 클래스를 사용하나요?

**A:**

* 연결 리스트: `std::list`
* 스택: `std::stack` (내부적으로 `deque`를 기반으로 함)
* 큐: `std::queue` (역시 `deque` 기반)

---

### 9. Q: STL의 `list`, `vector`, `deque`의 차이를 설명해주세요.

**A:**

* `vector`: 동적 배열. 임의 접근이 빠르지만 앞쪽 삽입/삭제는 느림.
* `list`: 이중 연결 리스트. 임의 접근은 느리지만 삽입/삭제가 빠름.
* `deque`: 양쪽 끝 삽입/삭제가 빠른 자료구조. 스택과 큐에 주로 쓰임.

---

### 10. Q: 큐(Queue)의 활용 예시를 알려주세요.

**A:**

* BFS 알고리즘에서 노드를 탐색할 때 사용
* OS의 프로세스 스케줄링
* 네트워크 패킷 처리, 캐시 시스템의 요청 대기열 등

---

## ✅ 심화 질문과 답변

---

## 🔸 1. 배열과 연결 리스트 중 어떤 상황에서 각각을 선택하나요?

**Q. 배열과 연결 리스트의 시간복잡도 관점에서 차이점은 무엇이고, 어떤 상황에서 각각을 사용하는 것이 적절한가요?**

**A.**

* 배열은 \*\*랜덤 접근이 O(1)\*\*로 매우 빠르기 때문에, 인덱스를 통해 빠르게 데이터를 조회해야 하는 경우 유리합니다.
* 반면 연결 리스트는 \*\*삽입/삭제가 O(1)\*\*이므로, 빈번하게 중간 삽입 또는 삭제가 필요한 경우에 적합합니다.
* 예시:

  * 정적 페이지네이션 → 배열
  * 데이터가 수시로 변동되는 대기열, 히스토리 → 연결 리스트
* 백엔드 예: 게시판의 댓글 스레드처럼 삽입/삭제가 잦고 순차 접근이 주인 경우 연결 리스트가 적합할 수 있습니다.

---

## 🔸 2. 벡터(vector)의 `push_back()`이 O(1)인 이유는?

**Q. 벡터에서 `push_back()`은 동적으로 메모리를 재할당해야 하는 경우도 있는데, 왜 평균적으로 O(1)의 시간복잡도를 가진다고 하나요?**

**A.**

* 이는 \*\*Amortized Analysis(평균 시간 복잡도)\*\*의 개념 때문입니다.
* 벡터는 용량이 부족할 때 메모리를 **2배씩 확장**하며 새 공간에 데이터를 복사합니다.
* 하지만 확장이 자주 일어나지 않고 대부분의 `push_back()`은 단순 삽입이므로 전체 N번 중 복사 연산이 일어난 총 시간은 **O(N)** 수준입니다.
* 따라서 한 번의 삽입 평균 시간은 \*\*O(1)\*\*에 가까워집니다.

---

## 🔸 3. 연결 리스트에서 중간 노드를 탐색하려면 왜 느린가요?

**Q. 연결 리스트에서 중간에 있는 데이터를 찾으려면 왜 O(n)이 걸리며, 이를 해결할 수 있는 방법은 없나요?**

**A.**

* 연결 리스트는 포인터로 노드를 연결하므로, 특정 인덱스를 찾기 위해 **처음부터 차례대로 순회해야** 합니다.
* 따라서 인덱스가 n/2인 노드를 찾기 위해 O(n)의 시간이 필요합니다.
* 해결 방법:

  * **인덱스 캐싱**, **해시테이블과 병행**, **Skip List** 등의 자료구조가 성능 개선에 사용됩니다.

---

## 🔸 4. 스택과 큐의 차이점과 실제 백엔드 활용 사례는?

**Q. 스택과 큐는 어떤 차이점이 있고, 각각의 대표적인 사용 사례는 무엇인가요?**

**A.**

* **스택 (LIFO)**: 마지막에 들어온 데이터가 가장 먼저 나옴.

  * 백트래킹, 재귀 호출 저장 구조, 브라우저 방문 기록 등.
* **큐 (FIFO)**: 먼저 들어온 데이터가 먼저 나옴.

  * 작업 스케줄링, BFS 탐색, 요청 처리 대기열 등.
* 백엔드 예:

  * **스택**: 함수 호출 기록, undo 기능
  * **큐**: Kafka, RabbitMQ 같은 **메시지 큐 시스템**

---

## 🔸 5. 백엔드에서 벡터 대신 연결 리스트를 쓰면 안 되는 이유는?

**Q. 벡터 대신 연결 리스트를 사용하면 메모리 할당이 유동적이라 유리한 거 아닌가요?**

**A.**

* 연결 리스트는 포인터 추가 저장이 필요하고 **메모리 접근 효율이 낮습니다**.
* CPU 캐시 히트율이 낮고, 포인터 dereference가 많기 때문에 실제 성능은 **벡터보다 나쁠 수 있습니다**.
* 대부분의 백엔드 서비스에서는 데이터가 수시로 삽입/삭제되지 않고, **배치 조회**와 같은 빠른 접근이 중요하므로 벡터(또는 배열형 구조)가 더 적합한 경우가 많습니다.

---

## 🔸 6. C++ STL의 `list`와 `vector` 중 하나를 직접 구현하라면, 어떤 고려사항이 있나요?

**Q. `std::list`와 `std::vector` 중 하나를 직접 구현한다면 어떤 점을 가장 중요하게 고려하시겠습니까?**

**A.**

* `vector`는 **동적 메모리 재할당**, **capacity 관리**, **연속 메모리** 보장을 고려해야 하며,
* `list`는 **노드 포인터 구조**, **삽입/삭제 시 포인터 연결 관리**, **메모리 관리**가 핵심입니다.
* 또한 C++의 경우 **Iterator 안정성**, **예외 안전성**, **allocator를 통한 커스터마이징**도 중요한 구현 포인트입니다.

---

## 🔸 7. Queue의 탐색이 O(n)인 이유는?

**Q. Queue에서 탐색이 O(n)인 이유와 이를 보완할 수 있는 방법은 무엇인가요?**

**A.**

* Queue는 선입선출 구조이기 때문에, 특정 값을 찾으려면 모든 요소를 순차적으로 확인해야 하기 때문입니다.
* 보완 방법:

  * 만약 빠른 탐색이 필요한 Queue라면 **Queue + HashMap** 조합을 활용합니다. (예: LRU Cache)
  * 이런 구조는 "값 삽입 순서 유지 + 빠른 탐색"을 동시에 달성합니다.

---

## 🔸 8. 백엔드 시스템에서 Stack을 실제로 활용할 수 있는 예시는?

**Q. 실무에서 Stack 자료 구조를 어떤 상황에서 활용할 수 있을까요?**

**A.**

* 트랜잭션 관리: 복수 작업이 실패 시 **롤백** 처리 → 작업 스택 구조로 관리
* 중첩된 태그 처리: HTML/XML 등의 파싱
* 표현식 계산기: 후위표기법 계산
* 경로 탐색 알고리즘(DFS): 스택 기반 구현
