# 3.4 CPU 스케줄링 알고리즘
- CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 
  - 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당함

✔️ CPU 스케줄링 알고리즘  <br>
- 비선점형
  - FCFS
  - SJF
  - 우선순위
- 선점형
  - 라운드로빈
  - SRF
  - 다단계큐

- 프로그램이 실행될 때는 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄 것인지 결정함
- 이 알고리즘의 목표 : 
  - CPU 이용률은 높게, 
  - 주어진 시간에 많은 일을 하계, 
  - 준비 큐(ready queue)에 있는 프로세스는 적게, 
  - 웅답 시간은 짬계 설정

---
# 3.4.1 비선점형 방식(non- preemptive)
- 프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로셰스를 중지하지 않음 
- 따라서 컨텍스트 스위칭으로 인한 부하가 적음

## FCFS(First Come, First Served)
- 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘 
- 단점 : 길게 수행되는 프로세스 때문에 '준비 큐에서 오래 기다리는 현상(convoy effect)'이 발생

## SJF(Shortest Job First)
- 실행 시간이 가장 짧은 프로세스를 가장 면제 실행하는 알고리즘
- 긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)이 일어나며 
- 평균 대기 시간이 가장 찾음 
- 하지만 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행했던 시간을 토대로 추측해서 사용함

## 우선순위
- 기존 SJF 스케줄링의 경우 긴 시간을 가진 프로세스가 실행되지 않는 현상이 있었음
- 우선순위는 이 단점을 오래된 작업일수록 '우선순위를 높이는 방법(aging)'을 사용해 보완한 알고리즘
- 참고로 우선순위는 앞서 설명한 SJF와 우선순위를 말하는 것 뿐만 아니라 
- FCFS를 활용하여 만들기도 하며 선점형, 비선점형적인 우선순위 스케줄링 알고리즘을 말하기도 함

---

# 3.4.2 선점형 방식
- 선점형 방식(preemptive)은 현대 운영체제가 쓰는 방식으로 
- 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 
- 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식

## 라운드 로빈(RR. Round Robin)
- 현대 컴퓨터가 쓰는 선점형 알고리즘 스케줄링 방법
  - 각 프로세스는 동일한 할당 시간을 주고 
  - 그 시간 안에 끝나지 않으면 다시 준비큐(ready queue)의 뒤로 가는 알고리즘
- ex) q만큼의 할당 시간이 부여되었고 N개의 프로세스가 운영된다고 하면 
  - (N-]) * q시간이 지나면 자기 차례가 오게 됨 
  - 할당 시간이 너무 크면 FCFS가 되고 짧으면 컨텍스트 스위침이 잦아져서 오버헤드, 즉 비용이 커짐
  - 일반적으로 전체 작업 시간은 길어지지만 평균 웅답 시간은 짧아진다는 특징이 있음
- 또한, 이 알고리즘은 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰임

## SRF(Shortest Remaining Time First)
- SJF : 중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고
  - 그 다음 잠은 작업은 이어나감
- SRF :  중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘

## 다단계 큐
- 우선순위에 따른 준비 큐를 여러 개 사용하고, 
- 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용한 것
- 특징 : 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적지만 유연성이 떨어짐

✔️ 다단계 큐  <br>
- 높은 우선순위
  - 시스템 프로세스
    - FCFS
- 중간 우선순위
  - 상호 작용적인 프로세스
      - SJF
- 낮은 우선순위
  - 배치 프로세스
    - RR

---
## ✅ 기본 질문과 답변

### 🔸 Q1. FCFS와 SJF의 차이점은 무엇이고, 각각의 장단점은 무엇인가요?

**답변:**

* **FCFS (First Come, First Served)** 는 도착 순서대로 처리하는 비선점형 스케줄링입니다. 
  * 단순하지만 **convoy effect** 때문에 짧은 작업이 긴 작업 뒤에 밀려 응답 속도가 느려질 수 있습니다.
* **SJF (Shortest Job First)** 는 실행 시간이 가장 짧은 작업을 먼저 처리합니다. 
  * 평균 대기 시간을 최소화할 수 있지만, 실행 시간을 정확히 알기 어렵고, 긴 작업이 계속 밀려 **기아(starvation)** 상태가 발생할 수 있습니다.

### 🔸 Q2. 비선점형과 선점형 스케줄링의 차이점은 무엇이고, 각각이 적합한 상황은 언제인가요?

**답변:**

* **비선점형(non-preemptive)**: 실행 중인 프로세스를 **강제로 중단하지 않음**. 예측 가능한 처리 순서를 갖기 때문에 **임베디드 시스템**이나 **실시간 제어 시스템**에 적합합니다.
* **선점형(preemptive)**: 더 높은 우선순위 프로세스가 오면 **현재 실행 중인 작업을 중단하고 교체**합니다. 사용자 반응성이 중요한 **데스크탑 OS, 웹 서버** 등에서는 선점형이 유리합니다.



### 🔸 Q3. 라운드 로빈(Round Robin) 스케줄링이 현대 운영체제에서 많이 쓰이는 이유는?

**답변:**
- 라운드 로빈은 **모든 프로세스에 공정한 시간(q)** 을 주기 때문에 **응답성이 균일**하고 사용자 경험이 좋습니다.
- 특히 **멀티태스킹 환경**에서 다양한 프로세스가 동시에 동작할 때 유리하며, **웹 서버나 WAS**에서 동시에 들어오는 다수의 요청 처리에 적합합니다.
- 단, **타임 쿼텀이 너무 짧으면 컨텍스트 스위칭 오버헤드**가 증가하고, 너무 길면 FCFS처럼 느려질 수 있으므로 적절한 설정이 중요합니다.

### 🔸 Q4. SJF 대신 SRF를 사용하는 이유는 무엇인가요?

**답변:**
- SRF(Shortest Remaining Time First)는 선점형 버전의 SJF입니다.
- SJF는 긴 작업이 먼저 실행되면 이후에 도착한 짧은 작업이 **기다려야** 하지만,
- SRF는 더 짧은 작업이 오면 **실행 중인 프로세스를 중단하고 교체**하기 때문에 **응답 시간이 짧아지고 평균 대기 시간이 줄어듭니다**.
- 단, **컨텍스트 스위칭이 잦아** 비용이 증가할 수 있습니다.

### 🔸 Q5. 다단계 큐(Multilevel Queue) 스케줄링의 특징과 단점은?

**답변:**
- 다단계 큐는 **프로세스를 우선순위별로 여러 큐에 나누고**, 각 큐에 **서로 다른 스케줄링 알고리즘**을 적용하는 방식입니다.
- 예) 시스템 프로세스는 FCFS, 상호작용 프로세스는 SJF, 배치 작업은 RR로 처리.

**장점:**

* 역할과 중요도에 따라 적절한 자원 할당 가능
* 각 큐가 독립적으로 운영돼 관리 용이

**단점:**

* 큐 간 이동이 불가하면 **유연성이 떨어짐**
* 낮은 우선순위 큐는 기아(starvation) 상태가 생길 수 있음

### 🔸 Q6. 선점형 스케줄링은 왜 컨텍스트 스위칭 비용이 크고, 이를 어떻게 줄일 수 있을까요?

**답변:**
- 선점형에서는 **프로세스를 강제로 중단**하고 다른 프로세스로 전환하는 과정에서 레지스터, 캐시, 프로그램 카운터 등을 저장/복원해야 하므로 **컨텍스트 스위칭 비용**이 발생합니다.
- 이때 **캐시 미스, TLB flush** 등의 부하도 함께 발생합니다.
- 이를 줄이기 위해:
  * **타임 쿼텀을 조절**해 스위칭 빈도 감소
  * **스레드 기반 처리**로 전환 (스택만 독립)
  * **비동기 이벤트 기반 처리 (Reactive)** 구조 도입

### 🔸 Q7. 웹 서버 개발자로서 CPU 스케줄링을 고려한 비동기 처리 전략에는 어떤 것이 있나요?

**답변:**
- 웹 서버는 **다수의 요청에 빠르게 응답**하는 것이 중요하므로, 프로세스 단위 처리보다는 **스레드나 이벤트 루프 기반** 처리가 유리합니다.
- 예를 들어:
  * Java: `CompletableFuture`, `WebFlux`, `ExecutorService`로 비동기 처리
  * Node.js: Event loop 기반
  * 요청을 스레드 풀에 태스크로 할당해 병렬 처리

이러한 구조는 **CPU 자원을 효율적으로 사용**하며, I/O 대기 중인 작업을 블로킹하지 않으므로 **응답성을 향상**시킬 수 있습니다.

### 🔸 Q8. 우선순위 스케줄링에서 starvation 문제를 해결하려면?

**답변:**
- starvation은 낮은 우선순위 작업이 영원히 실행되지 않는 현상입니다. 이를 방지하기 위해 **aging** 기법을 사용합니다.
- 시간이 지날수록 프로세스의 우선순위를 점진적으로 높여 결국은 실행되도록 보장하는 방식입니다.

---
## ✅ 심화 질문과 답변

### 💡 Q1. 프로세스와 스레드의 차이를 설명해보세요. 왜 웹 서버는 멀티스레드 구조를 채택하나요?

**답변:**

* **프로세스**는 메모리 공간과 자원을 독립적으로 갖는 실행 단위이고,
  **스레드**는 같은 프로세스 내에서 자원을 공유하면서 실행되는 작은 단위입니다.
* **웹 서버**는 수많은 요청을 빠르게 처리해야 하므로, 프로세스를 여러 개 만드는 것보다
  **경량인 스레드를 생성**하여 CPU와 메모리를 아끼고, **컨텍스트 스위칭 비용도 줄일 수 있습니다.**


### 💡 Q2. JVM에서 GC와 OS의 스와핑이 동시에 일어나면 무슨 일이 생기고, 어떻게 해결할 수 있을까요?

**답변:**

* GC는 메모리에서 많은 객체를 탐색하고 정리하는 작업인데,
  이때 OS가 일부 힙 메모리를 디스크로 **스와핑**하면 GC가 느려집니다.
* GC가 지연되면 애플리케이션이 멈추고, **서버 응답 지연이나 중단**이 발생할 수 있습니다.
* 해결책은:

  * JVM 힙 크기 조절 및 GC 정책(G1GC 등) 변경
  * 메모리 프로파일링을 통한 누수 탐지
  * **Redis 캐시 도입**으로 힙 부담 분산
  * OS 설정에서 `vm.swappiness` 값을 낮춰 스와핑 억제


### 💡 Q3. 스레싱(Thrashing)이 무엇이며, 서버 운영 중 이를 어떻게 감지하고 대응하나요?

**답변:**

* **스레싱**은 페이지 폴트가 너무 자주 일어나 **CPU보다 디스크 작업이 많아지는 현상**입니다.
* 원인은 메모리 과부하로 인해 스와핑이 반복되는 것이고, 서버는 점점 느려지다 멈출 수 있습니다.
* 감지 방법:

  * `vmstat`, `top`, `iostat` 명령어로 **페이지 폴트 수나 CPU idle 시간 확인**
* 대응:

  * **불필요한 프로세스 종료**, 캐시 조정, 메모리 증설
  * **작업 세트(Working Set)** 조정
  * 클라우드 환경이면 **스케일 업 or 아웃**


### 💡 Q4. 웹 서버에서 비동기 프로그래밍을 도입할 때 운영체제 관점의 이점은?

**답변:**

* 동기 방식은 요청마다 스레드 1개를 고정 배정해야 하므로, 동시 요청이 많으면 스레드 부족 발생
* 반면 비동기는 **I/O 작업이 발생하면 스레드를 반납**하고, 완료 이벤트로 이어서 작업
* OS 입장에서는 스레드 수가 줄어 **컨텍스트 스위칭 비용 감소**, 메모리 절약
* 실전에서는 `CompletableFuture`, `Netty`, `Spring WebFlux` 등의 기술을 활용함


### 💡 Q5. LRU 알고리즘은 왜 캐시에서 많이 쓰이고, 이를 Redis에서 구현하려면 어떤 설정이 필요한가요?

**답변:**

* LRU(Least Recently Used)는 가장 오래 사용하지 않은 데이터를 제거해
  **자주 사용하는 데이터를 최대한 캐시에 유지**하려는 전략입니다.
* Redis에서는 `maxmemory-policy` 설정을 `allkeys-lru`로 지정하면
  전체 키에 대해 LRU 알고리즘이 적용됩니다.
* 또한 TTL과 함께 사용하면 **오래된 데이터 + 일정 시간 지난 데이터**를 효율적으로 제거할 수 있습니다.


### 💡 Q6. JVM에서 OutOfMemoryError가 잦을 때 Redis 캐시로 해결할 수 있는 이유는?

**답변:**

* **자주 조회되는 대용량 데이터를 JVM 힙이 아닌 Redis에 보관**하면 힙 사용량이 줄고
  GC 빈도도 감소해서 성능이 좋아집니다.
* Redis는 메모리 기반 DB라서 **응답 속도가 빠르고 TTL 설정도 가능**하므로
  캐시 관리 및 무효화 정책도 유연하게 운영할 수 있습니다.
* 단, **캐시 미스율이 높으면 오히려 성능 저하**가 생기므로 캐시 적중률 모니터링이 필요합니다.


### 💡 Q7. 서버에서 "Zombie JVM" 현상은 무엇이며, 운영체제 관점에서 어떻게 탐지할 수 있나요?

**답변:**

* Zombie JVM은 **JVM 프로세스가 살아있지만 정상 동작하지 않는 상태**를 의미합니다.
  예: GC 무한 반복, 스레드 데드락, 응답 없음 등
* 탐지:

  * `top`, `ps`, `jstack`, `jstat`, `jmap` 등으로 CPU 사용률, GC 상태, 스레드 덤프 분석
* 대응:

  * **JVM 헬스 체크** 로직 구현 (`/health`, `/actuator`)
  * 비정상 탐지 시 자동 재시작하는 **Process Manager(PM2, systemd)** 연동