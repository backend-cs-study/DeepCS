# 3.1 운영체제와 컴퓨터
- 운영체제(OS, Operating System) : 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스
- 한정된 메모리나 시스템 자원을 효율적으로 분배하는 참된 일꾼
- 펌웨어(firmware) : 운영체제와 유사하지만 소프트웨어를 추가로 설치할 수 없는 것

# 3.1.1 운영체제의 역할과 구조

## 운영체제의 역할
1. CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리
2. 메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리
3. 디스크 파일 관리 : 디스크 파일을 어떠한 방법으로 보관할지 관리
4. I/O 디바이스 관리 : I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리

## 운영체제의 구조
- 유저 프로그램
- *인터페이스(GUI, CUI)
- *시스템콜
- *커널(드라이버, 파일 시스템 등)
- 하드웨어
- 여기서 * 표시된 부분이 운영체제를 지징함
- GUI가 없고 CUI만 있는 리눅스 서버도 있음

✔️ 용어 <br>
- GUI : 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태,
  - 단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호 작용할 수 있도록 해준다.
- 드라이버 : 하드웨어를 제어하기 위한 소프트웨어
- CUI : 그래픽이 아닌 명령어로 처리하는 인터페이스

### 시스템콜
- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용
- 유저 프로그램이 I/O 요청으로 트랩(trap)을 발동하면
  - 올바른 I/O 요청인지 확인한 후
  - 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행됨
- ex) I/O 요청인 fs.readFile()이라는 파일 시스템의 파일을 읽는 함수가 발동
  - 이 때 유저 모드에서 파일을 읽지 않고
  - 커널 모드로 들어가 파일을 읽고
  - 다시 유저 모드로 돌아가
  - 그 뒤에 있는 유저 프로그램의 로직을 수행함
  - 이 과정을 통해 컴퓨터 자원에 대한 직접 접근을 차단 가능,
  - 프로그램을 다른 프로그램으로부터 보호 가능

✔️ 용어 <br>
- I/O 요청 : 입출력 함수, 데이터베이스, 네트워크, 파일 접근 등에 관한 일
- 드라이버 : 하드웨어를 제어하기 위한 소프트웨어

✔️ 시스템콜과 커널, 운영체제
- 프로세스나 스레드에서 운영체제로 어떠한 요청을 할 때 
  - 시스템콜이라는 인터페이스와 커널을 거쳐 운영체제에 전달됨
- 이 시스템콜은 하나의 추상화 계층임
  - 장점 : 이를 통해 네트워크 통신이나 데이터베이스와 같은 
    - 낮은 단계의 영역 처리에 대한 부분을 많이 신경 쓰지 않고 프로그램 구현 가능

#### modebit
- 시스템콜이 작동될 떄 modebit을 참고해서 유저 모드와 커널 모드 구분함
- modebit : 1 또는 0의 값을 가지는 플래그 변수
- 카메라, 키보드 등 I/O 디바이스는 운영체제를 통해서만 작동해야 함
- ex) 카메라를 켜는 프로그램
  - IF) 유저 모드를 기반으로 카메라가 켜진다면,
    - 사용자가 의도하지 않았는데 공격자가 카메라를 갑자기 켤 수 있는 등 나쁜 짓 하기 쉬움
- 물론 커널 모드를 거쳐 운영체제를 통해 작동한다고 해도 100% 막을 수는 없지만,
  - 운영체제를 통해 작동하게 해야 막기가 쉬움
- 이를 위한 장치가 modebit
- modebit의 0은 커널 모드, 1은 유저 모드라고 설정됨

✔️ modebit의 역할
- 유저 프로그램이 카메라를 이용하려고 할 때
  - 시스템콜을 호출하고 modebit을 1에서 0으로 바꾸며 커널 모드로 변경한 후
    - 카메라 자원을 이용한 로직을 수행함
    - 그 이후에 modebit을 0에서 1로 바꿔서 유저 모드로 변경하고 이후 로직을 수행함

✔️ 용어 <br>
- 유저 모드 : 유저가 접근할 수 있는 영역을 제한적으로 두며 
  - 컴퓨터 자원에 함부로 침범하지 못하는 모드
- 커널 모드 : 모든 컴퓨터 자원에 접근할 수 있는 모드
- 커널 : 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며
  - 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등
    - 운영체제의 중추적인 역할을 함

---
# 3.1.2 컴퓨터의 요소
- CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이루어짐

## CPU(Central Processing Unit)
- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치
  - 인터럽트에 의해 단순히 메모리에 존재하는 명령어르 ㄹ해석해서 실행하는 일꾼

✔️ CPU라는 일꾼 <br> 
- 관리자 역할을 하는 운영체제의 커널이 프로그램을 메모리에 올려 프로세스로 만들면
  - 일꾼인 CPU가 이를 처리함

### 제어장치(CU, Control Unit)
- 프로세스 조작을 지시하는 CPU의 한 부품
- 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며
  - 데이터 처리를 위한 순서를 결정함

### 레지스터
- CPU 안에 있는 매우 빠른 임시기억장치
- CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 수십 배에서 수백 배까지 빠름
- CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에
  - 레지스터를 거쳐 데이터를 전달함

### 산술논리연산장치(ALU, Arithmetic Logit Unit)
- 덧셈, 뺄셈 같은 두 숫자의 산술 연살과 
  - 배타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로

#### CPU의 연산 저리
1. 제어장치가 메모리에 계산할 값을 로드, 또한 레지스터에도 로드
2. 제어장칠가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령
3. 제어장치가 계산된 값을 다시 '레지스터에서 메모리로' 계산한 값을 저장

### 인터럽트

✔️ 용어 <br>
- 인터럽트 핸들러 함수 : 인터럽트가 발생했을 때 이를 핸들링하기 위한 함수.
  - 커널 내부의 IRQ를 통해 호출되며 request_irq()를 통해 인터럽트 핸들러 함수를 등록 가능

#### 하드웨어 인터럽트
- 키보드를 연결한다거나 마우스를 연결하는 일 등의 IO 디바이스에서 발생하는 인터럽트
- 이때 인터럽트 라인이 설계된 이후 순차적인 인터럽트 실행을 중지하고 
  - 운영체제에 시스템콜을 요청해서
    - 원하는 디바이스로 향해 디바이스에 있는 작은 로컬 버퍼에 접근하여 일 수행

#### 소프트웨어 인터럽트
- 트랩(trap)이라고도 함
- 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동함

## DMA 컨트롤러
- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
- CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에
  - CPU 부하를 막아주며
  - CPU의 일을 부담하는 보조 일꾼
- 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지

## 메모리(memory)
- 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치
- 보통 RAM(Random Access Memory)을 일컬어 메모리라고도 함
- CPU는 계산을 담당하고, 메모리는 기억을 담당
- ex) 공장에 비유
  - CPU는 일꾼 / 메모리는 작업장
    - 작업장의 크기가 곧 메모리의 크기
    - 작업장이 클수록 창고에서 물건을 많이 가져다놓고 많은 일을 할 수 있듯이
      - 메모리가 크면 클수록 많은 일을 동시에 가능

## 타이머(timer)
- 몇 초 안에는 작업이 끝나야 한다는 것을 정하고
  - 특정 프로그램에 시간 제한을 다는 역할
  - 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재함

## 디바이스 컨트롤러(device controller)
- 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU
  - 옆에 붙어 있는 로컬 버퍼는 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리

---
## ✅ 기본 질문과 답변


### 🔹 Q1. 운영체제에서 시스템콜이란 무엇인가요? 백엔드와 어떤 관련이 있나요?

* **A.**
시스템콜은 **유저 프로그램이 커널의 기능을 요청할 수 있는 인터페이스**입니다.
예를 들어, 백엔드 서버에서 파일을 읽거나 네트워크로 데이터를 보내는 작업은 단순 함수 호출이 아니라 내부적으로 시스템콜을 통해 커널 모드에서 수행됩니다.

* 예시: Java의 `File.read()` → 내부적으로는 `read()` 시스템콜 호출
* 이는 **보안**과 **안정성**을 위해 직접 하드웨어 접근을 막고 커널이 대신 처리해주는 구조입니다.



### 🔹 Q2. 운영체제의 모드비트(modebit)의 역할은 무엇인가요?

* **A.**
모드비트는 현재 CPU가 **유저 모드**인지 **커널 모드**인지를 구분하는 \*\*플래그 값(1비트)\*\*입니다.

* 유저 모드에서는 직접 하드웨어를 조작할 수 없고,
* 시스템콜을 통해 커널 모드로 진입해야 하드웨어 리소스를 사용할 수 있습니다.

이 구조 덕분에 **멀웨어나 악성 코드가 카메라·키보드 등 디바이스를 직접 제어하지 못하도록 보호**할 수 있습니다.



### 🔹 Q3. 인터럽트란 무엇이고, 하드웨어 인터럽트와 소프트웨어 인터럽트의 차이는?

* **A.**
인터럽트는 현재 CPU 작업을 **중단하고 외부 요청에 대응하는 신호**입니다.

* **하드웨어 인터럽트**: 키보드 입력, 마우스 클릭 등 물리적 장치에서 발생
* **소프트웨어 인터럽트**(= 트랩): 예외 상황(예: 0으로 나누기)이나 시스템콜 요청 시 발생

서버 운영 중에도 예외나 I/O 요청을 효과적으로 처리하려면 인터럽트를 적절히 이해하고 핸들링하는 것이 중요합니다.



### 🔹 Q4. DMA 컨트롤러는 무엇이며 왜 필요할까요?

* **A.**
DMA(Direct Memory Access) 컨트롤러는 I/O 장치가 **CPU를 거치지 않고 메모리에 직접 접근할 수 있게 도와주는 하드웨어**입니다.

* 많은 I/O가 발생하는 백엔드 환경에서 CPU에 과부하를 주지 않고 효율적인 데이터 처리를 가능하게 합니다.
* 예: 대용량 로그 파일을 디스크에서 메모리로 옮길 때 CPU 대신 DMA가 처리



### 🔹 Q5. 레지스터는 왜 필요한가요? 메모리와의 차이는?

* **A.**
레지스터는 **CPU 내부에 있는 가장 빠른 저장소**입니다.
메모리는 속도가 상대적으로 느려, 계산에 바로 사용되기 위해선 데이터를 레지스터에 먼저 로드해야 합니다.

* **레지스터**: 계산용 데이터 저장 (예: A + B 계산 시 A, B를 임시로 저장)
* **메모리**: 작업장 역할, 실행 중인 코드/데이터 저장
* 실무에서는 CPU 캐시 히트율이나 메모리 레이아웃 최적화에 관여할 수 있습니다.



### 🔹 Q6. 운영체제가 메모리를 관리한다는 것은 구체적으로 어떤 일을 하나요?

* **A.**
운영체제는 **메모리 공간을 어떤 프로세스에 얼마나, 언제 할당하고 해제할지 결정**합니다.
이는 메모리 누수, 충돌, 과도한 할당 등 오류를 방지하기 위해 필수적입니다.

* 백엔드 서버에서 GC(가비지 컬렉션), OutOfMemory 오류 등이 발생했을 때
  → 메모리 관리 방식 이해가 문제 해결에 도움 됩니다.



### 🔹 Q7. 커널과 드라이버는 어떤 관계인가요?

* **A.**

* **커널**: 운영체제의 핵심, 시스템콜과 자원 관리 담당
* **드라이버**: 커널의 하위 모듈로, 하드웨어 제어를 담당하는 소프트웨어

예를 들어, 백엔드에서 외장 SSD를 연결할 때 드라이버가 없다면 장치를 인식조차 못합니다.



### 🔹 Q8. 타이머(timer)는 어떤 용도로 사용되나요?

* **A.**
운영체제는 타이머를 통해 **프로세스 시간 제한**을 설정합니다.
예를 들어, 하나의 요청이 너무 오래 걸린다면 CPU를 양보하고 다른 요청으로 전환해야 합니다.

* 백엔드 예시: WAS의 요청 타임아웃 설정, 타이머 인터럽트 기반 스레드 전환 등



### 🔹 Q9. 시스템콜을 사용하지 않고 직접 하드웨어를 접근하면 왜 위험한가요?

* **A.**
시스템콜 없이 하드웨어에 접근하면 보안 위험이 발생합니다.
예를 들어, 악성 코드가 유저 모드에서 카메라를 켜거나 데이터를 무단 복사할 수 있습니다.

modebit과 시스템콜을 통해서만 커널 자원에 접근하도록 제한함으로써
**보안성 확보**와 **자원 보호**가 가능해집니다.



### 🔹 Q10. 운영체제가 없으면 프로그램이 어떻게 실행되나요?

* **A.**
운영체제가 없다면, 각각의 프로그램이 직접 하드웨어 제어, 메모리 할당, I/O 처리를 해야 합니다.
이는 매우 비효율적이고 위험하며, 프로그램 간 충돌이나 자원 중복이 빈번하게 발생합니다.

운영체제가 중간에 있어 **표준화된 방식으로 자원을 분배**하므로 개발자와 프로그램이 쉽게 컴퓨터를 사용할 수 있습니다.

---
## ✅ 심화 질문과 답변

### 🔹 Q1. 시스템콜은 언제 오버헤드가 발생하나요? 이를 줄이기 위한 방법은?

**심화 포인트:**

* 시스템콜은 유저 모드 ↔ 커널 모드 전환이 발생하므로 문맥 전환 비용이 큽니다.
* 대량의 I/O 호출(예: 수많은 작은 파일 읽기)이 반복되면 오버헤드 증가.

**백엔드 연계:**

* 예) 로그 수집기, REST API 다중 호출 → `epoll`, `sendfile()` 등 커널 기반 호출 최적화 고려.



### 🔹 Q2. 프로세스와 스레드의 차이를 설명하되, Node.js나 Spring에서 어떻게 쓰이는지 예시로 말해보세요.

**심화 포인트:**

* 프로세스: 메모리 독립 / 스레드: 메모리 공유
* Node.js는 단일 스레드 기반이지만, 비동기 이벤트 루프를 사용하여 다중 요청을 처리함.
* Spring은 기본적으로 스레드 풀로 요청을 처리하며, 설정 변경으로 병렬 처리량 조절 가능.



### 🔹 Q3. 백엔드에서 I/O Block이 발생했을 때 어떤 방식으로 대응하는 게 적절한가요?

**심화 포인트:**

* Blocking I/O는 스레드를 점유하여 처리 효율이 낮아짐.
* 해결 방법:

  * Java NIO (논블로킹 방식)
  * `CompletableFuture`, `WebFlux`, `Reactor` 등 리액티브 프로그래밍 사용
  * 또는 아예 큐(메시지 브로커 등)를 두어 비동기 처리



### 🔹 Q4. 커널 공간과 유저 공간의 메모리 구분은 왜 필요한가요? 백엔드 개발에선 어떤 영향을 미치나요?

**심화 포인트:**

* 구분하지 않으면 프로세스가 시스템 전체 자원에 접근 가능 → 보안, 안정성 문제
* 예: Java Native Interface(JNI) 사용 시 커널 영역 메모리 접근 주의
* 파일 캐싱 등 커널 영역 동작이 성능에 영향을 주기도 함 (예: page cache)



### 🔹 Q5. context switching이 잦아질 때 어떤 현상이 발생하나요? 백엔드에서 이를 어떻게 조절할 수 있을까요?

**심화 포인트:**

* 잦은 문맥 전환은 CPU 캐시 손실, 스케줄러 부하 초래
* 백엔드 서버는 스레드 수를 제한하거나 thread pool 사이즈를 조절하여 컨텍스트 스위칭 최소화 가능



### 🔹 Q6. HTTP 요청 처리 시 커널 모드가 어떤 식으로 동작하는지 설명해보세요

**심화 포인트:**

1. HTTP 요청 수신
2. NIC(네트워크 카드) 인터럽트 → 커널이 패킷 수신
3. 커널 네트워크 스택 처리
4. 시스템콜을 통해 유저 영역으로 전달 (`read()`, `recv()` 등)

**코드 기반 예시 (Java):**

```java
BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
String requestLine = in.readLine();  // 내부적으로 read() 시스템콜
```



### 🔹 Q7. 하나의 CPU에서 여러 스레드를 동시에 실행하는 건 가능한가요?

**심화 포인트:**

* 진짜 병렬 처리 불가 → 문맥 전환을 통해 번갈아 처리
* 다중 코어 환경 + 스레드 수 설정이 병렬성에 영향을 줌

**백엔드 연계:**

* CPU 코어 수보다 많은 스레드가 있을 때 thread starvation, race condition 등 위험 발생 가능
* 적절한 스레드 풀 사이즈와 동기화 전략 필요



### 🔹 Q8. SIGTERM, SIGKILL 차이를 설명하고 백엔드에서 graceful shutdown을 위해 어떤 처리가 필요한지 설명하세요.

**심화 포인트:**

* SIGTERM: 종료 요청 → 종료 전 정리 가능
* SIGKILL: 강제 종료 → 리소스 누수 가능

**백엔드 대응:**

* Spring Boot 예시: `@PreDestroy`
* 서버 종료 전 DB 커넥션 반환, 로그 플러시 등 처리
* Kubernetes 환경에서는 `terminationGracePeriodSeconds` 설정 고려



### 🔹 Q9. 커널 스케줄링 정책에 따라 서버 응답에 차이가 날 수 있나요?

**심화 포인트:**

* 스케줄러 정책 (ex: CFS, FIFO, RR)에 따라 프로세스 우선순위나 CPU 점유 시간 차이 발생
* 부하가 심한 시스템에서 서버 프로세스의 응답 지연 가능

**백엔드 연계:**

* 중요 프로세스 `nice` 값 조절
* `top`, `htop`, `taskset`, `nice` 명령어로 우선순위 관리



### 🔹 Q10. 서버가 과도하게 많은 요청을 받았을 때 OOM(Out of Memory)가 발생했어요. 운영체제 입장에서 어떤 일이 벌어지나요?

**심화 포인트:**

* 메모리 부족 시 OOM Killer가 실행 → 가장 메모리 많이 쓰는 프로세스 종료
* 백엔드 프로세스 종료로 인해 서버 중단

**백엔드 대응:**

* JVM 힙 사이즈 조절 (`-Xmx`)
* `ulimit`, swap, cgroup 등을 활용한 메모리 제한 설정
* 요청 제한(Rate Limiting), 백프레셔(backpressure) 적용