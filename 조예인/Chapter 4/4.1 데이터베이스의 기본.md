# 4.1 데이터베이스의 기본
- 데이터베이스(DB, DataBase) : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음 
- DBMS(DataBase Management System) : 해당 데이터베이스를 제어, 관리하는 통합 시스템
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있음 
- 또한, 데이터베이스는 실시간 접근과 동시 공유가 가능함

✔️ 데이터베이스와 DBMS  <br>
- 응용 프로그램 <-> DBMS <-> 데이터베이스
- 데이터베이스 위에 DBMS가 있고 그 위에 응용 프로그램이 있으며, 이러한 구조를 기반으로 데이터를 주고받음
- ex) MySQL이라는 DBMS가 있고 그 위에 응용 프로그램에 속하는 Node.js나 php에서 해당 데이터베이스 안에 있는 데이터를 끄집어내 해당 데이터 관련 로직 구축가능

---

# 4.1.1 엔터티
- 엔터티(entity) : 사람, 장소, 물건, 사전, 개념 등 여러 개의 속성을 지닌 명사를 의미함
- ex) 회원이라는 엔터티가 있다고 해봅시다. 회원은 이름. 아이디. 주소, 전화번호의 속성을 갖겠죠?

✔️ 엔터티 <br>
- 회원 
  - 이름 아이디 주소 전화번호
- 물론 이보다 많은 속성이 있지만 서비스의 요구 사항에 맞춰 속성이 정해짐
- ex) 주소라는 속성이 서비스의 요구 사항과 무관한 속성이라면 주소라는 속성은 사라지게 됨

## 약한 엔터타와 강한 엔터티
- 엔터티는 약한 엔터티와 강한 엔터티로 나뉨 
- ex) A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 
  - A는 약한 엔터티이고 B는 강한 엔터티가 됨 
- ex) 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티, 건물을 강한 엔터티

---

# 4.1.2 릴레이션(relation)
- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리함

✔️ 릴레이션 <br>
- 회원이라는 엔터티가 데이터베이스에서 관리될 때 릴레이션으로 변화 된 것을 볼 수 있음 
- 릴레이션은 관계형 데이터베이스에서는 '테이블'이라고 하며, NoSQL 데이터베이스에서는'컬렉션'이라고 함

## 테이블과 컬렉션
- 데이터베이스의 종류 : 관계형 데이터베이스, NoSQL 데이터베이스 
- 이 중 대표적인 관계형 데이터베이스인 MySQL과 대표적인 NoSQL 데이터베이 스인 MongoDB를 예로 들면, 
  - MySQL의 구조는 레코드-테이블-데이터베이스로 이루어져 있고 
  - MongoDB 데이터베이스의 구조는 도큐먼트-컬렉션-데이터베이스로 이루어져 있음

✔️ 레코드-테이블-데이터베이스의 구조 <br>
- 레코드가 쌓여서 테이블이 되고 테이블이 쌓여서 데이터베이스가 되는 것

---

# 4.1.3 속성(attribute) 
- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보 
- ex) '차'라는 엔터티의 속성을 뽑아보기 -> 차 넘버, 바퀴 수, 차 색깔, 차종 등
  - 이 중에서 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 됨

---

# 4.1.4 도메인(domain)
- 릴레이선에 포함된 각각의 속성들이 가질 수 있는 값의 집합
- ex) 성벌이라는 속성이 있다면 이 속성이 가질 수 있는 값은 {남, 여}라는 집합이 됨

✔️ 속성과 도메인  <br>
- 회원이라는 릴레이션에 이름, 아이디, 주소, 전화번호, 성별이라는 속성이 있고 
- 성별은 (남, 여}라는 도메인을 가지는 것을 알 수 있음

---

# 4.1.5 필드와 레코드
- 앞에서 설명한 것들을 기반으로 데이터베이스에서 필드와 레코드로 구성된 테이블을 만들 수 있음

✔️ 필드와 레코드 <br>
- 회원이란 엔터티는 member라는 테이블로 
  - 속성인 이름, 아이디 등을 가지고 있으며 name, ID, address 등의 필드를 가짐
  - 그리고 이 테이블에 쌓이는 행(row) 단위의 데이터를 레코드라고 함 
  - 또한, 레코드를 튜플이라고도 함
- ex) '책이라는 엔터티를 정의하고 이를 기반으로 테이블 생성
  - 먼저 어떠한 속성들이 있을까요? 책의 제목, 책의 가격, 책의 ISBN, 책의 저자, 책의 출판 년도 등
    - 일단 수많은 '속성' 중에서 이름, 저자의 아이디, 출판년도, 장르, 생성 일시, 업데이트 일시만 있다고 가정 
  - 이 엔터티를 데이터베이스에 넣어 테이블로 만틀려면
    - 이 속성에 맞는 타입을 정의해야 함 
    - 참고로 타입은 MongoDB나 MySQL 등 데이터베이스마다 조금씩 차이가 있는데 MySQL을 기준으로 설명함
      - 책의 아이디: INT 
      - 책의 제목: VARCHAR(255)
      - 책의 저자 아이디: INT
      - 책의 출판년도: VARCHAR(255)
      - 책의 장르: VARCHAR(255) 
      - 생성 일시:DATETIME 
      - 업데이트 일시: DATETIME
  - 각 속성에 맞는 타입을 정의함
  - 이를 테이블로 만들면 다음과 같음
  
✔️ book 테이블  <br>
- book
  - id INT
  - title VARCHAR(2S5)
  - author_id INT
  - publishing_year VARCHAR(255)
  - genre VARCHAR(255)
  - created_at DATETIME
  - updated_at DATETIME
  
- 보통 책의 작목, 책의 출판년도처럼 한글을 속성 이름으로 쓰지 않음 
  - title, author_id 등으로 영어 이름에 매핑해서 쓰며 
  - 앞서 설명한 속성과 타입들이 들어간 것을 불 수 있음

- 참고로 앞의 테이블을 MySQL로 구헌하려면 다음과 같은 코드를 입력하면 됨
- SQL
  - CREATE TABLE book( 
    - id INT NOT NULL AUTO_INCREMENT, 
    - title VARCHAR(255), 
    - author_id INT, 
    - publishing_year VARCHAR(255), 
    - genre VARCHAR(255), 
    - created_at DATETIME, 
    - updated_at DATETIME,
    - PRIMARY KEY (id)
  - );

## 필드 타입
- 필드는 타입을 가짐
- ex) 이름은 문자열이고 전화번호는 숫자겠죠? 
  - 이러한 타입들은 DBMS마다 다르며 이 책에서는 MySQL을 기준으로 설명하겠음
- 여러 가지 타입이 있고 대표적인 타입인 숫자, 날짜, 문자 타입에 대해 알아보겠음

### 숫자 타입
- 숫자 타입으로는 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있음

✔️ MySQL 숫자 타입  <br>
- 타입 용량(바이트) 최숫값(부호 있음) 최솟값(부호 없음) 최댓값(부호 없음) 최댓값(부호 있음) 
- TINYINT 1 -128 0 127 255 
- SMALLINT 2 -32768 0 32767 65535 
- MEDIUMINT 3 -8388608 0 8388607 
- INT 4 -2147483648 0 2147483647 4294967295
- BIGINT 8 -263 0 263-1 264-1

### 날짜 타입 
- 날짜 타입으로는 DATE, DATETIME, TIMESTAMP 등이 있음

#### DATE 
- 날짜 부분은 있지만 시간 부분은 없는 값에 사용됨 
- 지원되는 범위는 1000-01-01~9999-12-31 
- 3바이트의 용량을 가짐

#### DATETIME 
- 날짜 및 시간 부분을 모두 포함하는 값에 사용됨
- 지원되는 범위는 1000-01-01 00:00:00에서 9999-12-31 23:59:59 
- 8바이트의 용량을 가짐

#### TIMESTAMP
- 날짜 및 시간 부분을 모두 포함하는 값에 사용됨
- 1970-01-01 00:00:01에서 2038-01-19 03:14:07까지 지원함 
- 4바이트의 용량을 가짐

### 문자 타입
- 문자 타입으로는 CHAR, VARCHAR, TEXT, BLOB, ENUM. SET이 있음

#### CHAR와 VARCHAR
- CHAR 또는 VARCHAR 모두 그 안에 수를 입력해서 몇 자까지 입력할지 정함 
  - ex) CHAR(30)이라면 최대 30글자까지 입력할 수 있음
- CHAR : 고정 길이 문자열
  - 길이는 0에서 255 사이의 값을 가짐 
  - 레코드를 저장 할 때 무조건 선언한 길이 값으로 '고정해서 저장됨
  - ex) CHAR(100)으로 선언한 후 10글자를 저장해도 100바이트로 저장되게 됨 
- VARCHAR : 가변 길이 문자열 
  - 길이는 0에서 65,535 사이의 값으로 지정가능 
  - 입력된 데이터에 따라 용량을 가변시켜 저장함 
  - ex) 10글자의 이메일을 저장할 경우 VARCHAR(10000) 선언했음에도 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 됨
- 그렇기 때문에 CHAR의 경우 유동적이지 않은 길이를 가진 데이터의 경우에 효율적이며, 유동적인 길이물 가진 데이터는 VARCHAR로 저장하는 짓이 좋음

#### TEXT와 BLOB 
- 두 개의 타입 모두 큰 데이터를 저장할 때 쓰는 타입 
- TEXT : 큰 문자열 저장에 쓰며 주로 게시판의 본문을 저장할 때 사용
- BLOB : 이미지. 동영상 등 큰 데이터 저장에 사용 
  - 그러나 보통은 아마존의 이미지 호스팅 서비스인 S3를 이용하는 등 서비에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장함

#### ENUM SET
- ENUM과 SET 모두 문자열을 열거한 타입
- ENUM : ENUM('x-small','small', 'medium', 'large', `x-large) 형태로 쓰이며, 
  - 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됨
  - ENUM을 이용하면 x-small 등이 0, 1 등으로 매핑되어 메모리를 적게 사용하는 이점을 얻음
  - ENUM은 최대 65,535개의 요소들을 넣을 수 있음
- SET : ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다름 
- 참고로 ENUM이나 SET을 쓸 경우 공간적으로 이점을 볼수 있지만 
  - 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야 한다는 단점이 있음

---

# 4.1.6 관계 
- 데이터베이스에 테이블은 하나만 있는 것이 아님
- 여러 개의 테이블이 있고 이리한 테이블은 서로의 관계가 정의되어 있음
- 이러한 관계를 관계화살표로 나타냅니다.

✔️ 관계화살표  <br>
- 하나의 A는 하나의 B로 구성되어 있다
- 하나의 A는 하나 이상의 B로 구성되어 있다 
- 하나의 A는 하나 이하의 B로 구성되어 있다
- 하나의 A는 0 또는 하나 이상의 B로 구성되어 있다

## 1:1관계
- ex) 유저당 유저 이메일은 한 개씩 있겠죠? 
- 이 경우 1:1 관계가 됨
- 1:1 관계는 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어줌

## 1:N 관계
- ex) 쇼핑몰을 운영한다고 해봅시다. 
  - 한 유저당 여러 개의 상품을 장바구니에 넣을 수 있겠죠?
  - 이 경우 1:N 관계가 됨
  - 물론 하나도 넣지 않는 0개의 정우도 있으니 0도 포함되는 화살표를 통해 표현해야 함
- 이렇게 한 개체가 다른 많은 개체를 포함하는 관계를 말함

## N:M관계
- 학생과 강의의 관계를 정의하면 어떻게 될까요? 
  - 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있음 
  - 이 경우 N:M이 됩니다.
- 중간에 학생 강의라는 테이블이 끼이 있음 
- N:M은 테이블 두 개를 직접적 으로 연결해서 구축하지는 않고 
- 1:N, 1:M이라는 관계를 찾는 테이블 두 개로 나눠서 설정함

---

# 4.1.7 키 
- 테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인맥스를 위해 설정된 장치
- 기본키. 외래키, 후보키, 슈퍼키. 대체키가 있음

✔️ 키간의 관계 <br>
- 슈퍼키는 유일성이 있고 
- 그 안에 포함된 후보키는 최소성까지 갖춘 키 
- 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 됨
- 유일성은 중복되는 값은 없으며, 
- 최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것을 말함

## 기본키(Primary Key)
- 줄여 PK 또는 프라이머리키라고 많이 부르며,
- 유일성과 최소성을 만족하는 키

✔️ 기본키가 안 되는 키  <br>
- ID nаmе 
  - PDT-00O1> 홍철이의 따스한 점퍼 
  - PDT-0002> 제호의 BMW 
  - PDT-00O2> 제호의 BHW X
  - PDT-0003> 종선이의 벤츠
- 이는 테이블의 데이터 중 소유하게 존재하는 속성이며 
- 기본키에 해당하는 데이터는 앞의 그림의 ID처럼 중복되어서는 안됨
- PDT-0002가 중복되기 때문에 ID라는 필드는 기본키가 되지 말아야 함

✔️ 기본키가 되는 키  <br>
- ID nаmе 
  - 1 주홍천 
  - 2 주홍철 
  - 3 최범석 
  - 4 양기영
- 앞의 그림에서 ID는 기본키로 설정할 수 있겠죠? 
- 물론 {ID, name}이라는 복합키를 기본키로 설정할 수 있지만 그렇게 되면 최소성을 만족하지 않음
- 기본키는 자연키 또는 인조키 중에 골라 설정함

### 자연키
- ex) 유저 테이블을 만든다고 가정하면 
- 주민등록번호, 이름, 성별 등의 속성이 있음
- 이 중 이름, 성별 등은 중복된 값이 들어올 수 있으므로 부적절하고 
- 남는 것은 주민등록번호임 
- 이런 식으로 중복된 값들을 제외하며 중복되지 않는 것을 '자연스레' 뽑다가 나오는 키를 자연키라고 함 
- 자연키는 언젠가는 변하는 속성을 가짐

### 인조키
- ex) 유저 테이블을 만든다고 했을 때 회원 테이블을 생성한다고 가정하면 
- 주민등록번호, 이름, 성별 속성이 있음 
- 여기에 인위적으로 유저 아이디를 부여함 
- 이를 통해 고유 식별자가 생겨남
- 오리클은 sequence, MySQL은 auto increment 등으로 설정함 
- 이렇게 인위적으로 생성한 키를 인조키라고 함 
- 자연키와는 대조적으로 변하지 않음 
- 따라서 보통 기본키는 인조키로 설정함

## 외래키(Foreign Key)
- FK라고도 하며, 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는 데 사용함
- 외래키는 중복되어도 괜찮음
- client라는 테이블의 기본키인 ID가 product라는 테이블의 user_id라는 외래키로 설정될 수 있음을 보여줌 
- 또한, user_id는 a_2라는 값이 중복되는 것을 볼 수 있음

## 후보키(candidate key)
- 기본키가 될 수있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

## 대체키(alternate key)
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말함

## 슈퍼키(super key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

---
## ✅ 기본 질문과 답변

### 🔹 Q1. DBMS와 데이터베이스의 차이는 무엇인가요?

- **답변:**
- 데이터베이스는 실제로 데이터를 저장하는 구조화된 공간이고, DBMS는 이 데이터베이스를 관리하고 접근할 수 있게 해주는 소프트웨어입니다.
- 예를 들어, MySQL은 DBMS이며, 그 안에 존재하는 여러 데이터베이스 중 하나가 `user_db`라면, 이 안에 회원 정보 등의 데이터가 저장됩니다.


### 🔹 Q2. 엔터티(Entity)란 무엇이며, 약한 엔터티는 어떤 경우 사용하나요?

- **답변:**
- 엔터티는 사람, 사물, 개념 등 명사형 개체이며, 속성을 가집니다. 예를 들어 `회원` 엔터티는 이름, 아이디, 주소 등의 속성을 가질 수 있습니다.
- 약한 엔터티는 다른 엔터티가 없으면 독립적으로 존재할 수 없는 개체입니다. 예를 들어 `방`은 `건물`이 있어야 의미 있으므로 `방`은 약한 엔터티입니다.


### 🔹 Q3. 관계형 데이터베이스에서 릴레이션은 무엇을 의미하나요?

- **답변:**
- 릴레이션은 관계형 데이터베이스에서 하나의 테이블을 의미합니다. 릴레이션은 속성(컬럼)과 레코드(행)로 구성되어 있고, 하나의 릴레이션은 하나의 엔터티 정보를 표현합니다.
- 예: `book` 릴레이션은 책의 제목, 저자, 장르 등의 속성을 가짐.


### 🔹 Q4. 속성(attribute)과 도메인(domain)의 차이를 설명해주세요.

- **답변:**
- 속성은 엔터티가 가진 고유의 정보 단위이고, 도메인은 속성이 가질 수 있는 값의 범위입니다.
- 예를 들어, `성별`이라는 속성의 도메인은 `{남, 여}`입니다.


### 🔹 Q5. VARCHAR와 CHAR의 차이는 무엇인가요?

- **답변:**

* `CHAR`: 고정 길이 문자열로, 항상 지정한 길이만큼 공간을 차지합니다. (ex: CHAR(10)은 항상 10바이트)
* `VARCHAR`: 가변 길이 문자열로, 실제 데이터 길이에 따라 저장 공간이 결정됩니다.

→ 일반적으로 가변 길이 데이터를 저장할 때는 VARCHAR를 사용합니다.


### 🔹 Q6. 1:1, 1\:N, N\:M 관계를 설명해주세요.

- **답변:**

* 1:1: 하나의 유저가 하나의 프로필을 가질 때
* 1\:N: 하나의 유저가 여러 개의 주문을 가질 때
* N\:M: 학생은 여러 강의를 듣고, 강의는 여러 학생을 수강할 수 있을 때

→ N\:M은 보통 중간 테이블을 생성하여 1\:N + 1\:N 관계로 변환합니다.


### 🔹 Q7. 기본키(Primary Key)와 외래키(Foreign Key)의 차이를 설명해주세요.

- **답변:**

* **기본키(PK)**: 테이블 내에서 각 레코드를 유일하게 식별하는 키. 중복/NULL 불가
* **외래키(FK)**: 다른 테이블의 기본키를 참조하는 키로, 테이블 간 관계를 맺을 때 사용

→ 예: `orders` 테이블에서 `user_id`는 `users` 테이블의 `id`를 참조하는 외래키가 될 수 있음


### 🔹 Q8. 인조키(Surrogate Key)와 자연키(Natural Key)의 차이를 설명해주세요.

- **답변:**

* **자연키**는 실제 의미 있는 데이터를 기본키로 사용하는 것 (ex: 주민등록번호)
* **인조키**는 의미 없는 숫자를 자동 생성하여 사용하는 것 (ex: AUTO\_INCREMENT id)

→ 일반적으로 백엔드에서는 안정성과 관리 편의성을 위해 인조키를 선호합니다.


### 🔹 Q9. 후보키(Candidate Key)와 슈퍼키(Super Key)의 관계를 설명해주세요.

- **답변:**

* **슈퍼키**: 유일성을 보장하는 모든 키의 집합
* **후보키**: 슈퍼키 중에서 최소성을 만족하는 키
* **기본키**는 후보키 중 선택된 하나

→ 즉, 모든 기본키는 후보키이며, 모든 후보키는 슈퍼키입니다.


### 🔹 Q10. ENUM과 SET 타입의 차이점은 무엇인가요?

- **답변:**

* **ENUM**: 하나의 값만 선택 가능한 열거형 (ex: ‘small’, ‘medium’, ‘large’ 중 하나)
* **SET**: 여러 값을 동시에 선택 가능한 열거형 (ex: ‘토핑1, 토핑2’ 등 다중 선택)

→ 실무에서는 ENUM은 선택지를 제한할 수 있어 유용하지만, 값이 변경될 경우 데이터 마이그레이션 부담이 있습니다.


---

## ✅ 심화 질문과 답변

### ❓ Q1. 릴레이션의 속성과 도메인은 각각 어떤 역할을 하며, 이를 백엔드 코드와 연결해 설명해보세요.

✅ A1.

* **속성(attribute)**: 릴레이션(테이블)의 열(Column)이며, 데이터를 설명하는 항목입니다. 예: `name`, `email`.
* **도메인(domain)**: 각 속성이 가질 수 있는 **값의 범위**를 의미합니다. 예: `성별` 속성은 `{남, 여}`와 같은 값 집합을 가질 수 있음.

💡 실무 예시:

```java
@Entity
public class Member {
  private String name;        // 속성
  private Gender gender;      // enum Gender { MALE, FEMALE } → 도메인 역할
}
```

→ 백엔드에서는 enum 타입 또는 Validation(예: @Pattern, @Enum 등)으로 도메인을 제한하고, 이 값을 DB에 저장하는 구조를 설계합니다.


### ❓ Q2. 약한 엔터티와 강한 엔터티를 활용한 테이블 설계 예시를 설명해보세요.

✅ A2.

* **강한 엔터티**는 자체적으로 고유 식별자(PK)를 갖고 존재할 수 있는 개체입니다.
* **약한 엔터티**는 외래키(FK)를 통해 다른 엔터티에 종속되는 개체이며, 자신의 PK가 부족하여 관계 속성으로 식별됩니다.

💡 실무 예시:

* `Order`(주문) 엔터티가 강한 엔터티라면
* `OrderItem`(주문 상세)는 주문이 없으면 존재 의미가 없고, `Order`의 PK + 상품 ID로 구성된 복합키를 가짐 → 약한 엔터티

```sql
CREATE TABLE order (
  id INT PRIMARY KEY,
  user_id INT
);

CREATE TABLE order_item (
  order_id INT,
  product_id INT,
  quantity INT,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (order_id) REFERENCES order(id)
);
```


### ❓ Q3. CHAR와 VARCHAR 타입의 차이를 고려해야 하는 실무 사례는?

✅ A3.

* **CHAR**는 고정 길이 문자 → 짧고 길이 일정한 데이터 (ex: 국가 코드 `KR`, `JP` 등)
* **VARCHAR**는 가변 길이 문자 → 길이가 유동적인 데이터 (ex: 사용자 닉네임, 이메일)

💡 실무 적용:

* 주민등록번호 앞 6자나 우편번호 같이 길이가 고정된 값은 `CHAR(6)`
* 로그인 이메일 등은 `VARCHAR(255)`로 지정하여 메모리 효율을 높입니다.


### ❓ Q4. ENUM 타입을 데이터베이스에서 사용할 때 장단점과 실무 대처 전략은?

✅ A4.

* **장점**: 고정된 값 집합이므로 데이터 무결성 확보 / 공간 효율성 (숫자 매핑)
* **단점**: 새로운 값 추가나 수정 시 마이그레이션 필요 / enum 변경이 DB 구조 변경을 수반

💡 실무 전략:

* ENUM 대신 **참조 테이블**을 두고 관리 (ex: `gender` 테이블)
* 또는 ENUM을 코드단에서만 유지하고, DB에는 `VARCHAR`로 저장하고 Validation으로 무결성 확보


### ❓ Q5. 슈퍼키, 후보키, 기본키, 대체키의 차이를 실무 예시와 함께 설명하세요.

✅ A5.

* **슈퍼키**: 유일성을 가진 모든 키 집합
* **후보키**: 슈퍼키 중 **최소성**을 만족하는 키
* **기본키**: 후보키 중 하나 선택
* **대체키**: 기본키로 선택되지 않은 후보키

💡 실무 예시:
회원 테이블에서 `email`과 `phone_number`가 유일하다고 가정:

| 키 종류 | 설명                                         |
| ---- | ------------------------------------------ |
| 슈퍼키  | `{id}`, `{email}`, `{email, phone_number}` |
| 후보키  | `{email}`, `{phone_number}`                |
| 기본키  | `{email}` 선택 시                             |
| 대체키  | `{phone_number}` (후보였으나 선택 안 됨)            |

→ 비즈니스에 따라 복합키 대신 인조키(Auto Increment `id`)로 대체하기도 함.


### ❓ Q6. 외래키(FK)의 제약 조건이 있는 경우와 해제해야 하는 경우를 비교해보세요.

✅ A6.

* **FK 제약 조건 활성**: 데이터 무결성을 위해, 참조 대상이 삭제되면 오류 발생 (`ON DELETE RESTRICT`)
* **FK 제약 조건 해제 또는 ON DELETE CASCADE 사용**:

  * 참조 대상 삭제 시 종속 데이터도 함께 삭제됨
  * ex: 회원 탈퇴 시 관련 주문, 장바구니 정보도 함께 삭제해야 하는 경우

💡 실무 판단 기준:

* FK는 **읽기 성능 저하, 이중 관리 이슈** 때문에 RDB 설계에 따라 해제하는 경우도 많음
* 대신 애플리케이션 계층에서 삭제 로직을 명시적으로 처리 (ex: Service Layer에서 순차 삭제)


### ❓ Q7. 릴레이션과 컬렉션의 차이를 설명하고, NoSQL에서 N\:M 관계를 어떻게 해결하는지 말해보세요.

✅ A7.

* **릴레이션**: 관계형 DB의 테이블 단위
* **컬렉션**: MongoDB와 같은 NoSQL의 문서(Document) 집합

NoSQL에서는 JOIN이 없기 때문에 N\:M 관계는 보통 다음 중 하나로 해결:

1. **중간 컬렉션 생성**: 별도의 `student_course` 컬렉션으로 양쪽 `_id`를 저장
2. **중첩 문서**: 한쪽 문서 안에 상대 ID 리스트를 저장 (ex: student에 courseId 배열)

➡ 관계형 DB처럼 관계가 강할수록 RDB, 관계가 느슨하고 유연성이 중요할수록 NoSQL이 유리


### ❓ Q8. 테이블의 필드 설계 시 주의할 점은? 속성과 타입 선정 기준도 함께 설명해주세요.

✅ A8.

* **속성 선정 기준**: 서비스 요구사항에 따라 식별 가능하고, 변하지 않으며, 자주 사용하는 필드 중심
* **타입 선정 기준**:

  * 값의 길이와 형식 고려 (ex: 전화번호는 `VARCHAR`, 금액은 `DECIMAL`)
  * 날짜는 `DATETIME` vs `TIMESTAMP` 용도 구분 필요

💡 예시:

* `created_at`은 대부분 `DATETIME`으로, 타임존 고려 시 `TIMESTAMP`
* 이메일은 길이 유동 → `VARCHAR(255)`
* 가격은 정수 + 소수점 필요 → `DECIMAL(10,2)`