# 4.1 데이터베이스의 기본
- 데이터베이스(DB, DataBase) : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음 
- DBMS(DataBase Management System) : 해당 데이터베이스를 제어, 관리하는 통합 시스템
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있음 
- 또한, 데이터베이스는 실시간 접근과 동시 공유가 가능함

✔️ 데이터베이스와 DBMS  <br>
- 응용 프로그램 <-> DBMS <-> 데이터베이스
- 데이터베이스 위에 DBMS가 있고 그 위에 응용 프로그램이 있으며, 이러한 구조를 기반으로 데이터를 주고받음
- ex) MySQL이라는 DBMS가 있고 그 위에 응용 프로그램에 속하는 Node.js나 php에서 해당 데이터베이스 안에 있는 데이터를 끄집어내 해당 데이터 관련 로직 구축가능

---

# 4.1.1 엔터티
- 엔터티(entity) : 사람, 장소, 물건, 사전, 개념 등 여러 개의 속성을 지닌 명사를 의미함
- ex) 회원이라는 엔터티가 있다고 해봅시다. 회원은 이름. 아이디. 주소, 전화번호의 속성을 갖겠죠?

✔️ 엔터티 <br>
- 회원 
  - 이름 아이디 주소 전화번호
- 물론 이보다 많은 속성이 있지만 서비스의 요구 사항에 맞춰 속성이 정해짐
- ex) 주소라는 속성이 서비스의 요구 사항과 무관한 속성이라면 주소라는 속성은 사라지게 됨

## 약한 엔터타와 강한 엔터티
- 엔터티는 약한 엔터티와 강한 엔터티로 나뉨 
- ex) A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 
  - A는 약한 엔터티이고 B는 강한 엔터티가 됨 
- ex) 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티, 건물을 강한 엔터티

---

# 4.1.2 릴레이션(relation)
- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리함

✔️ 릴레이션 <br>
- 회원이라는 엔터티가 데이터베이스에서 관리될 때 릴레이션으로 변화 된 것을 볼 수 있음 
- 릴레이션은 관계형 데이터베이스에서는 '테이블'이라고 하며, NoSQL 데이터베이스에서는'컬렉션'이라고 함

## 테이블과 컬렉션
- 데이터베이스의 종류 : 관계형 데이터베이스, NoSQL 데이터베이스 
- 이 중 대표적인 관계형 데이터베이스인 MySQL과 대표적인 NoSQL 데이터베이 스인 MongoDB를 예로 들면, 
  - MySQL의 구조는 레코드-테이블-데이터베이스로 이루어져 있고 
  - MongoDB 데이터베이스의 구조는 도큐먼트-컬렉션-데이터베이스로 이루어져 있음

✔️ 레코드-테이블-데이터베이스의 구조 <br>
- 레코드가 쌓여서 테이블이 되고 테이블이 쌓여서 데이터베이스가 되는 것

---

# 4.1.3 속성(attribute) 
- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보 
- ex) '차'라는 엔터티의 속성을 뽑아보기 -> 차 넘버, 바퀴 수, 차 색깔, 차종 등
  - 이 중에서 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 됨

---

# 4.1.4 도메인(domain)
- 릴레이선에 포함된 각각의 속성들이 가질 수 있는 값의 집합
- ex) 성벌이라는 속성이 있다면 이 속성이 가질 수 있는 값은 {남, 여}라는 집합이 됨

✔️ 속성과 도메인  <br>
- 회원이라는 릴레이션에 이름, 아이디, 주소, 전화번호, 성별이라는 속성이 있고 
- 성별은 (남, 여}라는 도메인을 가지는 것을 알 수 있음

---

# 4.1.5 필드와 레코드
- 앞에서 설명한 것들을 기반으로 데이터베이스에서 필드와 레코드로 구성된 테이블을 만들 수 있음

✔️ 필드와 레코드 <br>
- 회원이란 엔터티는 member라는 테이블로 
  - 속성인 이름, 아이디 등을 가지고 있으며 name, ID, address 등의 필드를 가짐
  - 그리고 이 테이블에 쌓이는 행(row) 단위의 데이터를 레코드라고 함 
  - 또한, 레코드를 튜플이라고도 함
- ex) '책이라는 엔터티를 정의하고 이를 기반으로 테이블 생성
  - 먼저 어떠한 속성들이 있을까요? 책의 제목, 책의 가격, 책의 ISBN, 책의 저자, 책의 출판 년도 등
    - 일단 수많은 '속성' 중에서 이름, 저자의 아이디, 출판년도, 장르, 생성 일시, 업데이트 일시만 있다고 가정 
  - 이 엔터티를 데이터베이스에 넣어 테이블로 만틀려면
    - 이 속성에 맞는 타입을 정의해야 함 
    - 참고로 타입은 MongoDB나 MySQL 등 데이터베이스마다 조금씩 차이가 있는데 MySQL을 기준으로 설명함
      - 책의 아이디: INT 
      - 책의 제목: VARCHAR(255)
      - 책의 저자 아이디: INT
      - 책의 출판년도: VARCHAR(255)
      - 책의 장르: VARCHAR(255) 
      - 생성 일시:DATETIME 
      - 업데이트 일시: DATETIME
  - 각 속성에 맞는 타입을 정의함
  - 이를 테이블로 만들면 다음과 같음
  
✔️ book 테이블  <br>
- book
  - id INT
  - title VARCHAR(2S5)
  - author_id INT
  - publishing_year VARCHAR(255)
  - genre VARCHAR(255)
  - created_at DATETIME
  - updated_at DATETIME
  
- 보통 책의 작목, 책의 출판년도처럼 한글을 속성 이름으로 쓰지 않음 
  - title, author_id 등으로 영어 이름에 매핑해서 쓰며 
  - 앞서 설명한 속성과 타입들이 들어간 것을 불 수 있음

- 참고로 앞의 테이블을 MySQL로 구헌하려면 다음과 같은 코드를 입력하면 됨
- SQL
  - CREATE TABLE book( 
    - id INT NOT NULL AUTO_INCREMENT, 
    - title VARCHAR(255), 
    - author_id INT, 
    - publishing_year VARCHAR(255), 
    - genre VARCHAR(255), 
    - created_at DATETIME, 
    - updated_at DATETIME,
    - PRIMARY KEY (id)
  - );

## 필드 타입
- 필드는 타입을 가짐
- ex) 이름은 문자열이고 전화번호는 숫자겠죠? 
  - 이러한 타입들은 DBMS마다 다르며 이 책에서는 MySQL을 기준으로 설명하겠음
- 여러 가지 타입이 있고 대표적인 타입인 숫자, 날짜, 문자 타입에 대해 알아보겠음

### 숫자 타입
- 숫자 타입으로는 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있음

✔️ MySQL 숫자 타입  <br>
- 타입 용량(바이트) 최숫값(부호 있음) 최솟값(부호 없음) 최댓값(부호 없음) 최댓값(부호 있음) 
- TINYINT 1 -128 0 127 255 
- SMALLINT 2 -32768 0 32767 65535 
- MEDIUMINT 3 -8388608 0 8388607 
- INT 4 -2147483648 0 2147483647 4294967295
- BIGINT 8 -263 0 263-1 264-1

### 날짜 타입 
- 날짜 타입으로는 DATE, DATETIME, TIMESTAMP 등이 있음

#### DATE 
- 날짜 부분은 있지만 시간 부분은 없는 값에 사용됨 
- 지원되는 범위는 1000-01-01~9999-12-31 
- 3바이트의 용량을 가짐

#### DATETIME 
- 날짜 및 시간 부분을 모두 포함하는 값에 사용됨
- 지원되는 범위는 1000-01-01 00:00:00에서 9999-12-31 23:59:59 
- 8바이트의 용량을 가짐

#### TIMESTAMP
- 날짜 및 시간 부분을 모두 포함하는 값에 사용됨
- 1970-01-01 00:00:01에서 2038-01-19 03:14:07까지 지원함 
- 4바이트의 용량을 가짐

### 문자 타입
- 문자 타입으로는 CHAR, VARCHAR, TEXT, BLOB, ENUM. SET이 있음

#### CHAR와 VARCHAR
- CHAR 또는 VARCHAR 모두 그 안에 수를 입력해서 몇 자까지 입력할지 정함 
  - ex) CHAR(30)이라면 최대 30글자까지 입력할 수 있음
- CHAR : 고정 길이 문자열
  - 길이는 0에서 255 사이의 값을 가짐 
  - 레코드를 저장 할 때 무조건 선언한 길이 값으로 '고정해서 저장됨
  - ex) CHAR(100)으로 선언한 후 10글자를 저장해도 100바이트로 저장되게 됨 
- VARCHAR : 가변 길이 문자열 
  - 길이는 0에서 65,535 사이의 값으로 지정가능 
  - 입력된 데이터에 따라 용량을 가변시켜 저장함 
  - ex) 10글자의 이메일을 저장할 경우 VARCHAR(10000) 선언했음에도 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 됨
- 그렇기 때문에 CHAR의 경우 유동적이지 않은 길이를 가진 데이터의 경우에 효율적이며, 유동적인 길이물 가진 데이터는 VARCHAR로 저장하는 짓이 좋음

#### TEXT와 BLOB 
- 두 개의 타입 모두 큰 데이터를 저장할 때 쓰는 타입 
- TEXT : 큰 문자열 저장에 쓰며 주로 게시판의 본문을 저장할 때 사용
- BLOB : 이미지. 동영상 등 큰 데이터 저장에 사용 
  - 그러나 보통은 아마존의 이미지 호스팅 서비스인 S3를 이용하는 등 서비에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장함

#### ENUM SET
- ENUM과 SET 모두 문자열을 열거한 타입
- ENUM : ENUM('x-small','small', 'medium', 'large', `x-large) 형태로 쓰이며, 
  - 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됨
  - ENUM을 이용하면 x-small 등이 0, 1 등으로 매핑되어 메모리를 적게 사용하는 이점을 얻음
  - ENUM은 최대 65,535개의 요소들을 넣을 수 있음
- SET : ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다름 
- 참고로 ENUM이나 SET을 쓸 경우 공간적으로 이점을 볼수 있지만 
  - 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야 한다는 단점이 있음

---

# 4.1.6 관계 
- 데이터베이스에 테이블은 하나만 있는 것이 아님
- 여러 개의 테이블이 있고 이리한 테이블은 서로의 관계가 정의되어 있음
- 이러한 관계를 관계화살표로 나타냅니다.

✔️ 관계화살표  <br>
- 하나의 A는 하나의 B로 구성되어 있다
- 하나의 A는 하나 이상의 B로 구성되어 있다 
- 하나의 A는 하나 이하의 B로 구성되어 있다
- 하나의 A는 0 또는 하나 이상의 B로 구성되어 있다

## 1:1관계
- ex) 유저당 유저 이메일은 한 개씩 있겠죠? 
- 이 경우 1:1 관계가 됨
- 1:1 관계는 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어줌

## 1:N 관계
- ex) 쇼핑몰을 운영한다고 해봅시다. 
  - 한 유저당 여러 개의 상품을 장바구니에 넣을 수 있겠죠?
  - 이 경우 1:N 관계가 됨
  - 물론 하나도 넣지 않는 0개의 정우도 있으니 0도 포함되는 화살표를 통해 표현해야 함
- 이렇게 한 개체가 다른 많은 개체를 포함하는 관계를 말함

## N:M관계
- 학생과 강의의 관계를 정의하면 어떻게 될까요? 
  - 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있음 
  - 이 경우 N:M이 됩니다.
- 중간에 학생 강의라는 테이블이 끼이 있음 
- N:M은 테이블 두 개를 직접적 으로 연결해서 구축하지는 않고 
- 1:N, 1:M이라는 관계를 찾는 테이블 두 개로 나눠서 설정함

---

# 4.1.7 키 
- 테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인맥스를 위해 설정된 장치
- 기본키. 외래키, 후보키, 슈퍼키. 대체키가 있음

✔️ 키간의 관계 <br>
- 슈퍼키는 유일성이 있고 
- 그 안에 포함된 후보키는 최소성까지 갖춘 키 
- 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 됨
- 유일성은 중복되는 값은 없으며, 
- 최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것을 말함

## 기본키(Primary Key)
- 줄여 PK 또는 프라이머리키라고 많이 부르며,
- 유일성과 최소성을 만족하는 키

✔️ 기본키가 안 되는 키  <br>
- ID nаmе 
  - PDT-00O1> 홍철이의 따스한 점퍼 
  - PDT-0002> 제호의 BMW 
  - PDT-00O2> 제호의 BHW X
  - PDT-0003> 종선이의 벤츠
- 이는 테이블의 데이터 중 소유하게 존재하는 속성이며 
- 기본키에 해당하는 데이터는 앞의 그림의 ID처럼 중복되어서는 안됨
- PDT-0002가 중복되기 때문에 ID라는 필드는 기본키가 되지 말아야 함

✔️ 기본키가 되는 키  <br>
- ID nаmе 
  - 1 주홍천 
  - 2 주홍철 
  - 3 최범석 
  - 4 양기영
- 앞의 그림에서 ID는 기본키로 설정할 수 있겠죠? 
- 물론 {ID, name}이라는 복합키를 기본키로 설정할 수 있지만 그렇게 되면 최소성을 만족하지 않음
- 기본키는 자연키 또는 인조키 중에 골라 설정함

### 자연키
- ex) 유저 테이블을 만든다고 가정하면 
- 주민등록번호, 이름, 성별 등의 속성이 있음
- 이 중 이름, 성별 등은 중복된 값이 들어올 수 있으므로 부적절하고 
- 남는 것은 주민등록번호임 
- 이런 식으로 중복된 값들을 제외하며 중복되지 않는 것을 '자연스레' 뽑다가 나오는 키를 자연키라고 함 
- 자연키는 언젠가는 변하는 속성을 가짐

### 인조키
- ex) 유저 테이블을 만든다고 했을 때 회원 테이블을 생성한다고 가정하면 
- 주민등록번호, 이름, 성별 속성이 있음 
- 여기에 인위적으로 유저 아이디를 부여함 
- 이를 통해 고유 식별자가 생겨남
- 오리클은 sequence, MySQL은 auto increment 등으로 설정함 
- 이렇게 인위적으로 생성한 키를 인조키라고 함 
- 자연키와는 대조적으로 변하지 않음 
- 따라서 보통 기본키는 인조키로 설정함

## 외래키(Foreign Key)
- FK라고도 하며, 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는 데 사용함
- 외래키는 중복되어도 괜찮음
- client라는 테이블의 기본키인 ID가 product라는 테이블의 user_id라는 외래키로 설정될 수 있음을 보여줌 
- 또한, user_id는 a_2라는 값이 중복되는 것을 볼 수 있음

## 후보키(candidate key)
- 기본키가 될 수있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

## 대체키(alternate key)
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말함

## 슈퍼키(super key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

---
## ✅ 기본 질문과 답변


---
## ✅ 심화 질문과 답변