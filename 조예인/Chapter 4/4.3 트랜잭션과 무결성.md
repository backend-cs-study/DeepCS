# 4.3 트랜잭션과 무결성

# 4.3.1 트랜잭션
- 트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말하며 
  - 데이터베이스에 접근하는 방법은 퀴리이므로, 
  - 즉 여러 개의 쿼리들을 하나로 묶는 단위를 말함
- 이에 대한 특징은 원지성, 일관성, 독립성, 지속성이 있으며 
  - 이를 한꺼번에 ACID 특징이라고 함

## 원자성(atomicity)
- "all or nothing"
- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
- ex) 트랜잭션을 커밋했는데, 문제가 발생하여 를백하는 경우
  - 그 이후에 모두 수행되지 않음을 보장하는 것
- ex) 1000만 원을 가진 홍철이가 0원을 가진 규영이에게 500만 원을 이체한다고 가정
  - 그렇다면 결과는 홍철이는 500만 원, 규영이는 500만 원을 가지겠죠? 
  - 해당 결과는 다음과 같은 operation 단위들로 이루어진 과정을 거침
    1. 홍철의 잔고를 조회한다. 
    2. 홍철에게서 500만 원을 뺀다.
    3. 규영에게 500만 원을 넣는다. 
- 여기서 1~3의 operation 중 데이터베이스 사용자는 이 세 가지의 과정을 볼 수도 참여할 수도 없음 
  - 다만 이 과정이 모두 끝난 이후의 상황인 홍철 500만 원, 규영 500만 원인 상황만 보는 것
- 여기서 이 작업을 '취소'한다고 했을 때 홍철이는 다시 1000만 원, 규영이는 0원을 가져야 함 
  - 일부 operation만 적용된 홍철이는 500만 원, 규영이는 0원이 되지 않는 것을 의미함 
  - 그래서 all or nothing인 것
- 또한 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안됨 
  - 만약 있다면 롤백이 일어났을 때 어떻게 헤야 할 것인지에 대한 해결 방법이 있어야 하고 
  - 트랜잭션 전파를 신경 써서 관리해야 함

### 커밋과 를백
- 커밋(commit) : 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어 
  - 트랜잭션 단위로 수행되며 
  - 변경된 내용이 모두 영구적으로 저장되는 것을 말함 
  - "커밋이 수행 되었다."를 "하나의 트랜잭션이 성공적으로 수행되었다."라고도 말함

✔️ 그림 4-26 커밋  <br>

<img src="https://github.com/user-attachments/assets/75823233-e475-4f2c-a6db-d8ce04bda568" width="400"/>

- 앞의 그림처럼 update, insert, delete의 퀴리가 하나의 트랜잭선 단위로 수행되고 
  - 이후에 데이터베이스에 영구 저장됨

✔️ 그림 4-27 롤백  <br>

<img src="https://github.com/user-attachments/assets/1e3f93e9-0df9-4c66-b85b-6fdc6609d30c" width="400"/>

- 하지만 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 한다면 어평게 해야 할까요? 
  - 이 때 사용하는 것이 롤백 
  - 롤백 : 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)을 말함
- 이러한 커밋과 롤백 덕에 데이터의 무결성이 보장됨 
  - 또한, 데이터 변경 전에 변경사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있음

### 트랜잭션 전파
- 트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 함 
  - 하지만 이를 매번 넘겨주기가 어렵기도 하고 귀찮기도 함 
  - 트랜잭션 전파 : 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것
```java
@Service
@Transactional(readOnly = true)
public class MemberService (
   private final MemberRepository memberRepository;
   
   public MemberService(MemberRepository memberRepository) {
       this.memberRepository = memberRepository;
   } 
```

- 앞의 코드처럼 Spring 프레임워크에서는 @Transactional 에너테이션을 통해 
  - 여러 쿼리 관련 코드들을 하나의 트랜직션으로 처리함

## 일관성(consistency) 
- '허용된 방식'으로만 데이터를 변경해야 하는 것을 의미함 
  - 데이터베이스에 기록된 모든 데이터는 어러 가지 조건, 규칙에 따라 유효함을 가져야 함 
  - ex) 홍철이는 1000만 원이 있고 범석이는 0원이 있음
  - 범석이가 필자 한테 500만 원을 입금할 수 있을까요? 불가능함 
  - 0원으로부터 500만 원이 나오는 것은 불가능함(마이너스 통장 제외)

## 격리성(isolation)
- 트랜잭션 수행 시 서로 끼어들지 못하는 것을 말함 
  - 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 
  - 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
  - 그냥 순차적으로 하면 쉽게 되겠지만 그렇게 하면 성능이 나쁨
- 격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장함

✔️ 그림 4-28 여러 개의 격리 수준 <br>

<img src="https://github.com/user-attachments/assets/46caa2c1-039e-4aaf-a949-f375fcfdc301" width="400"/>

- 격리 수준은 SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED 가 있음 
  - 위로 갈수록 동시성이 강해지지만 격리성은 약해지고, 아래로 갈수록 동시성은 약해지고 격리성은 강헤짐
  - ex) SERIALIZABLE : 격리성이 강한데 반해, 동시성은 악함 
    - 또한, 각 단계마다 나타나는 현상이 있음

- REPEATABLE_READ : 팬텀 리드, 
  - READ_COMMITTED : 팬텀 리드, 반복 가능하지 않은 조회가 발생하며, 
  - READ_UNCOMMITTED 는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 발생할 수도 있음

### 격리 수준에 따라 발생하는 현상
  - 팬텀 리드, 
  - 반복 가능하지 않은 조회, 
  - 더티 리드

#### 팬텀리드(phantom read) 
- 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말함
- ex) 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보냄
  - 이 결과로 세 개의 테이블이 조회함
  - 그다음 사용자 B가 age가 15인 회원 레코드를 삽입함 
  - 그러면 그다음 세 개가 아닌 네 개의 테이블이 조회됨

#### 반복 가능하지 않은 조회(non-repeatable read)
- 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킴 
- ex) 사용자 A가 큰돌의 보석 개수가 100개라는 값을 가진 데이터였는데, 
  - 그 이후 사용자 B가 그값을 1로 변정해서 커밋했다고 하면 
  - 사용자 A는 100이 아닌 1을 읽게 됨
- 팬텀 리드와 다른 점은 반복 기능하지 않은 조회는 행 값이 달라질 수도 있는데, 
- 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미함

#### 더티 리드(dirty read)
- 반복 기능하지 않은 조회와 유사하며 
  - 한 트렌잭선이 실행 중일때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생함 
- ex) 사용자가 큰돌의 보석 개수 100을 1로 변경한 내용이 '커밋되지 않은' 상태라도 
  - 그 이후 사용자 B가 조회한 결과가 1로 나오는 경우를 말함

### 격리 수준
#### SERIALIZABLE
- 말 그대로 트랜책선을 순차적으로 진행시키는 것을 말함 
  - 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음 
  - 이 수준은 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 
  - 이후 트랜색션이 이 행에 대해 일어난다면 기다려야 함 
  - 그렇기 때문에 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준

#### REPEATABLE READ
- 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않음
  - 따라서 이후에 추가된 행이 발견될 수도 있음
  - 이는 MySQL8.0의 innoDB 기본값이기도 함

#### READ_COMMITTED
- 가장 많이 사용되는 격리 수준
  - PostgreSQL, SQL Server, 오라클에서 기본값으로 설정되어 있음 
  - READ UNCOMMITTED와는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음 
  - 즉, 커밋 완료된 데이터에 대해서만 조회를 허용함 
  - 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜색션이 수정할 수 있음
  - ex) 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수도 있음 
    - 이 때문에 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있음
  
#### READ_UNCOMMITTED 
- 가장 낮은 격리 수준으로, 
  - 하나의 트랜책선이 커및되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름
  - 이는 데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적이나, 
  - 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데는 사용하면 좋음

## 지속성(durability)
- 성공적으로 수행된 트랜책선은 영원히 반영되어야 하는 것을 의미함 
  - 이는 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회북 기능이 있어야 합을 뜻하며, 
  - 데이터베이스는 이를 위헤 체크섬, 저널링, 롤백 등의 기능을 제공함

✔️ 용어  <br>
- 체크섬 : 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
- 저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 
  - 트랜잭션 등 변경사항에 대한 로그를 남기는 것

---

# 4.3.2 무결성
- 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말하며,
  - 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치 하는지에 대한 신뢰가 생김

✔️ 표 4-2 무결성 종류  <br>

| **이름**   | **설명**                                                        |
| -------- |---------------------------------------------------------------|
| 개체 무결성   | 기본키로 선택된 필드는 빈 값을 허용하지 않음                                     |
| 참조 무결성   | 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함                     |
| 고유 무결성   | 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성 값은 모두 고유한 값을 가짐        |
| NULL 무결성 | 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건 |




---
## ✅ 기본 질문과 답변

### ✅ Q1. 트랜잭션이란 무엇인가요?

- **답변:**
- 트랜잭션(Transaction)은 데이터베이스에서 하나의 논리적인 작업 단위를 말합니다. 여러 쿼리들을 하나로 묶어 모두 성공하거나, 하나라도 실패하면 전체를 취소(롤백)하는 것을 보장합니다.
- 예를 들어 A가 B에게 500만 원을 이체할 때, A의 계좌에서 출금하고 B의 계좌에 입금하는 두 작업은 하나의 트랜잭션으로 처리되어야 합니다.

### ✅ Q2. 트랜잭션의 ACID 속성에 대해 설명해주세요.

**답변:**
트랜잭션은 다음과 같은 4가지 속성(ACID)을 가집니다:

* **Atomicity(원자성)**: 전부 성공하거나 전부 실패해야 합니다.
* **Consistency(일관성)**: 데이터는 항상 유효한 상태를 유지해야 합니다.
* **Isolation(격리성)**: 트랜잭션 간 간섭 없이 독립적으로 실행되어야 합니다.
* **Durability(지속성)**: 성공한 트랜잭션의 결과는 영구적으로 저장되어야 합니다.


### ✅ Q3. 트랜잭션의 커밋과 롤백의 차이는 무엇인가요?

**답변:**

* \*\*커밋(commit)\*\*은 트랜잭션이 성공적으로 끝났음을 선언하고, 그 결과를 데이터베이스에 영구 저장합니다.
* \*\*롤백(rollback)\*\*은 트랜잭션 도중 문제가 생겼을 때, 이전 상태로 되돌리는 작업입니다. 이를 통해 데이터의 무결성을 유지할 수 있습니다.


### ✅ Q4. 트랜잭션의 격리 수준(Isolation Level)에 대해 설명해주세요.

**답변:**
트랜잭션 격리 수준은 여러 트랜잭션이 동시에 실행될 때 서로 영향을 미치지 않도록 보호하는 정도입니다. 대표적인 격리 수준은 다음과 같습니다:

1. **READ UNCOMMITTED**: 커밋되지 않은 데이터도 읽을 수 있음 → 오류 가능성 높음
2. **READ COMMITTED**: 커밋된 데이터만 읽음 → 대부분의 DB 기본값
3. **REPEATABLE READ**: 같은 쿼리 결과가 항상 동일하게 보장됨
4. **SERIALIZABLE**: 가장 엄격한 수준으로, 모든 트랜잭션을 순차적으로 실행


### ✅ Q5. 더티 리드(Dirty Read), 반복 불가능 조회, 팬텀 리드의 차이는 무엇인가요?

**답변:**
이들은 낮은 격리 수준에서 발생할 수 있는 현상입니다.

* **더티 리드**: 다른 트랜잭션에서 커밋하지 않은 데이터를 읽는 것
* **반복 불가능한 조회**: 같은 쿼리를 여러 번 했을 때 결과가 달라지는 것
* **팬텀 리드**: 같은 조건의 쿼리인데 새로운 행이 생겨 결과 개수가 달라지는 것


### ✅ Q6. 데이터 무결성이란 무엇인가요?

**답변:**
데이터 무결성은 데이터의 **정확성, 일관성, 유효성**을 보장하는 개념입니다. 현실 세계의 상태와 데이터베이스의 상태가 일치하도록 하기 위해 다양한 제약 조건을 둡니다.


### ✅ Q7. 데이터 무결성 제약 조건의 종류는 어떤 것들이 있나요?

**답변:**

1. **개체 무결성**: 기본키는 반드시 존재하고, 중복될 수 없습니다.
2. **참조 무결성**: 외래키로 참조된 값은 항상 존재하는 값이어야 합니다.
3. **고유 무결성**: 특정 속성은 중복될 수 없습니다. (e.g., 주민번호, 이메일)
4. **NULL 무결성**: 특정 속성은 NULL 값을 허용하지 않아야 합니다. (e.g., 이름, 생년월일 등 필수 정보)


### ✅ Q8. Spring에서 트랜잭션을 어떻게 관리하나요?

**답변:**
Spring에서는 `@Transactional` 어노테이션을 사용하여 메서드 단위로 트랜잭션을 선언합니다.
예를 들어, 서비스 클래스에 `@Transactional`을 붙이면, 해당 메서드 내 쿼리들이 하나의 트랜잭션으로 처리됩니다.

```java
@Service
@Transactional
public class MemberService {
    // ...
}
```


---

## ✅ 심화 질문과 답변

### ✅ Q1. 트랜잭션 내부에서 외부 API 호출은 왜 위험한가요?

**답변:**
트랜잭션은 보통 DB 작업이 모두 성공할 경우에만 `commit`, 실패 시 `rollback`하여 원자성을 보장합니다. 그런데 트랜잭션 안에서 외부 API를 호출하면 다음과 같은 문제가 발생할 수 있습니다:

* 외부 API 호출은 롤백할 수 없습니다.
* DB는 롤백되었지만 외부 서비스에는 변화가 반영된 경우, 시스템 간 데이터 불일치가 생깁니다.

이런 경우에는 **Saga 패턴**이나 **이벤트 기반 비동기 처리**로 트랜잭션 외부에서 처리해야 합니다.


### ✅ Q2. 트랜잭션 전파(propagation) 옵션에는 어떤 것들이 있고, 언제 사용하나요?

**답변:**
Spring의 `@Transactional`은 트랜잭션 전파 옵션을 제공하여 메서드 간 트랜잭션 흐름을 제어합니다.

* `REQUIRED` (기본): 기존 트랜잭션이 있으면 참여, 없으면 새로 생성
* `REQUIRES_NEW`: 기존 트랜잭션 중단, 무조건 새 트랜잭션 생성 → **별도 로그 저장 등에 사용**
* `NESTED`: 기존 트랜잭션 내부에 중첩 트랜잭션 시작 (지원 DB 한정)

예시: 결제 트랜잭션 중, 알림 전송 실패는 메인 트랜잭션에 영향 주지 않게 하려면 `REQUIRES_NEW`로 분리할 수 있습니다.


### ✅ Q3. 트랜잭션 격리 수준을 실무에서 어떻게 선택하나요?

**답변:**
트랜잭션 격리 수준은 **데이터 정합성 vs 성능** 간 트레이드오프를 고려해 설정합니다.

* 대부분의 업무 시스템은 `READ_COMMITTED`로 충분합니다 (기본값).
* 하지만 **조회 시 값이 바뀌면 안 되는 경우**는 `REPEATABLE_READ`를 사용해야 하며,
* **정합성이 가장 중요한 금융 거래나 회계 시스템**은 `SERIALIZABLE`을 고려할 수 있습니다.

단, 격리 수준이 높을수록 락 충돌과 교착상태 가능성이 높기 때문에 주의가 필요합니다.


### ✅ Q4. 팬텀 리드와 반복 불가능한 조회의 차이를 실무 예시로 설명해주세요.

**답변:**

* **반복 불가능한 조회**: 기존에 조회한 **같은 행의 값**이 바뀌는 현상
  → 예: 장바구니에서 본 상품 가격이 A → B로 변경됨

* **팬텀 리드**: 기존에 없던 **새로운 행**이 생겨서 조회 결과가 달라짐
  → 예: ‘12세 이상 유저 목록’ 조회 중, 누군가 12세 유저 등록 → 결과 수가 바뀜

팬텀 리드는 보통 `REPEATABLE_READ`로는 방지되지 않으며, `SERIALIZABLE`로만 방지됩니다.


### ✅ Q5. 트랜잭션과 무결성은 어떻게 연결되나요?

**답변:**
트랜잭션의 ACID 속성 중 \*\*일관성(Consistency)\*\*이 무결성과 가장 밀접한 관련이 있습니다.

* 예를 들어 외래키 제약조건(참조 무결성)이 있는 두 테이블에서,
  하나의 트랜잭션이 부모 테이블을 삭제하고 자식 테이블 참조를 수정하지 않으면,
  무결성이 깨집니다.

트랜잭션을 통해 데이터 변경 작업 전체를 원자적으로 처리하고, 실패 시 롤백함으로써 **무결성을 보장**할 수 있습니다.


### ✅ Q6. READ\_COMMITTED에서 더티 리드가 발생하지 않는 이유는 무엇인가요?

**답변:**
`READ_COMMITTED`는 **커밋된 데이터만 읽을 수 있도록 제한**합니다. 따라서,

* 다른 트랜잭션이 아직 커밋하지 않은 데이터는 조회할 수 없습니다.
* 이로 인해 \*\*더티 리드(Dirty Read)\*\*는 발생하지 않습니다.

하지만 같은 행을 다시 읽었을 때 값이 변경될 수 있으므로, **반복 불가능한 조회**는 여전히 발생할 수 있습니다.


### ✅ Q7. 무결성 제약조건 중 참조 무결성이 깨지는 상황은 어떤 경우인가요?

**답변:**
예를 들어 `orders` 테이블의 `user_id`가 `users` 테이블을 참조한다고 가정할 때,

* `users` 테이블에서 해당 `user_id`를 삭제했는데,
* `orders`에서 여전히 그 `user_id`를 참조하고 있다면 **참조 무결성 위반**입니다.

이를 방지하기 위해 **ON DELETE CASCADE**나 애플리케이션 단에서 참조 유효성 검사를 수행합니다.


### ✅ Q8. @Transactional(readOnly = true) 옵션은 왜 사용하는가요?

**답변:**
이 옵션은 **읽기 전용 트랜잭션**을 생성합니다.

* 데이터 변경이 일어나지 않음을 보장하므로, 일부 DB는 **락 생성을 생략**하거나 **트랜잭션 로그 기록을 줄여** 성능을 향상시킵니다.
* 또한, 실수로 insert/update 쿼리가 실행될 경우 **예외가 발생하거나 무시**되므로 안전장치 역할도 합니다.



---
## ✅ 추가 심화 질문과 답변


### ✅ Q9. 트랜잭션이 롤백되지 않는 상황에는 어떤 경우가 있을까요?

**답변:**
Spring에서는 **`RuntimeException` 및 `Error` 계열 예외**만 자동으로 롤백합니다.
따라서 `checked exception`이 발생해도 트랜잭션은 기본적으로 롤백되지 않습니다.

예시:

```java
@Transactional
public void doSomething() throws IOException {
    throw new IOException(); // 롤백되지 않음
}
```

해결책:

* `rollbackFor = IOException.class`를 명시하거나
* `RuntimeException`으로 감싸서 던지는 방식으로 처리합니다.


### ✅ Q10. @Transactional 이 내부 호출에서 제대로 작동하지 않는 이유는 무엇인가요?

**답변:**
Spring AOP 기반의 `@Transactional`은 **프록시 객체를 통해 트랜잭션을 적용**합니다.
그런데 동일 클래스 내에서 `this.다른메서드()`처럼 **내부 호출**을 하면 AOP 프록시를 거치지 않기 때문에 트랜잭션이 적용되지 않습니다.

해결책:

* `별도의 빈`으로 분리하거나
* `ApplicationContext.getBean()`으로 우회 호출해야 합니다.


### ✅ Q11. 트랜잭션 커밋 전에 외부에 메시지를 발행하면 어떤 문제가 생기나요?

**답변:**
트랜잭션이 **성공하지 않을 수도 있는 상황에서 메시지를 먼저 발행**하면,
외부 시스템은 해당 데이터가 반영된 것으로 잘못 인식하게 됩니다.

예시: 주문 테이블에 데이터가 반영되기 전에 Kafka 메시지를 발행 →
Kafka에서는 주문 성공으로 판단하지만 DB에는 실패 → 데이터 불일치 발생

**해결 방법**:

* 트랜잭션 후 실행되는 **`TransactionSynchronizationManager.registerSynchronization()`** 사용
* **Outbox 패턴** 또는 **이벤트 발행 → 비동기 소비 패턴**으로 해결


### ✅ Q12. 트랜잭션 전파 옵션에서 REQUIRED vs REQUIRES\_NEW의 차이를 실제 예시로 설명해보세요.

**답변:**

| 항목 | REQUIRED                          | REQUIRES\_NEW                     |
| -- | --------------------------------- | --------------------------------- |
| 정의 | 기존 트랜잭션 참여, 없으면 새로 생성             | 항상 새로운 트랜잭션 시작                    |
| 예시 | 회원가입 트랜잭션 안에서 포인트 지급 → 실패 시 전체 롤백 | 회원가입 실패해도 포인트 지급은 별도 처리하고 싶을 때 사용 |

예를 들어, 회원가입 중 이메일 인증 로그는 성공 여부와 관계없이 기록해야 하는 경우,
REQUIRES\_NEW로 별도 트랜잭션으로 분리하면 됩니다.


### ✅ Q13. Serializable 격리 수준에서 발생할 수 있는 실무 이슈는 무엇인가요?

**답변:**
`Serializable`은 가장 강력한 격리 수준이지만, 실무에서는 다음 문제가 발생합니다:

* **락 경합**: 모든 트랜잭션을 순차적으로 처리하므로 병렬성이 떨어짐
* **교착 상태(Deadlock)**: 여러 트랜잭션이 서로의 자원을 기다리다가 막히는 상황이 자주 발생
* **성능 저하**: 많은 트랜잭션이 대기하게 되므로 TPS가 급감할 수 있음

따라서 높은 정합성이 필요한 곳에서만 사용하며, 일반 업무에는 `REPEATABLE_READ` 또는 `READ_COMMITTED`가 실용적입니다.


### ✅ Q14. 무결성 제약 조건을 애플리케이션 레벨에서 검증해야 하는 이유는?

**답변:**
DB 제약 조건이 있다고 해도 **애플리케이션 레벨에서 선제적으로 체크**하는 것이 중요합니다.

이유:

* 사용자 경험(UX): 제약 위반으로 인해 SQL 예외가 터지면, 사용자에게 친절한 메시지를 주기 어렵습니다.
* 성능: 쿼리 실행 자체가 무거울 수 있고, DB까지 요청하지 않아도 되는 사전 검증 가능
* 비즈니스 로직 반영: ex) 이메일 중복 체크는 DB UNIQUE + 서비스 단 체크가 병행되어야 안정적


### ✅ Q15. 여러 DB 작업을 하나의 트랜잭션으로 묶기 위한 설계 고려사항은?

**답변:**

* **같은 DB 커넥션**을 사용해야 트랜잭션이 유효하게 묶입니다. (JPA의 영속성 컨텍스트 기준)
* 외부 시스템, 멀티 DB(MSA 구조)는 \*\*분산 트랜잭션(XA)\*\*이 필요하거나, **이벤트 기반 eventually consistent 설계**로 가야 합니다.
* 트랜잭션 간 의존성이 강한 경우, 도메인 모델을 재설계하여 트랜잭션 경계를 좁히는 것이 유지보수에 유리합니다.