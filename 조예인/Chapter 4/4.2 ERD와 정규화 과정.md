# 4.2 ERD와 정규화 과정
- ERD(Entity Relationship Diagram) : 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며,
  - 릴레이션 간의 관계들을 정의한 것 
- 만약 서비스를 구축한다면 가장 먼저 신경 써야 할 부분이며 
  - 이 부분을 신경 쓰지 않고 서비스를 구축한다면 단단하지 않은 골조로 건물을 짓는 것이나 다름없음

# 4.2.1 ERD의 중요성
- ERD는 시스템의 요구사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축함
- 데이터베이스를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할을 담당하기도 함
- 하지만 ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용할 수 있지만 
  - 단점 : 비정형 데이터를 충분히 표현할 수 없음

✔️ 용어  <br>  
- 비정형데이터 : 비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보를 말함

---

# 4.2.2 예제로 배우는 ERD
- 다음 예제의 서비스 요구 사항과 답을 기반으로 ERD를 작성하며 공부해불까요? 
- 참고로 정답 ERD의 테이블 필드, 타입은 생락했음

## 승원 영업부서의 ERD
### 요구 사항
- 영업사원은 0~n명의 고객을 관리함
- 고객은 0~n개의 주문을 넣을 수 있음
- 주문에는 1~n개의 상품이 들어감

### 정답
<img src="https://github.com/user-attachments/assets/7e06f6c7-ef8f-49f2-b2c2-dec4b6749fca" width="200"/>

## 무무오브레전드의 ERD
### 요구사항
- 선수들은 1명의 챔피언을 고를 수 있음
- 챔피언은 한 개 이상의 스킬을 가짐
- 스킬은 한 개 이상의 특성을 가짐

### 정답
<img src="https://github.com/user-attachments/assets/ff08f7fe-816d-4c76-a55a-8cfcca31c195" width="400"/>

---

# 4.2.3 정규화 과정
- 정규화 과정 : 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 
  - 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리 하는 과정
- 데이터베이스 이상 현상 : 회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나 
  - 삭제할 때 필요한 데이터가 같이 삭제되고, 
  - 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안 되어서 삽입하기 어려운 현상을 말함
- 정규화 과정 : 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 
  - 정규화된 정도는 정규형(NF, Normal Form)으로 표현함 
    - 기본 정규형인 제1정규형, 제2정규형, 제3 정규형, 보이스/코드 정규형이 있고 
    - 고급 정규형인 제4정규형, 제5정규형이 있음
    - 이 중 기본 정규형인 제1ㆍ2ㆍ3정규형, 보이스/코드 정규형을 알아보겠음

## 정규형원칙
- 정규형의 원칙 : 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 하고, 
  - 자료의 중복성은 감소해야 하고, 
  - 독립적인 관계는 별개의 릴레이션으로 표현해야 하며, 
  - 각각의 릴레이션은 독립적인 표현이 가능해야 하는 것을 말함

## 제1정규형
- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 함  
  - 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 됨
  - 만약에 반복 집합이 있다면 제거해야 함

<img src="https://github.com/user-attachments/assets/7c8e6722-1c53-481c-92d8-e203ddf88029" width="400"/>
- 앞의 그림처럼 홍철이란 ID에 수강명이 {C++코딩테스트 프런트특강}이 있었는데 이것을 나눠서 반복 집합을 제거하는 것을 불 수 있음

## 제2정규형
- 릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태를 말함 
- 부분 함수의 종속성 제거 : 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말함

<img src="https://github.com/user-attachments/assets/2bdc031e-8240-4a80-b9e7-16ccd2edbff7" width="400"/>

- 앞의 그림을 보면 기본키인 {유저ID, 수강명}과 완전 종속된 유저번호 릴레이션과 '{유저 ID, 수강명}에 따른 성취도' 릴레이션으로 분리된 것을 볼 수 있음
- 이때 주의할 점은 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 
  - 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 한다는 것
  
## 제3정규형
- 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태를 말함

### 이행적 함수 종속 
- 이행적 함수 종속 : A->B와 B->C가 존재하면 논리적으로 A->C가 성립하는데, 
  - 이 때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함

<img src="https://github.com/user-attachments/assets/c8512c65-5e1c-4466-a272-397dac74ace6" width="300"/>
- 예를 들어 무무쇼핑몰이 있다고 해봅시다. 
- 유저ID와 등급, 할인율이 정해져 있는 테이블을 다음과 같이 분해하는 것을 말함

<img src="https://github.com/user-attachments/assets/d8cf1c79-27c6-4b60-aae3-a44e9274c929" width="400"/>

## 보이스/코드 정규형(BCNF)
- 제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관제를 제거하여 
  - 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말함

✔️ 용어  <br>
- 결정자 함수 : 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소, 
  - 'X->Y'일 때 X는 결정자, Y는 종속자
  
- 요구 사항은 다음과 같음
  - 각 수강명에 대해 한 학생은 오직 한 강사의 강의만 수강함
  - 각 강사는 한 수강명만 담당함
  - 한 수강명은 여러 강사가 담당할 수 있음

<img src="https://github.com/user-attachments/assets/19ef2cf0-b710-4566-848a-587197875a57" width="300"/>

- 앞의 릴레이션을 보면 {학번, 수강명} 또는 {학번, 강사}가 후보키가 되며, 
  - 만약 범석이라는 강사가 '몰'이라는 수강명을 담당한다고 했을 때 이를 삽입하면 학번이 NULL이 되는 문제점이 발생 
- 또한, 이 릴레이션은 다음과 같은 함수 종속 다이어그램을 가짐


<img src="https://github.com/user-attachments/assets/015c8176-3f4d-433a-afcb-ae8561474d23" width="300"/>

- 즉, 강사 속성이 결정자이지만 후보키가 아니므로 이강사 속성을 분리해야 함

<img src="https://github.com/user-attachments/assets/f3e4efe7-a0b6-48ed-bcd4-84f6c3035a61" width="400"/>

- 앞의 그림처럼 롤-범석이 제대로 들어갔으며 학번-강사/수강명-강사로 잘 분해된 모습을 볼 수 있죠?
- 참고로 이렇게 정규형 과정을 거쳐 테이블을 나눈다고 해서 성능이 100% 좋아지는 것은 아님
- 성능이 좋아질 수도 나빠질 수도 있음 
- 테이블을 나누게 되면 어떠한 쿼리는 조인을 해야 하는 경우도 발생해서 오히려 느려질 수도 있기 때문에 
- 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 함

---
## ✅ 기본 질문과 답변

### ✅ Q1. 정규화란 무엇이며, 왜 필요하다고 생각하나요?

**A.**
- 정규화는 데이터 중복을 줄이고, 이상 현상을 방지하기 위해 테이블을 잘게 나누는 구조화 과정입니다.
- 릴레이션 간의 잘못된 종속 관계로 인해 발생할 수 있는 데이터 삽입/삭제/갱신 오류를 막고, 저장 공간을 효율적으로 사용하기 위해 진행합니다.

**💬 꼬리 질문**

* **Q. 항상 정규화가 유리한가요?**
  → 아닙니다. 지나친 정규화는 조인 비용을 높이고 성능 저하로 이어질 수 있어, 실무에서는 조회 성능을 위해 일부 비정규화를 허용하기도 합니다.

---

### ✅ Q2. 제1\~제3정규형과 BCNF를 각각 설명해주세요.

**A.**

* **제1정규형**: 모든 속성이 더 이상 쪼갤 수 없는 \*\*원자 값(Atomic Value)\*\*으로 구성되어야 합니다.
  예: 하나의 필드에 '자바,파이썬' 같이 여러 값이 들어가 있으면 안 됩니다.

* **제2정규형**: 제1정규형을 만족하고, **부분 함수 종속성 제거**
  → 기본키의 일부분에만 종속된 속성을 분리해야 합니다.

* **제3정규형**: 제2정규형이고, **이행적 함수 종속성 제거**
  → 기본키가 아닌 컬럼이 또 다른 컬럼을 결정짓는 구조를 분리합니다.

* **BCNF**: 제3정규형이면서 **모든 결정자가 후보키**여야 합니다.
  → 즉, 함수 종속 관계에서 결정자가 후보키가 아닐 경우 분해합니다.


### ✅ Q3. ERD는 왜 중요한가요?

**A.**
- ERD는 서비스의 요구사항을 시각적으로 정리한 데이터 모델입니다.
- → 데이터베이스 설계의 뼈대가 되며, 초기 설계가 잘못되면 이후 기능 추가나 디버깅이 매우 어렵습니다.
- 또한, 협업 시 다른 개발자나 기획자가 구조를 빠르게 파악할 수 있는 소통 도구이기도 합니다.


### ✅ Q4. 제2정규형과 제3정규형의 차이를 실례를 들어 설명해보세요.

**A.**

* **제2정규형 문제 예**:
  복합키 `{학생ID, 강의명}`이 기본키일 때, `학생이름`이 `학생ID`에만 종속되어 있다면 → 부분 종속 → 분리 필요

* **제3정규형 문제 예**:
  테이블에 `{회원ID, 등급, 할인율}`이 있을 때 `할인율`은 `등급`에 의해 결정됨 → 이행 종속 → `등급` 테이블로 분리


### ✅ Q5. BCNF 정규화는 제3정규형과 어떻게 다른가요?

**A.**
제3정규형은 이행적 종속만 제거하면 되지만,
**BCNF는 모든 결정자가 후보키인지까지 확인**해야 합니다.

예: `강사명 → 과목명`이고, `학생ID, 과목명`이 복합키일 경우
→ 강사명이 후보키가 아닌데 결정자 역할을 함 → BCNF 위반 → `강사` 테이블로 분리해야 함


### ✅ Q6. 정규화된 테이블은 실무에서 어떻게 비정규화되나요?

**A.**

* 조인 비용을 줄이기 위해 일부 정보를 중복 저장합니다.
* 예: 주문 테이블에 `회원명`, `배송주소`를 함께 저장해서 주문 목록 조회 시 회원 테이블을 조인하지 않게 만듭니다.
* 단, **데이터 무결성 유지와 비용 간 균형**이 필요합니다.


### ✅ Q7. 정규화 과정 중 무손실 분해는 무엇인가요?

**A.**
- 정규화를 위해 릴레이션을 분해할 때, **원래의 데이터 관계를 복원할 수 있어야 함**을 말합니다.
- 즉, 분해 전 테이블을 조인했을 때 분해 후 테이블들과 동일한 데이터를 얻을 수 있어야 무손실 분해입니다.


### ✅ Q8. ERD 작성 시 흔히 하는 실수는 무엇인가요?

**A.**

* 1\:N과 N\:M 관계를 혼동하여 중간 테이블을 생략하거나 잘못 구성하는 경우
* 중복되는 속성을 여러 테이블에 넣어 **데이터 중복과 이상 현상**을 유발하는 경우
* 테이블 이름을 구체적이지 않게 짓는 경우 (`Info`, `Data` 등은 피해야 함)

---

## ✅ 심화 질문과 답변

### ✅ Q1. ERD는 왜 백엔드 개발자에게 중요한가요?

**A.**
- ERD는 데이터베이스의 구조를 시각적으로 설계한 도면입니다.
- 요구사항 분석 → 테이블 설계 → 실제 구현까지 일관성을 유지하게 해주며,
- **협업, 유지보수, 확장성 측면에서도 큰 역할**을 합니다.
- 서비스 구조가 복잡해질수록 ERD의 정확도가 실질적인 성능과 개발 속도에 영향을 줍니다.

**💬 꼬리 질문**
- Q. ERD 없이 개발하는 팀을 본 적 있나요?
- → 일부 스타트업 초기엔 ERD 없이 개발하는 경우도 있는데, 이후 변경 요구나 버그가 생기면 데이터 관계를 파악하기 어렵고, 기능 추가나 마이그레이션이 매우 비효율적입니다.


### ✅ Q2. 정규화의 목적은 무엇이며, 꼭 필요한가요?

**A.**
- 정규화는 데이터의 **중복 제거**와 **이상현상 방지**를 통해 **데이터 무결성 유지**와 **저장공간 최적화**를 목표로 합니다.
- 하지만 모든 상황에서 정규화가 정답은 아니며, 실무에선 조회 성능을 위해 **비정규화**를 병행하는 경우도 많습니다.

**💬 꼬리 질문**
- Q. 그럼 정규화를 어디까지 적용하고, 언제 비정규화하나요?
- → 대부분 **3NF 또는 BCNF까지 정규화**한 후, 조회가 잦은 경우 **JOIN을 줄이기 위해 비정규화**합니다. 예: 주문 목록 조회를 위해 사용자 이름, 주소 등을 주문 테이블에 중복 저장.


### ✅ Q3. 제1정규형(1NF)의 정의와 실무 예시를 설명해주세요.

**A.**
- 1NF는 **모든 필드가 원자값**만 가지는 구조입니다.
- 예: 사용자의 연락처 컬럼에 `010-1234-5678, 010-2345-6789`처럼 **복수의 값을 넣는 것**은 1NF 위반입니다. → 별도 연락처 테이블로 분리해야 합니다.


### ✅ Q4. 제2정규형과 제3정규형의 차이를 실무 사례로 설명해주세요.

**A.**

* **2NF**는 부분 종속 제거입니다. 예: `{회원ID, 상품ID}`를 PK로 가진 리뷰 테이블에서 `회원이름`은 `회원ID`에만 종속 → 회원 테이블로 분리
* **3NF**는 이행 종속 제거입니다. 예: 회원 테이블에 `회원ID → 등급 → 할인율`이라면 할인율은 등급 테이블로 분리


### ✅ Q5. 보이스 코드 정규형(BCNF)은 제3정규형과 무엇이 다르며, 언제 필요하나요?

**A.**
- BCNF는 모든 **함수 종속의 결정자가 반드시 후보키여야 함**을 추가로 요구합니다.
- 예를 들어, `강사명 → 과목`, `학생ID + 과목`이 PK라면, 강사가 후보키가 아니더라도 결정자 역할을 하므로 분리 대상이 됩니다.
- → **강사 테이블을 별도로 분리**해 정규화합니다.


### ✅ Q6. ERD 설계 시 자주 발생하는 실수는 무엇인가요?

**A.**

* **N\:M 관계에 중간 테이블이 빠진 경우** (ex: 유저와 태그)
* **중복된 속성 컬럼 반복**
* **관계 방향이 잘못된 외래키 설계**
* **불명확한 네이밍 (Info, Temp 등)**
* **정규화/비정규화 기준 없이 무작정 테이블 쪼갬**


### ✅ Q7. 중간 테이블이 필요한 이유는 무엇인가요? (예: N\:M 관계)

**A.**
- 관계형 데이터베이스는 **N\:M 관계를 직접 표현할 수 없어**, 중간 테이블을 통해 두 개의 1\:N 관계로 변환합니다.
- 예: `User - UserRole - Role` 구조처럼 `UserRole`이 중간 테이블 역할을 하며, **복수의 유저와 복수의 역할 연결**을 가능하게 합니다.

**💬 꼬리 질문**
- Q. 중간 테이블에 추가 정보가 필요하다면?
- → 단순 조인 테이블이 아닌 **명시적인 엔티티(예: `UserRole`)로 선언하고, 등록일 등 부가 정보를 함께 가집니다.**


### ✅ Q8. ERD가 NoSQL 기반 시스템에서는 어떻게 달라지나요?

**A.**
- NoSQL은 **정규화 대신 중복을 허용하는 구조**입니다.
- ERD보다는 **Document 구조 설계**가 더 중요하며, JOIN 대신 **중첩 문서나 ID 참조 방식**을 활용합니다.
- MongoDB의 경우 ERD처럼 \*\*관계를 시각화하는 도구(MongoDB Compass, Draw\.io 등)\*\*를 활용해 문서 관계를 정리합니다.


### ✅ Q9. ERD 설계 이후 실무에서 어떻게 활용되나요?

**A.**

* 개발 초기: 요구사항 반영 확인 및 DB 설계 베이스
* 개발 중: JPA, SQL 쿼리 작성 시 구조 확인
* 운영 중: 디버깅, 쿼리 튜닝, 마이그레이션 시 참고
* 팀 협업: 설계 의도 파악, 테이블 간 의존성 분석

---
## ✅ 추가 심화 질문과 답변

### ✅ Q1. 정규화를 진행할 때 성능과 무결성 사이에서 어떤 기준으로 트레이드오프를 결정하시나요?

**A.**
- 정규화는 무결성과 중복 제거에 유리하지만, JOIN이 많아져 **조회 성능**에 악영향을 줄 수 있습니다.
- 따라서 다음 기준에 따라 결정합니다:

* **읽기 빈도가 높은 쿼리**: 비정규화를 고려 (ex. 게시글 목록에 작성자명 함께 보여줄 경우)
* **쓰기/수정이 많은 데이터**: 정규화를 유지해 데이터 정합성 확보
* **실시간 API**: JOIN 최소화를 위해 일부 컬럼 중복 허용
* **운영/데이터 분석 목적 테이블**: 최대한 정규화하여 정합성 유지

실제 프로젝트에서는 ERD 설계 단계에서 **사용 시나리오별 조회 방식**을 미리 정의하고 이에 따라 **정규화 수준을 조정**합니다.


### ✅ Q2. 정규화된 테이블이 너무 많아서 JOIN이 과도하게 발생할 때 어떻게 개선할 수 있나요?

**A.**
JOIN이 많아질수록 성능 병목이 발생하므로 다음과 같은 방법으로 개선할 수 있습니다:

* **View 또는 Materialized View 생성**: 자주 조회되는 결과를 정적으로 유지
* **캐싱 계층 도입**: Redis를 이용해 정규화된 결과를 키 기반으로 저장
* **CQRS 분리**: Command(DB 정규화 유지) / Query(조회 최적화용 비정규 테이블) 구조 분리
* **JPA DTO Projection**: 필요한 필드만 뽑아내도록 Repository Layer에서 최적화

이처럼 “정규화는 데이터 저장의 원칙”, “조회는 성능 중심”으로 분리해서 설계합니다.


### ✅ Q3. 정규화된 테이블이지만 실제 서비스 요구사항을 반영하지 못할 때는 어떻게 대응하시나요?

**A.**
정규화는 데이터 이상을 방지하지만, **비즈니스 로직에 유연하게 대응하지 못하는 경우**가 있습니다.
이럴 땐 다음 방법을 고려합니다:

* **도메인 주도 설계(Domain-Driven Design)** 방식으로 Aggregate를 기준으로 다시 테이블 구조 설계
* **읽기 전용 비정규화 테이블 추가 생성**
* JPA를 사용한다면, **Entity 단위는 정규화 구조**를 유지하되, **DTO/Service Layer에서는 View 형태**로 조합

즉, DB 설계만으로 모든 문제를 해결하려 하지 않고, **계층 분리와 역할 분담**으로 유연하게 설계합니다.


### ✅ Q4. JPA에서 정규화를 기반으로 설계한 ERD를 그대로 매핑할 때 주의할 점은 무엇인가요?

**A.**

* **양방향 연관관계의 무분별한 설정**: 순환참조 및 LazyLoading N+1 문제 발생
* **복합키 매핑 시 @Embeddable 사용**: 하지만 복잡해질 수 있어 가급적 Surrogate Key 사용
* **@ManyToMany 지양**: 중간 테이블이 실무에선 속성 갖는 경우가 많기 때문에 명시적 엔티티 권장
* 정규화된 ERD에서는 외래키가 많기 때문에 `@JoinColumn` 등을 명시적으로 관리하여 **명확한 의도 전달** 필요


### ✅ Q5. ERD 설계 시 ENUM과 참조 테이블 중 어떤 방식을 선택하나요?

**A.**
다음 기준으로 결정합니다:

* **변경 가능성 없음 (성별, 상태 코드)**: ENUM 사용
* **관리 UI 필요 / 빈번한 수정 가능성 있음 (카테고리, 등급 등)**: 참조 테이블 사용
* **ENUM을 쓰되 DB에는 `VARCHAR`로 저장**하고, `@Enumerated(EnumType.STRING)`와 Bean Validation(@Pattern, 커스텀 Validator 등)으로 무결성 확보

또한 실무에서는 **참조 테이블에도 Soft Delete**, 생성자/수정자 필드, 정렬용 컬럼 등을 포함해 관리합니다.


### ✅ Q6. BCNF 정규화를 적용했더니 과도한 테이블 분해가 발생했습니다. 이를 어떻게 해결할 수 있나요?

**A.**
BCNF는 이론적으로 바람직하지만 실무에서는 너무 많은 테이블이 생겨 JOIN 과다, 유지보수 복잡도가 증가합니다.

해결 방법:

* **3NF까지만 적용 후, 의도적으로 일부 이행 종속을 허용**
* **조회용 API에서는 비정규화된 DTO 활용**
* **데이터 모델은 BCNF, 서비스 로직은 3NF 기반으로 유연하게 조정**

결론적으로 **정규화는 원칙, 성능과 유지보수는 현실**이라는 관점에서 타협점을 찾습니다.


### ✅ Q7. ERD를 기준으로 마이그레이션 계획을 어떻게 수립하시나요?

**A.**

1. **ERD 변경사항 정리** (정규화, 컬럼 변경, 관계 추가 등)
2. **DDL 스크립트 작성** (ALTER TABLE, CREATE INDEX 등)
3. **데이터 이관 로직 작성** (ETL, SQL INSERT, Python 등)
4. **무중단 배포 전략 적용** (예: 컬럼 추가 → Dual Write → 컬럼 삭제)
5. **롤백 플랜 확보**

**도구 예시**:

* Liquibase / Flyway (버전 관리)
* ERDCloud / dbdiagram.io (협업 및 리뷰)


### ✅ Q8. NoSQL 기반이라면 정규화 개념이 아예 무의미한가요?

**A.**
NoSQL에서도 **정규화 원칙은 존재**하지만, 정규화보다는 **성능과 모델링 유연성**이 더 중요하게 여겨집니다.

* Document DB(MongoDB 등): 중복 저장 허용, 읽기 성능 극대화
* Key-Value DB(Redis 등): 정규화 불가, 오히려 Flatten 구조가 성능상 이점

다만, **정합성 유지가 중요한 경우**, ID 참조나 Eventual Consistency 기반 보완 로직이 필요합니다.


