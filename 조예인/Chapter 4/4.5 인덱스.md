# 4.5 인덱스

# 4.5.1 인덱스의 필요성
- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치 
- ex) 책의 마지막 장에 있는 찾아보기

✔️ 그림 4-35 인덱스  <br>

<img src="https://github.com/user-attachments/assets/b50bbfbd-8f3a-489a-a0dd-e64703d40a8c" width="400"/>

- 책의 본문이 있고 그 본문 안에 내가 찾고자 하는 '항목'을 찾아보기를 통해 빠르게 찾을 수 있음 
  - 이와 마친가지로 인테스를 설정하면 테이블 안에 내가 찾고자 하는 데이터 를빠르게 찾을 수 있음

---

# 4.5.2 B-트리
- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음 
  - 이는 루트 노드, 리프 노드, 그리고 루트 노드와 리프 노트 사이에 있는 브랜치 노드로 나뉨
- 먼저 루트 노드와 리프 노드를 기반으로 설명하면 다음과 같음

✔️ 그림 4-36 B-트리 예제 1  <br>

<img src="https://github.com/user-attachments/assets/2a45a812-b2d6-4af8-8575-d0fbffb47f37" width="400"/>

- ex) E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라 
  - E가 있을 법한 리프 노드로 들어가서 E를 탐색하면 쉽게 찾을 수 있음
- 이 자료 구조 없이 E를 탐색하고자 하면 A, B. C, D, E 다섯 번을 탐색해야 하지만, 
  - 이렇게 노드들로 나누면 두 번만에 리프 노드 에서 찾을 수 있음
- ex) 키 57에 해당하는 데이터를 검색해야 하는 예시

✔️ 그림 4-37 B-트리 예제 2  <br>

<img src="https://github.com/user-attachments/assets/13984669-92a9-476d-924a-7521cfefea9d" width="400"/>

- 트리 탐색은 맨 위 루트 노드부터 탐색이 일어나며 브랜치 노드를 거처 리프 노드까지 내려옴 
- '57보다 같거나 클 때까지 <='를 기반으로 처음 루트 노드에서는 39, 83 
  - 이후 아래 노드로 내려와 46, 53, 57 등 정렬된 값을 기반으로 탐색하는 것을 볼 수 있음 
  - 이렇게 루트 노드부터 시작하여 마지막 리프 노드에 도달해서 57이 가리키는 데이터 포인터를 통해 결괏값을 반환하게 됨

## 인덱스 효율적인 이유와 대수확장성
- 인덱스가 효율적인 이유 : 효율적인 단계를 거처 모든 요소에 집근합 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수학장성 때문
- 대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미함 
  - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

✔️ 표4-3 트리의 대수화장성   <br>

| 트리 깊이 | 인덱스 항목 수 |
|-----------|----------------|
| 3         | 64             |
| 4         | 256            |
| 5         | 1,024          |
| 6         | 4,096          |
| 7         | 16,384         |
| 8         | 65,536         |
| 9         | 262,144        |
| 10        | 1,048,576      |


- 앞의 표처럼 트리 깊이는 열 개짜리로, 100만 개의 레코드를 검색할 수 있다는 의미
  - 참고로 실제 인덱스는 이것보다 휠씬 더 효율적이며, 그렇기 때문에 인덱스가 효율적이라고 볼 수 있음

---

# 4.5.3 인덱스 만드는 방법
- 인덱스를 만드는 방법은 데이터베이스마다 다르며 MySQL과 MongoDB를 기준으로 설명함

## MySQL
- MySQL의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있으며, 
  - 클러스터형 인덱스는 테이블당 하나를 설정할 수 있음
- primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고
  - 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스 터형 인덱스로 만들 수 있음
- create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있음 
  - 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋음
- 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 퀴리를 많이 보낼 때 생성해야 하는 인덱스 
- ex) age라는 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요하겠죠? 
  - 하지만 age, name, email 등 다양한 필드를 기반으로 쿼리를 보낼 때는 세컨더리 인덱스를 시용헤야 함

## MongoDB
- MongoDB의 정우 도뷰먼트를 만들면 자동으로 ObjcctID가 형성되며, 해당 키가 기본키로 설정됨 
- 그리고 세컨더리키도 부가적으로 설정해서 기본키와 세건더리키를 같이 쓰는 복합 인덱스를 설정할 수 있음

---

# 4.5.4 인덱스 최적화기법
- 인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문에 
  - 특정 데이터베이스를 기준으로 설명해도 무방함 
- 이 책에서는 MongoDB를 기반 으로 인덱스 최적화 기법을 설명하며, 
  - 이를 기반으로 다른 데이터베이스에 웬만큼 적용할 수 있음
  
## 1. 인덱스는 비용이다
- 먼저 인덱스는 두 번 탐색하도록 강요함 
  - 인덱스 리스트, 그다음 컬렉선 순으로 탐색 하기 때문이며, 관련 읽기 비용이 들게 됨 
- 또한, 컬렉션이 수정 되었을 때 인덱스도 수정되어야 함 
  - 마치 책의 본문이 수정되었을 때 목차나 찾아보기도 수정해야 하듯이 말이죠
  - 이때 B-트리의 높이를 균형 있게 조 절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 됨 
- 그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아님
  - 또한, 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적

## 2. 항상 테스팅하라
- 인덱스 최적화 기법은 서비스 특징에 따라 달라짐
  - 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문
- 그렇기 때문에 항상 테스팅하는 것이 중요함 
- explain() 합수를 통해 인빅스를 민들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 함
- 참고로 MySQL에서는 다음과 같은 코드로 테스팅을 수행함
```SQL
   EXPLAIN
   SELECT * FROM t1
   JOIN t2 ON t1.c1 = t2.c1
```   

## 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
- 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 
  - 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라wla
  - 같음, 정렬, 다중 값, 카디 널리티 순으로 생성해야 함
1. 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정함 
2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정함
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 <등 많은 값을 출력해야 하는 퀴리에 쓰는 필드라면 나중에 인덱스를 설정함
4. 유니크한 값의 정도를 카디널리티라고 함 
   - 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성 해야 함 
   - ex) age와 email이 있다고 해봅시다. 어떤 것이 더 높죠? 당연히 email
   - 즉, email이라는 필드에 대한 인덱스를 먼저 생성해야 하는 것

---
## ✅ 기본 질문과 답변

---

### ✅ 1. 인덱스란 무엇이고, 왜 필요한가요?

**질문 의도**: 인덱스의 개념과 필요성에 대한 기본 이해 확인

**답변 예시**:
인덱스는 데이터베이스에서 특정 데이터를 빠르게 찾기 위한 자료구조입니다.
마치 책의 찾아보기처럼, 테이블 전체를 훑지 않고도 원하는 데이터를 효율적으로 조회할 수 있게 해줍니다.
보통 B-트리 구조를 사용하며, 트리 깊이에 따라 대수적으로 성능이 확장되어 수십만 건의 데이터도 빠르게 검색할 수 있습니다.

---

### ✅ 2. MySQL에서 인덱스의 종류와 차이점은 무엇인가요?

**질문 의도**: RDBMS 인덱스 구조와 사용법 이해도 확인

**답변 예시**:
MySQL에서는 대표적으로 **클러스터형 인덱스**와 **세컨더리 인덱스**가 있습니다.
클러스터형 인덱스는 기본키(primary key)나 unique not null 필드에 설정되며, 데이터 자체가 인덱스 구조에 포함됩니다.
세컨더리 인덱스는 보조 인덱스로, 여러 필드 조합에 대해 별도로 만들어야 하며, 인덱스를 통해 포인터로 실제 데이터를 조회합니다.
일반적으로 조회 성능은 클러스터형이 더 좋지만, 다양한 조건이 필요한 경우에는 세컨더리 인덱스를 활용합니다.

---

### ✅ 3. 인덱스를 너무 많이 만들면 왜 안 되나요?

**질문 의도**: 인덱스의 부작용 및 실무 고려사항 확인

**답변 예시**:
인덱스는 조회 성능을 높이지만, 유지 비용이 있습니다.
데이터가 삽입, 수정, 삭제될 때마다 인덱스도 갱신되므로 성능 저하가 발생할 수 있고, 디스크 공간도 더 많이 사용됩니다.
특히, 컬렉션 전체를 자주 읽는 경우에는 인덱스를 거치느라 오히려 성능이 떨어질 수 있어, 무작정 인덱스를 만드는 것은 지양해야 합니다.

---

### ✅ 4. B-트리는 왜 인덱스에 적합한 자료구조인가요?

**질문 의도**: 자료구조와 DB 설계 연계 이해도 확인

**답변 예시**:
B-트리는 균형 이진트리의 일종으로, 데이터가 정렬된 상태로 유지되며 트리의 깊이를 일정하게 유지합니다.
이 덕분에 **검색, 삽입, 삭제 연산이 모두 logN 시간**에 처리되고, 디스크 접근 횟수를 줄일 수 있습니다.
또한 리프 노드까지 내려가는 트리 깊이도 느리게 증가하는 **대수확장성** 특성 덕분에 수십만 건의 데이터도 빠르게 탐색할 수 있어 인덱스에 매우 적합합니다.

---

### ✅ 5. 복합 인덱스를 만들 때 고려해야 할 요소는?

**질문 의도**: 인덱스 튜닝 실무 이해도 확인

**답변 예시**:
복합 인덱스를 만들 때는 필드의 **조회 조건의 사용 빈도와 형태**를 기준으로 순서를 정해야 합니다.
일반적으로 "같음 → 정렬 → 범위조건 → 카디널리티(유일도 높은 값)" 순으로 구성하는 것이 성능상 유리합니다.
예를 들어, `WHERE email = ? AND age > ?` 쿼리를 자주 사용한다면 email을 먼저, age를 나중에 인덱스에 포함시켜야 효율적입니다.

---

### ✅ 6. MongoDB에서 인덱스는 어떻게 관리되며, 기본 인덱스는 어떻게 생성되나요?

**질문 의도**: NoSQL 데이터베이스 사용 경험과 이해도 확인

**답변 예시**:
MongoDB는 도큐먼트를 생성할 때 자동으로 `_id` 필드에 대해 인덱스를 생성하며, 이는 기본 인덱스로 사용됩니다.
추가로, 필요한 필드에 대해 `createIndex()` 명령어를 사용해 세컨더리 인덱스를 만들 수 있으며, 복합 인덱스나 정렬, 텍스트 검색, 해시 기반 인덱스도 설정 가능합니다.
인덱스 성능은 `explain()` 명령어를 통해 확인하고 분석할 수 있습니다.

---

## ✅ 심화 질문과 답변

### ❓ 질문 1: 인덱스는 무조건 성능을 향상시킬까요?

**답변:**

아닙니다. 인덱스는 조회 성능을 향상시키지만, 그에 따른 비용도 존재합니다.
데이터 삽입, 수정, 삭제 시 인덱스도 함께 갱신되어야 하기 때문에 DML 작업이 많은 테이블에는 오히려 성능 저하 요소가 될 수 있습니다.
또한, 인덱스가 너무 많으면 오히려 옵티마이저가 잘못된 인덱스를 선택하거나, 메모리 낭비로 이어질 수 있습니다.

그래서 저는 인덱스 설정 시, **쿼리 분석 → 사용 빈도 높은 컬럼 → 인덱스 후보 도출 → EXPLAIN로 성능 측정 → 선택** 순으로 적용합니다.

---

### ❓ 질문 2: 인덱스가 B-트리로 구성되는 이유는 무엇인가요?

**답변:**

B-트리는 **균형 잡힌 다진 검색 트리** 구조로, 탐색, 삽입, 삭제 시에도 성능이 일정하게 유지됩니다.
특히 인덱스는 "디스크 기반의 저장소"이기 때문에 **노드 수를 최소화하면서도 빠른 탐색이 가능한 자료구조**가 필요합니다.

트리의 깊이가 깊어질수록 I/O가 많아지지만, B-트리는 한 단계 깊어질 때마다 인덱스 항목 수가 4배씩 늘어나기 때문에 `대수 확장성(log n)`을 보장합니다.
예를 들어 트리 깊이 4에서 256개, 깊이 8에서는 65,536개까지 커버할 수 있기 때문에 **1\~2번의 디스크 I/O로 수십만 건을 커버할 수 있습니다.**

---

### ❓ 질문 3: 클러스터형 인덱스와 세컨더리 인덱스의 차이와 선택 기준은?

**답변:**

* **클러스터형 인덱스**: 실제 데이터가 인덱스 순서대로 정렬되어 저장됩니다. 테이블당 하나만 존재하며, `PRIMARY KEY`로 지정하면 생성됩니다.
* **세컨더리 인덱스**: 데이터와는 별도로 관리되며, 실제 데이터를 가리키는 포인터만 갖고 있습니다.

**선택 기준:**

* `자주 사용하는 기준 키`에 대해 클러스터형 인덱스를 부여하는 것이 좋습니다.
* `복잡한 조회`, `다중 조건`, `보조 컬럼`에 대해서는 세컨더리 인덱스를 복합으로 설정합니다.

예를 들어 유저 테이블에서 userId는 클러스터형, email이나 nickname은 세컨더리 인덱스로 구성합니다.

---

### ❓ 질문 4: 복합 인덱스를 구성할 때 순서를 고려해야 하는 이유는?

**답변:**

복합 인덱스의 **컬럼 순서**는 쿼리 성능에 직접적인 영향을 미칩니다.
MySQL의 인덱스는 **왼쪽부터 차례대로 탐색**하기 때문에, 순서가 맞지 않으면 인덱스를 사용할 수 없습니다.

일반적으로 다음과 같은 순서를 따릅니다:

1. **같음(=)** 조건 필드
2. **정렬(ORDER BY)** 대상
3. **범위 조건(> < BETWEEN)**
4. **카디널리티 높은 필드 (유니크 값 많음)**

이 순서로 설정하면 옵티마이저가 인덱스를 최대한 효율적으로 사용할 수 있습니다.

---

### ❓ 질문 5: MongoDB에서 인덱스 성능 최적화는 어떻게 하나요?

**답변:**

MongoDB는 JSON 기반 문서 DB이기 때문에 쿼리 성능 향상을 위해 세밀한 인덱스 전략이 필요합니다.

* **복합 인덱스 생성 시 필드 순서 최적화**
* **인덱스 통계 확인**: `db.collection.explain()` 명령으로 실행 계획을 분석합니다.
* **불필요한 인덱스 제거**: 쿼리 패턴을 기반으로 정리
* **TTL 인덱스**: 만료되는 데이터를 자동 삭제
* **Partial Index / Sparse Index**를 통해 저장 공간과 성능 최적화

MongoDB에서는 B-트리 기반 구조를 쓰되, `도큐먼트 크기`, `조회 필드`, `데이터 변동성` 등을 고려해서 인덱스를 신중하게 구성합니다.

---
## ✅ 추가 심화 질문과 답변

---

### ❓ Q1. 인덱스가 설정되어 있어도 쿼리가 느려질 수 있는 경우는 언제인가요?

**A.**
인덱스가 있어도 다음과 같은 이유로 쿼리 성능이 저하될 수 있습니다:

* **인덱스 선택 실패 (Index Miss)**: 옵티마이저가 잘못된 인덱스를 선택했거나, 범위가 넓은 조건에서 인덱스를 포기하고 풀스캔을 수행한 경우
* **함수 사용**: `WHERE DATE(created_at) = '2024-01-01'`처럼 컬럼에 함수가 적용되면 인덱스가 무효화됩니다.
* **형변환**: `WHERE phone_number = 01012345678`와 같이 문자열 컬럼에 숫자 조건이 들어가면 암시적 형변환으로 인덱스 사용이 불가합니다.
* **OR 조건**: `OR` 연산자가 여러 조건을 포함할 경우, 인덱스를 타지 못할 수 있습니다. 이때는 `UNION ALL`로 분리하는 것이 좋습니다.

---

### ❓ Q2. Composite Index(복합 인덱스)와 Index Merge 기법의 차이는 무엇인가요?

**A.**

* **Composite Index**는 여러 필드를 조합한 하나의 인덱스로, **선두 조건부터 차례로 만족해야** 사용 가능합니다.
  예: `(name, age)` 인덱스는 `WHERE name = '철수'`는 가능하지만 `WHERE age = 20`은 불가능합니다.

* **Index Merge**는 MySQL 옵티마이저가 **여러 단일 인덱스를 병합해서** 쿼리를 수행하는 방식입니다.
  예: `name`과 `age`에 각각 인덱스가 있을 때, `WHERE name = '철수' OR age = 20` 같은 쿼리는 두 인덱스를 병합하여 처리할 수 있습니다.

Index Merge는 편리하지만, 복합 인덱스에 비해 성능이 떨어질 수 있습니다.

---

### ❓ Q3. B-트리 인덱스와 Hash 인덱스의 차이점은?

**A.**

| 항목       | B-Tree 인덱스                  | Hash 인덱스              |
| -------- | --------------------------- | --------------------- |
| 구조       | 정렬된 트리 구조                   | Key → Value 형태 해시 테이블 |
| 지원 연산    | 범위 검색, 정렬, Like 검색 등 다양     | 정확히 일치하는 값 조회에만 효율    |
| 대표 사용 DB | MySQL(InnoDB), PostgreSQL 등 | Memory 엔진, Redis 등    |
| 단점       | 비교적 느린 성능 (일치 조회 기준)        | 범위, 정렬 불가, 충돌 가능성 있음  |

MySQL에서는 **MEMORY 스토리지 엔진**이 Hash 인덱스를 사용하는 예외적인 경우가 존재합니다.

---

### ❓ Q4. 인덱스가 과도하게 많으면 어떤 문제가 발생하나요?

**A.**
인덱스가 많을수록 다음과 같은 문제가 발생할 수 있습니다:

* **쓰기 성능 저하**: INSERT/UPDATE/DELETE마다 인덱스를 갱신해야 하므로 DML 비용이 증가합니다.
* **저장 공간 낭비**: 각 인덱스는 메타데이터와 함께 저장되어 공간을 차지합니다.
* **쿼리 성능 저하**: 옵티마이저가 여러 인덱스 중 잘못된 인덱스를 선택할 가능성이 있습니다.
* **복잡한 유지관리**: 데이터 구조 변경 시 인덱스도 수정해줘야 하므로 관리 부담이 커집니다.

그래서 실무에서는 **사용 빈도 기반 + EXPLAIN 분석 + 주기적인 인덱스 제거 검토**를 병행합니다.

---

### ❓ Q5. covering index란 무엇이고, 왜 중요한가요?

**A.**
**Covering Index**는 쿼리에서 사용되는 **모든 컬럼을 인덱스에 포함시켜서**, **데이터 페이지를 조회하지 않고도 결과를 반환할 수 있는 인덱스**입니다.

예시:

```sql
CREATE INDEX idx_user_email_age ON users (email, age);
SELECT email, age FROM users WHERE email = 'test@example.com';
```

→ 이 경우 `email`과 `age` 모두 인덱스에 포함되어 있어, 별도의 테이블 조회 없이 인덱스 스캔만으로 결과를 반환할 수 있습니다.

**장점:**

* Disk I/O 횟수 감소 (인덱스 레벨에서 처리 완료)
* 쿼리 속도 향상

---

### ❓ Q6. Unique Index와 Primary Key의 차이점은?

**A.**

| 구분         | Primary Key           | Unique Index      |
| ---------- | --------------------- | ----------------- |
| NULL 허용 여부 | 허용되지 않음 (NOT NULL 필수) | 하나의 NULL은 허용      |
| 개수 제한      | 테이블당 1개만 설정 가능        | 여러 개 생성 가능        |
| 용도         | 엔터티의 유일 식별자           | 특정 조건의 중복 방지 목적   |
| 기본 동작      | 클러스터형 인덱스로 설정         | 기본은 세컨더리 인덱스로 설정됨 |
