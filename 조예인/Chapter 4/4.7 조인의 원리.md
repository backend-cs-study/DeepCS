# 4.7 조인의 원리
- 앞서 설명한 조인은 조인의 원리를 기반으로 조인 작입이 이루어짐
- 조인의 원리인 중첩 루프 조인, 정렬 병합 조인, 해시 조인에 대헤 알아봄
- 앞서 설명한 조인의 종류는 이 원리를 기반으로 조인을 히는 것

---

# 4.7.1 중첩 루프 조인(NLJ, Nested Loop Join)
- 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법이며,
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음
- ex) "t1, t2 테이블을 조인한다."라고 했을 때
    - 첫 번째 테이블에서 행을 한 번에 하나씩 읽고
    - 그다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값을 반환함

- 의사코드
```SQL
   for each row in t1 matching reference key {
    for each row in t2 matching reference key {
        if row satisfies join conditions, send to client
    }
   }
```  
- 참고로 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠서 블록 하나석 조인하는
    - 블록 중첩 루프 조인(BNL, Block Nested Loop)이라는 방식도 있음

---

# 4.7.2 정렬 병합 조인
- 각각의 테이블을 조인한 필드 기준으로 정별하고 정별이 끝난 이후에 조인 작업을 수행하는 조인
    - 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블 들을 조인하고
    - 조인 조건으로 <,> 등 범위 비교 연산자가 있을 때 씀

---

# 4.7.3 해시 조인
- 해시 테이블을 기반으로 조인하는 방법
    - 두 개의 테이블을 조인한다고 했을 때
    - 하나의 테이블이 메모리에 온전히 들어간다면 보통 중접 루프 조인보다 더 효율적
    - (메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용이 발생됨)
    - 또한, 동등(=) 조인에서만 사용할 수 있음
- MySQL의 경우 MySQL8.0.18 릴리스와 함께 이 기능을 사용할 수 있게 되었으며 이를 기반으로 해시 조인의 과정을 살펴봄
- MySQL의 해시 조인 단계는 빌드 단계, 프로브 단계로 나뉨

## 빌드단계
- 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
- ex) persons와 countries라는 테이블을 조인한다고 했을 때
    - 둘 중에 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드합

✔️ 그림 4-40 빌드단계  <br>

<img src="https://github.com/user-attachments/assets/5dadb1f9-aec5-45b1-9871-d30284016588" width="600"/>

- 또한, 조인에 사용되는 필드가 해시 테이블의 키로 사용됨
- 'countries.country_id'가 키로 사용되는 것을 볼 수 있음

## 프로브 단계
- 프로브 단계 동안 레코드 읽기를 시작하며,
- 각 레코드에서 'persons.country_id'에 일치하는 레코드를 찾아서 결괏값으로 반환함

✔️ 그림 4-41 프로브단계  <br>

<img src="https://github.com/user-attachments/assets/3c8b3d93-f04f-4c04-a085-6fe95cb27881" width="600"/>

- 이를 통해 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋음
    - 참고로 사용 가능한 메모리양은 시스템 변수 join buffer size에 의해 제어되며, 런타임 시에 조정할 수 있음

---
## ✅ 기본 질문과 답변

---

### ✅ Q1. 조인에는 여러 종류가 있는데, 그 내부 동작 원리에는 어떤 방식들이 있나요?

**A.**
조인의 내부 동작 방식은 주로 다음 세 가지로 분류됩니다:

1. **중첩 루프 조인(Nested Loop Join)**:
   두 테이블을 각각 반복문처럼 탐색하여 조건에 맞는 데이터를 찾는 방식입니다.
   → 소규모 데이터나 인덱스가 잘 잡힌 경우 사용됩니다.

2. **정렬 병합 조인(Sort-Merge Join)**:
   두 테이블을 조인 조건 컬럼 기준으로 정렬한 후, 같은 키를 순차적으로 비교하며 병합합니다.
   → 인덱스가 없고 범위 조건이 있거나, 대용량일 때 유리합니다.

3. **해시 조인(Hash Join)**:
   작은 테이블을 메모리에 올려 해시 테이블을 만든 후, 큰 테이블에서 해시 키를 탐색해 조인합니다.
   → 등가 조건(=) 조인에서 빠르고 효율적입니다.
   → MySQL 8.0.18부터 지원됩니다.

---

### ✅ Q2. 중첩 루프 조인은 어떤 상황에서 비효율적일 수 있나요?

**A.**
중첩 루프 조인은 모든 레코드를 반복문처럼 비교하기 때문에

* **대용량 테이블 간 조인**이나
* **인덱스가 없는 경우**
  → 각 레코드마다 반복 탐색을 하므로 **O(N²) 성능**이 되어 비효율적입니다.

실제로는 인덱스가 적절히 설정되어 있거나, 데이터 양이 적을 때만 권장됩니다.

---

### ✅ Q3. 해시 조인은 어떤 조건에서 가장 효율적인가요?

**A.**
해시 조인은 **등가 조건(=)** 에 기반한 조인에서 가장 효율적입니다.

* **작은 테이블을 메모리에 로딩**해 해시 테이블로 만든 뒤,
* 큰 테이블에서 키만 비교하여 조인 결과를 반환하므로,
  → **양쪽 테이블을 한 번씩만 읽는 구조**로 매우 빠릅니다.

단, 메모리에 적재할 수 있어야 하며, **범위 비교 (<, > 등)에는 사용할 수 없습니다.**

---

### ✅ Q4. 정렬 병합 조인은 어떤 조건에서 사용되며 어떤 장점이 있나요?

**A.**
정렬 병합 조인은 다음 조건에서 사용됩니다:

* **조인 컬럼에 적절한 인덱스가 없거나**,
* **<, >, BETWEEN 같은 범위 조건**이 있는 경우
* 또는 대용량 데이터를 조인해야 할 때 적합합니다.

장점은:

* 사전 정렬을 통해 비교를 최소화하고,
* 대량 데이터를 효율적으로 처리할 수 있다는 점입니다.

하지만 정렬 비용이 추가되므로, 사전에 인덱스가 잡혀 있다면 불필요할 수도 있습니다.

---

### ✅ Q5. MySQL에서 해시 조인은 언제부터 도입되었고, 어떻게 작동하나요?

**A.**
MySQL에서는 **8.0.18 버전부터 해시 조인**이 도입되었습니다. 작동 방식은 두 단계입니다:

1. **빌드 단계**:

    * 두 테이블 중 작은 쪽을 메모리에 로딩하고
    * 조인 키를 기준으로 해시 테이블을 생성합니다.

2. **프로브 단계**:

    * 다른 테이블의 각 레코드에 대해
    * 해시 키에 매칭되는 값을 찾아 조인 결과를 생성합니다.

이 방식은 **테이블 전체를 반복하지 않고**, 빠르게 원하는 키만 찾아 효율적입니다.

---

### ✅ Q6. 해시 조인이 메모리에 로딩되지 못할 정도로 큰 테이블이라면 어떻게 되나요?

**A.**
이 경우에는 디스크 기반 조인으로 전환되어 **성능이 급격히 저하**될 수 있습니다.

→ 이를 방지하기 위해:

* `join_buffer_size`와 같은 설정 값을 조정하거나,
* 조인 전에 **서브 쿼리나 필터링**으로 데이터를 줄이는 방식이 필요합니다.

---

### ✅ Q7. 실무에서는 어떤 조인 방식이 가장 많이 사용되나요?

**A.**
MySQL의 옵티마이저는 상황에 따라 **자동으로 적절한 조인 방식**을 선택합니다.

* 일반적으로 **중첩 루프 조인(NLJ)** 이 기본이며,
* 최신 버전에서는 **해시 조인도 자주 활용**됩니다.
* **정렬 병합 조인**은 비교적 덜 사용되지만, 범위 조건이 많거나 인덱스가 없을 때 사용됩니다.

**개발자는 실행 계획(EXPLAIN)** 을 통해 어떤 조인 방식이 선택되었는지 확인하고, 필요 시 인덱스 추가나 쿼리 구조 개선을 고려해야 합니다.

---

## ✅ 심화 질문과 답변

---

### ✅ Q1. 중첩 루프 조인의 성능이 떨어지는 이유는 무엇이며, 이를 개선하기 위한 방법은 무엇인가요?

**A.**
중첩 루프 조인(Nested Loop Join)은 외부 테이블의 각 행마다 내부 테이블을 전부 탐색하기 때문에 시간 복잡도가 **O(N × M)** 으로 큽니다. 특히 **인덱스가 없는 상태에서 대용량 조인** 시 성능 저하가 두드러집니다.

개선 방법으로는:

* **인덱스 추가**를 통해 내부 루프의 탐색 비용을 줄이거나,
* **Block Nested Loop Join**(BNL)을 사용해 블록 단위로 데이터를 읽어 I/O 횟수를 줄이는 방식이 있습니다.
* 또는 MySQL 8.0 이상에서는 **해시 조인**을 통해 효율을 극대화할 수도 있습니다.

---

### ✅ Q2. 정렬 병합 조인은 언제 사용하는 것이 적절하며, 어떤 단점이 있을까요?

**A.**
정렬 병합 조인(Sort Merge Join)은 다음과 같은 상황에서 적절합니다:

* **조인 키에 인덱스가 없는 경우**
* **조인 조건이 범위 조건(<, >, BETWEEN 등)** 인 경우
* **대용량 테이블을 조인할 때**

장점은 범용적이고, 정렬 후 병합으로 빠르게 비교가 가능하다는 것이고,
단점은 **정렬 비용이 크며, 메모리/디스크 정렬이 발생할 수 있다는 점**입니다.
즉, 테이블이 크고 메모리 정렬 버퍼가 부족하면 쿼리 성능이 급격히 저하될 수 있습니다.

---

### ✅ Q3. 해시 조인의 빌드 단계와 프로브 단계를 설명하고, 각 단계에서 주의할 점은 무엇인가요?

**A.**
해시 조인은 두 단계로 나뉩니다:

* **빌드 단계**:
  조인할 두 테이블 중 작은 쪽을 선택하여 **메모리에 해시 테이블을 생성**합니다. 이때 조인 조건의 컬럼이 **해시 키**로 사용됩니다.

* **프로브 단계**:
  큰 테이블의 각 레코드를 순차적으로 읽으며, 해시 키를 기반으로 **해시 테이블에서 매칭되는 값을 탐색**합니다.

**주의할 점:**

* 해시 조인은 **등가(=) 조건에만 사용 가능**하며, 범위 조인에서는 사용할 수 없습니다.
* 빌드 테이블이 메모리를 초과하면 **디스크 기반 해시 조인**으로 바뀌어 성능 저하가 생길 수 있습니다.
* 이때는 `join_buffer_size` 설정을 조정하거나, 조인 전에 **필터링으로 데이터 크기를 줄이는 전략**이 필요합니다.

---

### ✅ Q4. MySQL 옵티마이저는 조인 방식을 어떻게 선택하나요? 해시 조인을 강제로 사용할 수 있는 방법이 있나요?

**A.**
MySQL 옵티마이저는 테이블 통계 정보(레코드 수, 인덱스 유무, 조건절 등)를 기반으로 조인 전략(NLJ, BNL, Hash Join 등)을 **자동으로 선택**합니다.

MySQL 8.0.18 이후, 해시 조인을 강제로 사용하고 싶을 때는 다음 힌트를 사용합니다:

```sql
SELECT /*+ HASH_JOIN(t1, t2) */ * FROM t1 JOIN t2 ON t1.id = t2.id;
```

단, 해시 조인을 사용할 수 있는 조건(동등 조인, 적절한 메모리 크기 등)을 만족해야 옵티마이저가 이를 선택합니다.

---

### ✅ Q5. 블록 중첩 루프 조인(BNL)은 일반 중첩 루프 조인에 비해 어떤 장점이 있나요?

**A.**
Block Nested Loop Join(BNL)은 테이블을 블록 단위로 나누어 중첩 루프를 수행하기 때문에,
**I/O 접근 횟수를 줄이고 캐시 활용도를 높일 수 있는 장점**이 있습니다.

예를 들어 한 번에 여러 행을 읽어오고, 그 블록 안에서 조건 비교를 하기 때문에 디스크 접근 횟수가 감소합니다.
이는 특히 **인덱스가 없고, 두 테이블이 중간 정도의 크기일 때** 효과적입니다.

---

### ✅ Q6. 실제 운영 환경에서 "조인 성능이 너무 느리다"는 이슈가 발생했을 때 어떤 방식으로 분석하고 개선하겠습니까?

**A.**

1. **EXPLAIN으로 실행 계획 확인**

    * 어떤 조인 방식이 선택되었는지 파악합니다.
    * 인덱스 미사용, 풀 스캔 여부 등을 확인합니다.

2. **조인 조건 최적화**

    * 조인 대상 컬럼에 적절한 인덱스를 생성합니다.
    * 조인 순서를 바꾸거나 서브쿼리로 분리하는 전략을 검토합니다.

3. **데이터 분할 or 필터링**

    * 조인 전에 불필요한 데이터를 WHERE로 줄이도록 쿼리 구조를 수정합니다.

4. **옵티마이저 힌트 사용**

    * 필요한 경우 NLJ, HASH\_JOIN 등 힌트를 통해 옵티마이저를 유도할 수 있습니다.

5. **메모리 설정 확인**

    * `join_buffer_size`, `sort_buffer_size` 등 시스템 변수 조정을 검토합니다.

이 과정을 통해 조인 성능 병목 원인을 파악하고, 구조적인 개선 또는 인덱싱 전략을 수립할 수 있습니다.
