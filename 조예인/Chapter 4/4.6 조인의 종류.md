# 4.6 조인의 종류
- 조인(join) : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
  - MySQL에서는 JOIN이리는 쿼리로, MongoDB에서는 lookup이라는 쿼리로 이를 처리할 수 있음
- 참고로 MongoDB를 사용할 때 lookup은 되도록 사용하지 말아야 함 
  - MongoDB는 조인 연산(lookup)에 대해 관계형 데이터베이스보다 성능이 떨어진다고 여러 벤치마크 테스트에서 알려져 있음
- 따라서 여러 테이블을 조인하는 작업이 많을 경우 MongoDB보다는 관계형 데이터베이스를 써야 함
- 조인의 종류 중 대표적인 내부 조인, 왼쪽 조인, 오른쪽 조인, 합집합 조인을 살펴봄

✔️ 그림4-38 조인의 종류  <br>

<img src="https://github.com/user-attachments/assets/4ee45b9e-d868-4497-b74c-41a6311da73e" width="400"/>


- 앞의 그림처럼 두 테이블 간의 교집합이 있다고 할 때, 다음과 같은 네 가지 조인이 있음
  - 내부 조인(inner join): 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기 함
  - 왼쪽 조인(left outer join): 왼쪽 테이블의 모든 행이 결과 테이블에 표기됨
  - 오른쪽 조인(right outer join): 오른쪽 테이블의 모든 행이 결과 테이블에 표기됨
  - 합집합 조인(full outer join): 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기함

- SQL의 JOIN을 시각화해서 볼 수 있는 사이트가 있음 
- 이 사이트를 통해 어떻게 JOIN을 구축해야 하는지 쉽게 확인할 수 있음
- SQL JOIN 시각화 사이트 링크 : https://sql-joins.leopard.in.ua/
- 앞으로 설명할 때 왼쪽 테이블은 A, 오른쪽 테이블은 B라 하고 설명하겠습니다.

---

# 4.6.1 내부 조인
- 내부 조인은 두 테이블 간에 교집합을 나타냄
```SQL
   SELECT * FROM TableA A 
   INNER JOIN TableB B ON 
   A.key = B.key
```   

---

# 4.6.2 왼쪽 조인 
- 왼쪽 조인은 테이블 B의 일치하는 부분의 레코드와 합께 테이블 A률 기준으로 완전한 레코드 집합을 생성함 
- 만약 테이불 B에 일치하는 항목이 없으면 해당 값은 null 값이 됨
```SQL
   SELECT * FROM TableA A 
   LEFT JOIN TableB B ON 
   A.key = B.key
```  
---

# 4.6.3 오른쪽 조인
- 오른쪽 조인은 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성함 
- 만약 테이블 A에 일치하는 항목이 없으면 해당 값은 null 값이 됨
```SQL
   SELECT * FROM TableA A
   RIGHT JOIN TableB B ON 
   A.key = B.key
```  
---

# 4.6.4 합집합 조인 
- 합집합 조인(완전 외부 조인)은 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성함 
- 이때 일치하는 항목이 없으면 누락된 쪽에 null 값이 포함되어 출력됨
```SQL
   SELECT * FROM TableA A
   FULL OUTER JOIN TableB B ON 
   A.key = B.key
```

---
## ✅ 기본 질문과 답변

---

### ✅ Q1. 조인이란 무엇인가요?

**A.**
조인이란 **두 개 이상의 테이블을 특정 조건으로 묶어 하나의 결과 집합을 만드는 SQL 연산**입니다.
예를 들어, 사용자 정보와 주문 정보를 각각의 테이블로 나누어 저장하고 있을 때,
`user.id = order.user_id`를 기준으로 두 테이블을 조인하여 사용자의 주문 이력을 확인할 수 있습니다.

---

### ✅ Q2. 내부 조인(Inner Join)과 외부 조인의 차이는 무엇인가요?

**A.**

* **내부 조인 (INNER JOIN)**:
  조인 조건을 만족하는 **양쪽 테이블 모두에 존재하는 행만** 결과에 포함됩니다.
  → 교집합 개념입니다.

* \*\*외부 조인 (OUTER JOIN)\*\*은 조건에 맞지 않아도 **한쪽 테이블의 모든 행을 유지**합니다.

  * **LEFT OUTER JOIN**: 왼쪽(A) 테이블의 모든 행 포함. 오른쪽(B)은 조건 일치 시만 포함.
  * **RIGHT OUTER JOIN**: 오른쪽(B) 테이블의 모든 행 포함. 왼쪽(A)은 조건 일치 시만 포함.
  * **FULL OUTER JOIN**: 양쪽 모두 조건 불일치 시에도 NULL 포함해 전체 출력 (MySQL은 직접 지원 X, UNION으로 구현).

---

### ✅ Q3. LEFT JOIN과 RIGHT JOIN은 언제 사용하나요?

**A.**

* `LEFT JOIN`: 기준 테이블을 \*\*왼쪽 테이블(A)\*\*으로 둘 때 사용합니다.
  → 예: `모든 사용자`와 `그들의 주문 내역`을 보고 싶을 때, 사용자 테이블이 왼쪽이 되어야 합니다.

* `RIGHT JOIN`: 반대로 기준 테이블을 \*\*오른쪽 테이블(B)\*\*으로 둘 때 사용합니다.
  하지만 실제 SQL 작성 시에는 대부분 `LEFT JOIN`을 사용하고, **테이블 순서를 바꿔서** 처리하는 경우가 많습니다.

---

### ✅ Q4. FULL OUTER JOIN은 무엇인가요?

**A.**
FULL OUTER JOIN은 양쪽 테이블의 모든 행을 **모두 포함**시킵니다.
→ 조인 조건에 맞는 행은 결합되고, 맞지 않는 행은 NULL로 채워집니다.
MySQL에서는 직접 지원되지 않기 때문에 `LEFT JOIN UNION RIGHT JOIN`으로 구현합니다.

---

### ✅ Q5. MongoDB에서 JOIN은 어떻게 하나요? 실무에서는 어떻게 사용하나요?

**A.**
MongoDB에서는 SQL의 JOIN과 유사한 기능으로 **`$lookup` 연산자**를 사용합니다.
하지만 MongoDB는 JOIN 연산에 최적화된 구조가 아니기 때문에,

* `$lookup`은 **단순 조회용으로 최소한만** 사용하고,
* 대부분의 경우는 \*\*데이터를 중복 저장(Denormalization)\*\*하거나
* JOIN이 많이 필요한 구조라면 **관계형 DB(MySQL, PostgreSQL 등)** 사용을 권장합니다.

---

### ✅ Q6. 조인 시 성능 문제를 어떻게 해결할 수 있나요?

**A.**

* 조인에 사용되는 **컬럼에 인덱스**를 생성합니다.
* 조인 테이블의 크기를 **제한하거나 조건을 먼저 걸어서 필터링**합니다.
* **서브쿼리 대신 JOIN**, 또는 반대로 JOIN 대신 **서브쿼리**를 사용하는 방식으로 성능 비교합니다.
* MongoDB의 경우, `$lookup`이 포함된 쿼리는 **aggregation pipeline** 최적화가 필요합니다.

---

## ✅ 심화 질문과 답변

---

### ✅ Q1. `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL OUTER JOIN`의 차이를 설명하고, 각각 언제 사용하는 것이 적절한지 예시와 함께 설명해보세요.

**A.**

* `INNER JOIN`은 양쪽 테이블에 **일치하는 레코드만 조회**합니다.
  → 예: 유효한 사용자(user)와 그 사용자의 주문(order)을 조회할 때.
  `SELECT * FROM user u INNER JOIN order o ON u.id = o.user_id;`

* `LEFT JOIN`은 **왼쪽 테이블의 모든 레코드를 기준**으로, 오른쪽 테이블과 일치하지 않으면 NULL로 채워줍니다.
  → 예: **주문이 없는 사용자도 포함**해서 전체 사용자 리스트를 보여줄 때.

* `RIGHT JOIN`은 `LEFT JOIN`의 반대이며, 실무에서는 테이블 순서를 바꾸고 `LEFT JOIN`을 사용하는 것이 일반적입니다.

* `FULL OUTER JOIN`은 양쪽 테이블 **모든 레코드를 포함**해 보여주며, 일치하지 않는 값은 NULL로 표시됩니다.
  → 예: 사용자 또는 주문 테이블 중 **하나라도 존재하는 모든 데이터**를 조회하고 싶을 때.

---

### ✅ Q2. MongoDB에서 `$lookup`은 JOIN 역할을 하지만 사용을 지양하는 이유는 무엇인가요?

**A.**
MongoDB의 `$lookup`은 **관계형 데이터베이스의 JOIN과 비슷한 역할**을 하지만,

* MongoDB는 **비정규화된 문서 지향 데이터 구조**를 기반으로 설계되었기 때문에
* `$lookup`은 **성능이 매우 떨어지고**, **인덱스를 효율적으로 활용하기 어렵고**,
* **Aggregation Pipeline 처리 비용**이 크며 **스케일아웃이 어렵습니다**.

따라서 여러 컬렉션 간의 JOIN이 자주 발생하는 경우에는 **RDBMS를 사용하는 것이 더 적합**합니다.

---

### ✅ Q3. 실무에서 `LEFT JOIN`을 쓰면 성능이 떨어질 수 있다고 들었습니다. 이유는 무엇인가요?

**A.**
`LEFT JOIN`은 \*\*기준 테이블(A)\*\*의 모든 레코드를 유지한 채,
조건에 일치하지 않는 **오른쪽 테이블(B)** 값은 **NULL로 채워 반환**합니다.

* 이때 **오른쪽 테이블에 인덱스가 없거나**,
* `ON` 조건이 비효율적으로 작성되었거나,
* `LEFT JOIN` 결과에 `WHERE B.column IS NOT NULL` 같은 조건이 있으면 **사실상 INNER JOIN과 다를 바 없어져** 오히려 성능 저하가 발생할 수 있습니다.

또한 결과가 많아질 경우 **디스크 I/O 비용**이 커지고, 정렬이나 그룹핑 시 **임시 테이블 생성**이 성능을 악화시킬 수 있습니다.

---

### ✅ Q4. JOIN 최적화는 어떤 방식으로 할 수 있나요?

**A.**

* 조인되는 컬럼에 **인덱스를 생성**합니다.
* **조인 순서를 변경**해 기준 테이블의 데이터를 줄이는 방식으로 옵티마이저가 실행 계획을 개선하게 유도합니다.
* 조인 전에 **WHERE절로 필터링**해 대상 레코드를 줄입니다.
* 필요 시 **EXPLAIN** 또는 **실행 계획 도구**를 통해 쿼리를 분석하고 조인 방식(Nested Loop / Hash Join 등)을 확인합니다.
* MongoDB에서는 `$lookup` 대신 **서브 문서 중첩 구조로 재설계**하거나 **캐싱 전략**을 사용합니다.

---

### ✅ Q5. 실무에서 조인을 사용하다가 트래픽 증가로 인해 성능 병목이 생긴다면 어떻게 대응하시겠습니까?

**A.**

1. **쿼리 성능 분석**: `EXPLAIN`으로 쿼리 실행 계획 확인 → 비효율적인 조인 방식이나 full scan 여부 확인
2. **인덱스 재설계**: 조인 컬럼에 복합 인덱스 추가 또는 순서 조정
3. **비정규화 고려**: 조인 대상 데이터를 중복 저장하여 조인 자체를 제거
4. **데이터 캐싱**: Redis나 메모리 캐시로 자주 조회되는 결과를 저장
5. **배치 전환**: 실시간 쿼리가 아니라면 배치로 전환하여 비동기 처리

---

### ✅ Q6. FULL OUTER JOIN은 MySQL에서 기본 지원하지 않는데 어떻게 구현하나요?

**A.**
MySQL은 `FULL OUTER JOIN`을 지원하지 않기 때문에
다음과 같이 `UNION`을 사용해 구현합니다:

```sql
SELECT * FROM A LEFT JOIN B ON A.id = B.id
UNION
SELECT * FROM A RIGHT JOIN B ON A.id = B.id;
```

이렇게 하면 **양쪽 모두 포함하는 결과셋**을 얻을 수 있습니다.
단, 중복된 결과가 있을 경우 `UNION`은 제거하므로 `UNION ALL`을 쓸 수도 있습니다.

