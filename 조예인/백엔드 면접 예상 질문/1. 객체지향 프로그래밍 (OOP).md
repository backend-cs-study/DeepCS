# 1. 객체지향 프로그래밍 (OOP)
---
- **의도 :** 이 카테고리는 객체지향 프로그래밍(OOP)의 기본 개념을 이해하고 있는지 평가합니다. OOP는 백엔드 개발에서 매우 중요한 패러다임이므로, 지원자가 클래스, 객체, 상속, 다형성 등 OOP의 기본 원리를 제대로 이해하고, 실제 코딩에 어떻게 적용하는지를 확인하려고 합니다. 또한 디자인 패턴이나 SOLID 원칙을 알고 있으면, 지원자가 유지보수 가능한 코드를 작성할 수 있는 능력을 가진지 판단하는 데 도움이 됩니다.
- **답변에 포함해야 할 키워드**
  - 클래스(Class): 객체를 생성하기 위한 템플릿
  - 객체(Object): 클래스의 인스턴스, 상태와 동작을 가짐
  - 다형성(Polymorphism): 동일한 인터페이스를 구현하는 여러 객체가 다양한 방식으로 동작
  - 상속(Inheritance): 클래스 간 코드 재사용
  - 캡슐화(Encapsulation): 객체의 내부 상태를 숨기고 외부와 상호작용을 제어
  - SOLID 원칙: OOP 설계 원칙 (단일 책임, 개방-폐쇄 원칙 등)
---

### 1. \[하] Class와 Object에 대해 설명해주세요.

* **답변**
  - 클래스(Class)는 객체를 만들기 위한 설계도 또는 템플릿입니다. 
    - 변수(속성)와 메서드(기능)를 정의합니다. 
  - 객체(Object)는 클래스를 기반으로 생성된 실체로, 실제 데이터를 갖고 동작하는 인스턴스입니다. 
  - 예를 들어, `User`라는 클래스를 정의하면, 실제 사용자인 "홍길동"은 `User` 클래스의 객체입니다.

<details> 
<summary> 🧠 개념을 쉽게 정리하면?</summary>

### 1. **클래스**(Class)는 **설계도**예요.

* 예를 들어 "자동차"를 만드는 설계도(도면)가 있다고 해볼게요.
* 그 도면에는 자동차의 속성(예: 색상, 바퀴 수)과 기능(예: 운전하기, 멈추기)이 적혀 있겠죠?
* 실제로 자동차는 없지만, 이 도면만 보고 자동차를 **만들 수 있는 정보**가 담겨 있어요.
* 프로그래밍에서는 이 "설계도"가 바로 **클래스**입니다.

```java
class Car {
    String color;     // 속성
    void drive() {    // 기능
        System.out.println("달립니다!");
    }
}
```

### 2. **객체**(Object)는 **설계도를 바탕으로 만든 실제 물건**이에요.

* 위의 자동차 설계도를 바탕으로 만든 실제 자동차가 바로 객체입니다.
* 예를 들어 `빨간 자동차`를 만들었다면, 이건 `Car`라는 클래스(설계도)를 기반으로 만든 **객체**입니다.

```java
Car myCar = new Car();     // 객체 생성
myCar.color = "빨간색";     // 속성 설정
myCar.drive();            // 기능 실행 → "달립니다!"
```

* 여기서 `myCar`가 바로 **객체**예요.
* 객체는 클래스가 정의한 속성과 기능을 **가질 수 있고 사용할 수 있어요.**

## 📌 쉽게 비유하면?

| 개념          | 비유           | 예시                             |
| ----------- | ------------ | ------------------------------ |
| 클래스 (Class) | 쿠키 틀         | `User`, `Car`, `Animal` 같은 설계도 |
| 객체 (Object) | 쿠키 틀로 찍어낸 쿠키 | "홍길동 사용자", "빨간 자동차" 같은 실제 인스턴스 |

## 💬 다시 말해보면

> 클래스는 어떤 대상(사람, 자동차, 게시글 등)을 **정의해 놓은 설계도**고,
> 객체는 그 설계도를 바탕으로 **실제로 만들어진 것**이에요.

## ✅ 이해 체크 예제

```java
class User {
    String name;
    void sayHello() {
        System.out.println("안녕하세요, 저는 " + name + "입니다.");
    }
}
```

```java
User user1 = new User();   // 객체 생성
user1.name = "홍길동";       // 속성 설정
user1.sayHello();          // → "안녕하세요, 저는 홍길동입니다."
```

* `User`는 클래스
* `user1`은 객체
* `user1.name`은 객체의 속성
* `user1.sayHello()`는 객체의 기능 호출

</details>

---

### 2. \[중] Polymorphism 개념에 대해 설명하고, 개인/팀 프로젝트에 적용한 사례가 있다면 이야기해주세요.

* **답변**
  - 다형성(Polymorphism)은 같은 인터페이스를 공유하면서도 객체마다 다르게 동작할 수 있는 성질을 의미합니다.
  - 예를 들어, `NotificationSender`라는 인터페이스를 만들고, 
    - `EmailSender`, `SmsSender`, `PushSender`가 각각 이를 구현하도록 하면, 
    - 클라이언트는 `send()` 메서드만 호출하면 됩니다.
  - 저희 팀 프로젝트에서는 알림 시스템 구현 시 `NotificationSender` 인터페이스를 만들어 이메일, 푸시 알림을 다형적으로 처리했습니다.


<details>
<summary> 🧠 개념을 쉽게 정리하면?</summary>

- **다형성**은 "모양은 같지만 행동은 다르게!" 동작하는 개념이에요.
- 즉, 같은 이름의 메서드를 써도, 객체에 따라 다르게 실행돼요.

### 📦 예시로 쉽게 이해해볼게요!

```java
interface NotificationSender {
    void send(String message);
}

class EmailSender implements NotificationSender {
    public void send(String message) {
        System.out.println("이메일 전송: " + message);
    }
}

class SmsSender implements NotificationSender {
    public void send(String message) {
        System.out.println("SMS 전송: " + message);
    }
}
````

* `send()`라는 똑같은 이름의 메서드를 가지고 있지만,
* 어떤 **객체를 통해 호출하느냐에 따라** 동작이 달라져요.

### 💡 실제 프로젝트에서는?

* 알림 기능을 구현할 때, 이메일 알림, 푸시 알림 등 종류가 여러 개 있었어요.
* 그래서 `NotificationSender`라는 인터페이스를 만들고,
* 각 알림 방식(이메일, 푸시 등)에 맞게 클래스를 나눴어요.
* 클라이언트 입장에서는 `send()`만 호출하면 돼서 **코드가 단순해지고**, **유지보수도 쉬워졌어요!**

</details>

---

### 3. \[하] Encapsulation(캡슐화)이란 무엇인가요?

* **답변**
  - 캡슐화는 객체의 내부 데이터를 외부로부터 숨기고, 메서드를 통해서만 접근하도록 제한하는 개념입니다. 
  - 예를 들어, 클래스의 필드를 `private`으로 지정하고 `getter/setter`를 통해 접근을 제어하면 데이터 무결성을 유지할 수 있습니다.

<details>
<summary> 🧠 개념을 쉽게 정리하면?</summary>

- **캡슐화**는 말 그대로 "데이터를 캡슐처럼 감싸서 보호하는 것"이에요.
- 외부에서는 객체 내부에 직접 접근하지 못하게 막고, **정해진 방법으로만 접근**하도록 제한합니다.

### 🎁 왜 감싸나요?

- 외부에서 **잘못된 값**을 넣는 걸 방지하고,
- **데이터를 안전하게 보호**하면서 사용하려고요.

### 💡 쉬운 예시

```java
public class BankAccount {
    private int balance; // 잔액은 외부에서 바로 접근할 수 없음

    public void deposit(int amount) {
        if (amount > 0) balance += amount;
    }

    public int getBalance() {
        return balance;
    }
}
````

* `balance`는 **private** 이라서 외부에서 `account.balance = -1000` 이런 식으로 **잘못 바꾸지 못해요**.
* 오직 `deposit()`이나 `getBalance()` 같은 **public 메서드**를 통해서만 잔액을 다룰 수 있어요.

### 🧠 정리하면?

* 캡슐화는 "데이터를 보호하고, 정해진 통로로만 접근하게 한다."
* 객체를 안전하게 만들고, 예측 가능한 코드로 유지할 수 있게 도와줘요!

</details>
---

### 4. \[중] 상속(Inheritance)의 개념을 설명하고, 상속의 장단점을 이야기해주세요.

* **답변**
  - 상속은 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 구조입니다.
  - **장점:** 
    - 코드 재사용이 가능하고, 
    - 유지보수가 쉬움
  - **단점:** 
    - 부모 클래스에 종속되어 유연성이 떨어질 수 있고, 
    - 다중 상속이 제한적이며, 
    - 잘못된 상속 구조는 코드 복잡도를 높입니다.

<details>
<summary>🧠 개념을 쉽게 정리하면?</summary>

### ✅ 상속이란?

- **상속(Inheritance)**은 **부모 클래스의 속성과 기능(메서드)**을 **자식 클래스가 물려받는 것**이에요.
- 쉽게 말해, 부모 클래스가 만든 것을 자식 클래스가 **그대로 사용하거나, 필요하면 바꿔서 사용할 수 있어요.**

### 🏡 쉬운 예시

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("멍멍!");
    }
}
````

* `Dog`는 `Animal`의 자식 클래스예요.
* `Animal` 클래스에 있는 `sound()`를 **재정의(override)** 해서 `Dog`는 "멍멍!"이라고 울게 만들 수 있어요!

### 👍 장점

* **코드 재사용**: 부모 클래스에 공통 기능을 만들고, 자식들이 가져다 씀
* **유지보수 용이**: 수정할 때 한 곳만 고치면 여러 클래스에 반영됨
* **구조적 설계 가능**: 계층 구조(예: 부모 → 자식 → 손자 등)를 만들 수 있음

### 👎 단점

* **부모 클래스에 너무 의존**하면 유연성이 떨어짐 (→ 부모 바꾸면 자식 다 영향받음)
* **잘못된 상속 구조**는 오히려 코드를 더 복잡하게 만들 수 있음
* **Java에선 다중 상속 불가능** → 대신 인터페이스 사용

### 📌 정리

* 상속은 "물려받는다"는 개념이에요.
* 너무 남용하지 말고, **진짜 공통된 특징이 있을 때만** 쓰는 게 좋아요!

</details>

---

### 5. \[상] SOLID 원칙이란 무엇인지, 각 원칙을 설명해주세요.

* **답변**
  SOLID는 객체지향 설계의 5가지 원칙입니다.

1. **SRP(단일 책임 원칙):** 하나의 클래스는 하나의 책임만 가져야 함
2. **OCP(개방-폐쇄 원칙):** 확장에는 열려있고, 변경에는 닫혀 있어야 함
3. **LSP(리스코프 치환 원칙):** 자식 클래스는 부모 클래스를 대체할 수 있어야 함
4. **ISP(인터페이스 분리 원칙):** 클라이언트는 자신이 사용하는 메서드에만 의존해야 함
5. **DIP(의존성 역전 원칙):** 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 함

<details>
<summary>🧠 개념을 쉽게 정리하면?</summary>

### ✅ SOLID란?

- **SOLID**는 객체지향 설계에서 좋은 구조를 만들기 위한 **5가지 핵심 원칙**의 앞 글자를 따온 용어예요.
- 이 원칙들을 지키면 **유지보수하기 쉽고, 유연한 코드**를 만들 수 있어요!

### 1️⃣ SRP – 단일 책임 원칙 (Single Responsibility Principle)

- 📌 **한 클래스는 한 가지 일만 하자!**
- 예: `UserService`가 회원가입도 하고, 이메일도 보내고, 로그도 남긴다면 → 책임이 너무 많아요 😥  
→ 각각 클래스로 나눠서 관리해요.

### 2️⃣ OCP – 개방-폐쇄 원칙 (Open/Closed Principle)

- 📌 **기능을 추가할 수는 있어도, 기존 코드는 건들지 말자!**
- 예: 새로운 결제 수단(PayPal 등)을 추가할 때 기존 결제 코드 변경 없이 확장만 가능하도록 설계

```java
interface Payment {
    void pay();
}

class CardPayment implements Payment { ... }
class KakaoPay implements Payment { ... }
// 새로운 클래스 추가만 하면 끝!
````

### 3️⃣ LSP – 리스코프 치환 원칙 (Liskov Substitution Principle)

* 📌 **부모 클래스를 사용하는 곳에 자식 클래스를 넣어도 문제 없어야 해요!**
* 예: `Bird`가 있고 `Penguin`이 상속받았는데 `Penguin.fly()`가 에러난다면...? → LSP 위반이에요 😨
  → 자식이 부모 역할을 완전히 대체할 수 있어야 해요.

### 4️⃣ ISP – 인터페이스 분리 원칙 (Interface Segregation Principle)

* 📌 **필요한 기능만 인터페이스로 분리해서 사용하자!**
* 예: `Machine` 인터페이스에 `print()`, `scan()`, `fax()`가 다 있으면
  → 프린터만 쓰고 싶은 클래스도 `fax()`를 구현해야 해요 😓
  → 각각 인터페이스로 나누는 게 좋아요!

### 5️⃣ DIP – 의존성 역전 원칙 (Dependency Inversion Principle)

* 📌 **상위 클래스와 하위 클래스는 모두 추상화에 의존해야 해요!**
* 예: 클래스 내부에서 직접 구현체(new EmailSender())를 만들면 DIP 위반
  → 대신 `NotificationSender`라는 인터페이스에 의존하고, 외부에서 주입받도록 해요 (DI)

### ✅ 정리 그림

```
[S] 하나의 책임만
[O] 확장은 OK, 수정은 NO
[L] 자식은 부모처럼
[I] 나눠서 쓰자
[D] 추상화에 의존하자
```

</details>

---

### 6. \[상] 인터페이스(Interface)와 추상 클래스(Abstract Class)의 차이점은 무엇인가요?

* **답변**

  * **인터페이스**는 모든 메서드가 추상 메서드이며, 다중 구현이 가능합니다. 주로 기능(행위)을 정의합니다.
  * **추상 클래스**는 추상 메서드와 일반 메서드를 혼용할 수 있으며, 필드도 가질 수 있습니다. 
    * 공통 속성과 일부 구현을 공유할 때 사용합니다. 
  * 예를 들어, `Animal`은 추상 클래스, `Flyable`은 인터페이스로 나눌 수 있습니다.

---

### 7. \[중] 추상화(Abstraction)란 무엇이며, 코드로 어떻게 구현할 수 있는지 설명해주세요.

* **답변**
  - 추상화는 복잡한 내부 구현을 숨기고, 핵심 개념이나 기능만 노출하는 것입니다. 
  - Java나 Kotlin에서는 추상 클래스나 인터페이스를 사용해 추상화를 구현합니다.
  - 예: `PaymentService`라는 인터페이스를 만들고, `KakaoPayService`, `NaverPayService`가 각각 구현하여 결제 방식만 다르게 동작하도록 설계했습니다.

---

### 8. \[중] 다형성(Polymorphism)을 프로젝트에서 어떻게 활용했는지 예를 들어 설명해주세요.

* **답변**
  - 팀 프로젝트에서 알림 시스템 구현 시 `AlarmSender` 인터페이스를 정의하고, 
  - `EmailAlarmSender`, `FcmAlarmSender`가 각각 구현체가 되어 `send()` 메서드를 오버라이딩했습니다.
  - 클라이언트는 `AlarmSender sender = senderFactory.get(channel)` 형태로 인터페이스만 보고 동작했고, 확장에 유리한 구조를 만들 수 있었습니다.

---

### 9. \[상] 의존성 주입(Dependency Injection)이란 무엇이며, 이를 적용했을 때의 장점을 설명해주세요.

* **답변**
  - 의존성 주입은 클래스 내부에서 직접 의존 객체를 생성하지 않고 외부에서 주입받는 방식입니다. Spring에서는 생성자 주입 방식이 가장 보편적입니다.
  - 장점: 테스트 용이성, 결합도 감소, 유연한 확장, 객체 생명주기 관리
  - 예: `UserService`가 `UserRepository`에 의존할 때, `@RequiredArgsConstructor`를 통해 생성자 주입을 사용했습니다.

---

### 10. \[상] 디자인 패턴 중 싱글톤(Singleton) 패턴을 설명하고, 실제로 구현할 때 고려해야 할 사항을 이야기해주세요.

* **답변**
  - 싱글톤은 클래스의 인스턴스를 하나만 생성하고, 전역적으로 공유하도록 하는 패턴입니다.
  - Spring에서 `@Service`, `@Component`가 기본적으로 싱글톤으로 관리됩니다.
  - 고려 사항:

  * 멀티스레드 환경에서는 `double-checked locking`으로 동기화 필요
  * 테스트 시 전역 상태로 인해 side effect 주의
  * 의존성 주입과 함께 사용하는 것이 이상적

---

### 11. \[중] 객체지향 설계에서 SRP(단일 책임 원칙)가 지켜지지 않으면 어떤 문제가 발생할 수 있나요? 이를 해결한 경험이 있다면 설명해 주세요.

* **답변**
  - SRP를 지키지 않으면 하나의 클래스가 여러 이유로 변경되므로, 유지보수가 어려워지고 테스트도 복잡해집니다.
  - 예를 들어, `ReservationService`에서 예약 로직과 알림 전송을 함께 처리했을 때 변경 시 영향 범위가 커졌습니다. 이를 `ReservationService`와 `NotificationService`로 분리하면서 SRP를 지켰고, 테스트와 유지보수가 수월해졌습니다.

---

### 12. \[상] 의존성 주입을 프로젝트에 어떻게 적용했고, 이를 통해 얻은 장점은 무엇인가요?

* **답변**
  - 알림 시스템에서 `AlarmService`가 다양한 `AlarmSender` 구현체에 의존할 때, 생성자 주입으로 DI를 적용했습니다.
  - `@Qualifier`나 `@Component` 기반으로 다양한 채널을 주입받을 수 있었고, 테스트 시 Mock 객체를 손쉽게 주입할 수 있어 테스트 코드 작성이 편리했습니다.

---

### 13. \[중] 다형성을 통해 인터페이스와 구현체를 분리하여 설계한 예시를 설명해 주세요.

* **답변**
  - `ParkingPaymentService` 인터페이스를 정의하고, `KakaoPaymentService`, `NaverPaymentService` 등으로 구현을 분리했습니다.
  - 클라이언트 코드에서는 `paymentService.pay()`만 호출하면 되므로, 새 결제 수단이 추가돼도 기존 코드는 수정 없이 확장할 수 있었습니다.

---

### 14. \[중] 상속(Inheritance) 대신 구성(Composition)을 사용하는 것이 더 적합한 경우는 언제인가요? 이유와 함께 설명해 주세요.

* **답변**
  - 상속은 "is-a" 관계일 때 적절하고, 구성은 "has-a" 관계일 때 적합합니다.
  - 예를 들어, `NotificationManager`가 `Logger` 기능이 필요할 경우, 상속이 아닌 Logger 객체를 주입(구성)하는 것이 더 유연합니다.
  - 구성은 런타임에 다른 구현체로 바꾸기 쉬워 테스트와 유지보수에 유리합니다.

---

### 15. \[상] 디자인 패턴 중 싱글톤을 사용했을 때 발생할 수 있는 문제점과 해결 방안을 설명해 주세요.

* **답변**
  문제점:

  * 전역 상태로 인해 테스트 간 side effect 발생 가능
  * 멀티스레드 환경에서 동시성 문제
    해결 방안:
  * Spring의 Bean 스코프 활용
  * 테스트에서는 `@DirtiesContext` 혹은 `MockBean` 활용
  * 동기화 문제는 `enum Singleton`, `synchronized`, `volatile`로 해결 가능

---

