# 1. 객체지향 프로그래밍 (OOP)
---
- **의도 :** 이 카테고리는 객체지향 프로그래밍(OOP)의 기본 개념을 이해하고 있는지 평가합니다. OOP는 백엔드 개발에서 매우 중요한 패러다임이므로, 지원자가 클래스, 객체, 상속, 다형성 등 OOP의 기본 원리를 제대로 이해하고, 실제 코딩에 어떻게 적용하는지를 확인하려고 합니다. 또한 디자인 패턴이나 SOLID 원칙을 알고 있으면, 지원자가 유지보수 가능한 코드를 작성할 수 있는 능력을 가진지 판단하는 데 도움이 됩니다.
- **답변에 포함해야 할 키워드**
  - 클래스(Class): 객체를 생성하기 위한 템플릿
  - 객체(Object): 클래스의 인스턴스, 상태와 동작을 가짐
  - 다형성(Polymorphism): 동일한 인터페이스를 구현하는 여러 객체가 다양한 방식으로 동작
  - 상속(Inheritance): 클래스 간 코드 재사용
  - 캡슐화(Encapsulation): 객체의 내부 상태를 숨기고 외부와 상호작용을 제어
  - SOLID 원칙: OOP 설계 원칙 (단일 책임, 개방-폐쇄 원칙 등)
---

### 1. \[하] Class와 Object에 대해 설명해주세요.

* **답변**
  - 클래스(Class)는 객체를 만들기 위한 설계도 또는 템플릿입니다. 
  - 변수(속성)와 메서드(기능)를 정의합니다. 
  - 객체(Object)는 클래스를 기반으로 생성된 실체로, 실제 데이터를 갖고 동작하는 인스턴스입니다. 
  - 예를 들어, `User`라는 클래스를 정의하면, 실제 사용자인 "홍길동"은 `User` 클래스의 객체입니다.

---

### 2. \[중] Polymorphism 개념에 대해 설명하고, 개인/팀 프로젝트에 적용한 사례가 있다면 이야기해주세요.

* **답변**
  - 다형성(Polymorphism)은 같은 인터페이스를 공유하면서도 객체마다 다르게 동작할 수 있는 성질을 의미합니다.
  - 예를 들어, `NotificationSender`라는 인터페이스를 만들고, 
  - `EmailSender`, `SmsSender`, `PushSender`가 각각 이를 구현하도록 하면, 
  - 클라이언트는 `send()` 메서드만 호출하면 됩니다.
  - 저희 팀 프로젝트에서는 알림 시스템 구현 시 `NotificationSender` 인터페이스를 만들어 이메일, 푸시 알림을 다형적으로 처리했습니다.

---

### 3. \[하] Encapsulation(캡슐화)이란 무엇인가요?

* **답변**
  - 캡슐화는 객체의 내부 데이터를 외부로부터 숨기고, 메서드를 통해서만 접근하도록 제한하는 개념입니다. 
  - 예를 들어, 클래스의 필드를 `private`으로 지정하고 `getter/setter`를 통해 접근을 제어하면 데이터 무결성을 유지할 수 있습니다.

---

### 4. \[중] 상속(Inheritance)의 개념을 설명하고, 상속의 장단점을 이야기해주세요.

* **답변**
  - 상속은 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 구조입니다.
  - **장점:** 
    - 코드 재사용이 가능하고, 
    - 유지보수가 쉬움
  - **단점:** 
    - 부모 클래스에 종속되어 유연성이 떨어질 수 있고, 
    - 다중 상속이 제한적이며, 
    - 잘못된 상속 구조는 코드 복잡도를 높입니다.

---

### 5. \[상] SOLID 원칙이란 무엇인지, 각 원칙을 설명해주세요.

* **답변**
  SOLID는 객체지향 설계의 5가지 원칙입니다.

1. **SRP(단일 책임 원칙):** 하나의 클래스는 하나의 책임만 가져야 함
2. **OCP(개방-폐쇄 원칙):** 확장에는 열려있고, 변경에는 닫혀 있어야 함
3. **LSP(리스코프 치환 원칙):** 자식 클래스는 부모 클래스를 대체할 수 있어야 함
4. **ISP(인터페이스 분리 원칙):** 클라이언트는 자신이 사용하는 메서드에만 의존해야 함
5. **DIP(의존성 역전 원칙):** 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 함

---

### 6. \[상] 인터페이스(Interface)와 추상 클래스(Abstract Class)의 차이점은 무엇인가요?

* **답변**

  * **인터페이스**는 모든 메서드가 추상 메서드이며, 다중 구현이 가능합니다. 주로 기능(행위)을 정의합니다.
  * **추상 클래스**는 추상 메서드와 일반 메서드를 혼용할 수 있으며, 필드도 가질 수 있습니다. 공통 속성과 일부 구현을 공유할 때 사용합니다.
    예를 들어, `Animal`은 추상 클래스, `Flyable`은 인터페이스로 나눌 수 있습니다.

---

### 7. \[중] 추상화(Abstraction)란 무엇이며, 코드로 어떻게 구현할 수 있는지 설명해주세요.

* **답변**
  - 추상화는 복잡한 내부 구현을 숨기고, 핵심 개념이나 기능만 노출하는 것입니다. 
  - Java나 Kotlin에서는 추상 클래스나 인터페이스를 사용해 추상화를 구현합니다.
  - 예: `PaymentService`라는 인터페이스를 만들고, `KakaoPayService`, `NaverPayService`가 각각 구현하여 결제 방식만 다르게 동작하도록 설계했습니다.

---

### 8. \[중] 다형성(Polymorphism)을 프로젝트에서 어떻게 활용했는지 예를 들어 설명해주세요.

* **답변**
  - 팀 프로젝트에서 알림 시스템 구현 시 `AlarmSender` 인터페이스를 정의하고, 
  - `EmailAlarmSender`, `FcmAlarmSender`가 각각 구현체가 되어 `send()` 메서드를 오버라이딩했습니다.
  - 클라이언트는 `AlarmSender sender = senderFactory.get(channel)` 형태로 인터페이스만 보고 동작했고, 확장에 유리한 구조를 만들 수 있었습니다.

---

### 9. \[상] 의존성 주입(Dependency Injection)이란 무엇이며, 이를 적용했을 때의 장점을 설명해주세요.

* **답변**
  - 의존성 주입은 클래스 내부에서 직접 의존 객체를 생성하지 않고 외부에서 주입받는 방식입니다. Spring에서는 생성자 주입 방식이 가장 보편적입니다.
  - 장점: 테스트 용이성, 결합도 감소, 유연한 확장, 객체 생명주기 관리
  - 예: `UserService`가 `UserRepository`에 의존할 때, `@RequiredArgsConstructor`를 통해 생성자 주입을 사용했습니다.

---

### 10. \[상] 디자인 패턴 중 싱글톤(Singleton) 패턴을 설명하고, 실제로 구현할 때 고려해야 할 사항을 이야기해주세요.

* **답변**
  - 싱글톤은 클래스의 인스턴스를 하나만 생성하고, 전역적으로 공유하도록 하는 패턴입니다.
  - Spring에서 `@Service`, `@Component`가 기본적으로 싱글톤으로 관리됩니다.
  - 고려 사항:

  * 멀티스레드 환경에서는 `double-checked locking`으로 동기화 필요
  * 테스트 시 전역 상태로 인해 side effect 주의
  * 의존성 주입과 함께 사용하는 것이 이상적

---

### 11. \[중] 객체지향 설계에서 SRP(단일 책임 원칙)가 지켜지지 않으면 어떤 문제가 발생할 수 있나요? 이를 해결한 경험이 있다면 설명해 주세요.

* **답변**
  - SRP를 지키지 않으면 하나의 클래스가 여러 이유로 변경되므로, 유지보수가 어려워지고 테스트도 복잡해집니다.
  - 예를 들어, `ReservationService`에서 예약 로직과 알림 전송을 함께 처리했을 때 변경 시 영향 범위가 커졌습니다. 이를 `ReservationService`와 `NotificationService`로 분리하면서 SRP를 지켰고, 테스트와 유지보수가 수월해졌습니다.

---

### 12. \[상] 의존성 주입을 프로젝트에 어떻게 적용했고, 이를 통해 얻은 장점은 무엇인가요?

* **답변**
  - 알림 시스템에서 `AlarmService`가 다양한 `AlarmSender` 구현체에 의존할 때, 생성자 주입으로 DI를 적용했습니다.
  - `@Qualifier`나 `@Component` 기반으로 다양한 채널을 주입받을 수 있었고, 테스트 시 Mock 객체를 손쉽게 주입할 수 있어 테스트 코드 작성이 편리했습니다.

---

### 13. \[중] 다형성을 통해 인터페이스와 구현체를 분리하여 설계한 예시를 설명해 주세요.

* **답변**
  - `ParkingPaymentService` 인터페이스를 정의하고, `KakaoPaymentService`, `NaverPaymentService` 등으로 구현을 분리했습니다.
  - 클라이언트 코드에서는 `paymentService.pay()`만 호출하면 되므로, 새 결제 수단이 추가돼도 기존 코드는 수정 없이 확장할 수 있었습니다.

---

### 14. \[중] 상속(Inheritance) 대신 구성(Composition)을 사용하는 것이 더 적합한 경우는 언제인가요? 이유와 함께 설명해 주세요.

* **답변**
  - 상속은 "is-a" 관계일 때 적절하고, 구성은 "has-a" 관계일 때 적합합니다.
  - 예를 들어, `NotificationManager`가 `Logger` 기능이 필요할 경우, 상속이 아닌 Logger 객체를 주입(구성)하는 것이 더 유연합니다.
  - 구성은 런타임에 다른 구현체로 바꾸기 쉬워 테스트와 유지보수에 유리합니다.

---

### 15. \[상] 디자인 패턴 중 싱글톤을 사용했을 때 발생할 수 있는 문제점과 해결 방안을 설명해 주세요.

* **답변**
  문제점:

  * 전역 상태로 인해 테스트 간 side effect 발생 가능
  * 멀티스레드 환경에서 동시성 문제
    해결 방안:
  * Spring의 Bean 스코프 활용
  * 테스트에서는 `@DirtiesContext` 혹은 `MockBean` 활용
  * 동기화 문제는 `enum Singleton`, `synchronized`, `volatile`로 해결 가능

---

