# 1.1 디자인 패턴

## 디자인 패턴이란?
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

## 1.1.1 싱글톤 패턴(Singleton Pattern)
- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 보통 데이터베이스 연결 모듈에 많이 사용

```java
public class Singleton {
    // 정적 참조 변수(싱글톤 객체를 담을 변수)
    private static Singleton singletonObject;
    
    // private 생성자
    private Singleton() {
    }
    
    // getInstance()
    public static Singleton getInstance() {
        if (singletonObject == null) {
            singletonObject = new Singleton();
        }
        return singletonObject;
    }
}
```

- ### 싱글톤 패턴의 장점
  - 인스턴스를 생성할 때 드는 비용이 줄어듬
- ### 싱글톤 패턴의 단점
  - 의존성이 높아짐(모듈 간의 결합을 강하게 만듬)
  - 각 단위 테스트마다 '독립적인' 인스턴스를 만들기 어려움
- ### 의존성 주입(DI, Dependency Injection)
  - 싱글톤 패턴에서 모듈 간 결합을 느슨하게 만드는 방법이 필요함 
  - 모듈 간 필요한 의존성을 중간에서 의존성 주입자를 통해 '간접적'으로 의존성을 주입하는 방식 사용
  - 의존성 주입을 통해 모듈들을 쉽게 교체할 수 있는 구조가 되어 '테스팅'하기 쉬워짐
  - 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 페널티가 생기기도 함

## 1.1.2 팩토리 패턴(Factory Pattern)
- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
- 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정함

```java
abstract class Coffee {
    protected String name;
    
    public String getName() {
        return name;
    }
}

class Latte extends Coffee {
    public Latte() {
        name = "Latte";
    }
}

class Espresso extends Coffee {
    public Espresso() {
        name = "Espresso";
    }
}
```

- ### 팩토리 패턴의 장점
  - 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가짐
  - 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 됨
  - 코드의 유지 보수성이 증가됨

## 1.1.3 전략 패턴(Strategy Pattern)
- 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
- 예를 들어, 특정 행위에 대한 기본 인터페이스를 구현하고 구체적인 행동을 구현하는 클래스를 생성하는 방식으로 전략 패턴을 구현할 수 있음

- ### 전략 패턴의 장점
  - 직접 행위에 대한 코드를 수정할 필요 없이 전략만 변경하면 되기 때문에 **유연한 확장 가능**
  - 같은 문제를 해결하는 여러 알고리즘이 캡슐화되어 있기 때문에 필요시에 교체가 쉽고, **다른 클래스에 영향을 주지 않고도 수정이 가능**
  
## 1.1.4 옵저버 패턴(Observer Pattern)
- 어떤 객체의 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴
- 옵저버 : 객체의 상태 변화에 따라 '추가 변화 사항'이 생기는 객체
- 주로 이벤트 기반 시스템에 사용하며 MVC 패턴에도 사용됨
  - 모델(model)에서 변경 사항이 생겨 update() 메서드로 옵저버인 뷰(view)에 알려주고 이를 기반으로 컨트롤러(controller) 등이 작동하는 방식

- ### 옵저버 패턴의 장점
  - 느슨한 결합을 가짐
    - 옵저버를 언제든 새로 추가, 제거할 수 있다.
    - 새로운 형식의 옵저버라 할 지라도 주체를 전혀 변경할 필요가 없다.
    - 주체와 옵저버는 서로 독립적으로 재사용 할 수 있다.
    - 주체나 옵저버가 바뀌더라도 서로에게 영향을 미치지 않는다.

## 1.1.5 프록시 패턴(Proxy Pattern)
- ### 프록시
  - 사전적인 의미는 '대리인'이라는 뜻
  - 클라이언트가 대상 객체를 직접 쓰는게 아니라 중간에 프록시(대리인)을 거쳐서 쓰는 코드 패턴
- ### 프록시 패턴
  - 대상 객체에 접근하기 전 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 존재함
  - 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용됨
    - 보안 : 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사 결과가 긍정적인 경우에만 요청을 대상으로 전달
    - 데이터 검증 : 프록시가 입력을 대상으로 전달하기 전에 유효성을 검사
    - 캐싱 : 프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 함
    - 로깅 : 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록
- ### 프록시 서버
  - 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램

## 1.1.6 이터레이터 패턴(Iterator Pattern)
- 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
- 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 컬렉션 순회가 가능

## 1.1.7 노출모듈 패턴(Revealing Module Pattern)
- 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴

## 1.1.8 MVC 패턴(Model, View, Controller)
- 모델, 뷰, 컨트롤러로 이루어진 디자인 패턴
- 애플리케이션의 구성 요소를 세 가지 역할로 구분
  - 모델 : 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함 **(뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신)**
  - 뷰 : 사용자 인터페이스 요소를 나타냄. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면 **(변경이 일어나면 컨트롤러에 이를 전달)**
  - 컨트롤러 : 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 함. 이벤트 등 메인 로직을 담당 **(모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줌)**
- 대표적인 프레임워크로는 스프링(Spring)이 있음

- ### MVC 패턴의 장점
  - 재사용성과 확장성이 용이
- ### MVC 패턴의 단점
  - 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐

## 1.1.9 MVP 패턴(Model, View, Presenter)
- MVC 패턴으로부터 파생되었으며 컨트롤러가 프레젠터(presenter)로 교체된 패턴
- 뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴임

## 1.1.10 MVVM 패턴(Model, View, View Model)
- 컨트롤러가 뷰모델(View Model)로 바뀐 패턴
- 뷰모델은 뷰를 더 추상화한 계층이며, 커맨드와 데이터 바인딩을 가지는 것이 특징임
  - 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원