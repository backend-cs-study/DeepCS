# 1.2 프로그래밍 패러다임

## 프로그래밍 패러다임이란?
프로그래밍의 관점을 갖게 해주는 역할을 하는 **개발 방법론**  

| 분류 | 종류 |
|:---:|:---:|
|선언형|함수형|
|명령형|객체지향형, 절차지향형|

## 1.2.1 선언형과 함수형 프로그래밍
- 선언형 프로그래밍(Declarative Programming) : '무엇을' 풀어내는가에 집중하는 패러다임
- 함수형 프로그래밍(Functional Programming) : 모든 것을 순수한 함수 스타일로 묶으려고 하는 프로그래밍 패러다임
- 개발자 혹은 어떤 것이 무엇을 하는지에 더 관심을 가지는 것
- '기계의 작동 모델'보다 '개발자의 정신 모델'에 더 부합하는 방식으로 프로그래밍
- 선언적 문장으로 프로그래밍 
- 제어 흐름, 알고리즘을 설명하지 않고 그 연산의 논리를 표현하는 패러다임

쉽게 말해 `프로그래머가 무엇을 하고 싶은지 기술` 하는 방식의 프로그래밍  
작은 '순수 함수'들을 블록처럼 쌓아 로직을 구현하고 '고차 함수'를 통해 재사용성을 높인 프로그래밍 패러다임  
`고차 함수가 어떻게 구현되는지는 신경 쓰지 않고 그 사용 목적만을 알고 사용하는 것`  
대표적인 함수형 프로그래밍 언어로는 `자바스크립트`가 있음

- ### 순수 함수
  - 출력이 입력에만 의존
  - 항상 동일한 인수에 대해 동일한 출력을 생성
  - 순수 함수의 유일한 결과는 반환하는 값임
  - 또한 사이드 이펙트가 존재하지 않음
```js
const pure = (a, b) => {
    return a + b
}
```

- ### 고차 함수
  - 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 의미
  - 함수를 인수로 받거나, 함수를 반환하는 함수

- ### 일급 객체
  - 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야 함
    - 변수나 메서드에 함수를 할당 가능
    - 함수 안에 함수를 매개변수로 담을 수 있어야 함
    - 함수가 함수를 반환할 수 있음

## 1.2.2 객체지향 프로그래밍(OOP, Object-Oriented Programming)
- 객체들의 집합으로 프로그램의 상호 작용을 표현
- 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
- 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림
```js
const ret = [1, 2, 3, 4, 5, 11, 12]
class List {
    constructor(list) {
        this.list = list
        this.mx = list.reduce((max, num) => num > max ? num : max, 0)
    }
    getMax() {
        return this.mx
    }
}
```
- 객체지향 프로그래밍의 특징으로는 추상화, 캡슐화, 상속성, 다형성이 있음
  - 추상화 : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것  
    `공통적인 특성을 파악한 후, 필요 없는 특성을 제거해 하나의 묶음으로 만들어내는 과정`
  - 캡슐화 : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것  
    `캡슐화는 높은 응집도와 낮은 결합도를 유지함. 즉, 한 곳에서 변화가 일어나도 다른곳에 미치는 영향을 최소화 함`
  - 상속성 : 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것  
    `기존 코드를 재활용해서 사용함으로써 코드의 생산성을 높여줌`
  - 다형성 : 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것  
    `동일한 명령을 각자 연결된 객체에 의존해서 해석하는 것을 뜻함`
    - 오버로딩 : 같은 이름을 가진 메서드를 여러 개 두는 것. (메서드의 타입, 매개변수의 유형, 개수 등으로 분리)
    - 오버라이딩 : 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것

- ### 설계 원칙(SOLID)
  - 단일 책임 원칙(SRP, Single responsibility Principle)  
  `모든 클래스는 각각 하나의 책임만 가져야 함`  
  어떠한 클래스는 A에 관한 클래스여야 하고 이를 수정한다고 했을 때도 A와 관련된 수정이어야 함
  - 개방-폐쇄 원칙(OCP, Open Closed Principle)  
  `유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 함`  
  기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 함
  - 리스코프 치환 법칙(LSP, Liskov Substitution Principle)  
  `프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함`  
  부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가게 만드는 것을 말함
  - 인터페이스 분리 원칙(ISP, Interface Segregation Principle)  
  `하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 함`
  - 의존 역전 원칙(DIP, Dependency Inversion Principle)  
  `추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙`  
  상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 함

## 1.2.3 절차형 프로그래밍
- 절차형 프로그래밍에서 로직은 수행되어야 할 연속적인 계산 과정으로 이루어져 있음
- 코드의 가독성이 좋으며 실행 속도가 빠름
- 모듈화하기 어렵고 유지 보수성이 떨어짐

## 1.2.4 패러다임의 혼합
- 어떠한 패러다임이 가장 좋은지에 대한 정답은 없음
- 비즈니스 로직이나 서비스의 특징을 고려해서 가장 적합한 패러다임을 정하는 것이 중요함
- 여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는 것도 좋은 방법임